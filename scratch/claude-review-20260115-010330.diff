diff --git a/.detect-secrets.cfg b/.detect-secrets.cfg
new file mode 100644
index 000000000..66ed5236e
--- /dev/null
+++ b/.detect-secrets.cfg
@@ -0,0 +1,26 @@
+# detect-secrets exclusion patterns (regex)
+#
+# Note: detect-secrets does not read this file by default. If you want these
+# applied, wire them into your scan command (e.g. translate to --exclude-files
+# / --exclude-lines) or into a baseline's filters_used.
+
+[exclude-files]
+# pnpm lockfiles contain lots of high-entropy package integrity blobs.
+pattern = (^|/)pnpm-lock\.yaml$
+
+[exclude-lines]
+# Fastlane checks for private key marker; not a real key.
+pattern = key_content\.include\?\("BEGIN PRIVATE KEY"\)
+# UI label string for Anthropic auth mode.
+pattern = case \.apiKeyEnv: "API key \(env var\)"
+# CodingKeys mapping uses apiKey literal.
+pattern = case apikey = "apiKey"
+# Schema labels referencing password fields (not actual secrets).
+pattern = "gateway\.remote\.password"
+pattern = "gateway\.auth\.password"
+# Schema label for talk API key (label text only).
+pattern = "talk\.apiKey"
+# checking for typeof is not something we care about.
+pattern = === "string"
+# specific optional-chaining password check that didn't match the line above.
+pattern = typeof remote\?\.password === "string"
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index e741444b8..8aa0b410b 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -74,9 +74,9 @@ jobs:
           - runtime: node
             task: protocol
             command: pnpm protocol:check
-          - runtime: node
-            task: format
-            command: pnpm format
+          - runtime: bun
+            task: lint
+            command: bunx biome check src
           - runtime: bun
             task: test
             command: bunx vitest run
diff --git a/.github/workflows/install-smoke.yml b/.github/workflows/install-smoke.yml
index b7e8e274e..a1c931615 100644
--- a/.github/workflows/install-smoke.yml
+++ b/.github/workflows/install-smoke.yml
@@ -29,5 +29,4 @@ jobs:
           CLAWDBOT_INSTALL_CLI_URL: https://clawd.bot/install-cli.sh
           CLAWDBOT_NO_ONBOARD: "1"
           CLAWDBOT_INSTALL_SMOKE_SKIP_CLI: "1"
-          CLAWDBOT_INSTALL_SMOKE_PREVIOUS: "2026.1.11-4"
         run: pnpm test:install:smoke
diff --git a/.secrets.baseline b/.secrets.baseline
new file mode 100644
index 000000000..4c0ca50a4
--- /dev/null
+++ b/.secrets.baseline
@@ -0,0 +1,518 @@
+{
+  "version": "1.5.0",
+  "plugins_used": [
+    {
+      "name": "ArtifactoryDetector"
+    },
+    {
+      "name": "AWSKeyDetector"
+    },
+    {
+      "name": "AzureStorageKeyDetector"
+    },
+    {
+      "name": "Base64HighEntropyString",
+      "limit": 4.5
+    },
+    {
+      "name": "BasicAuthDetector"
+    },
+    {
+      "name": "CloudantDetector"
+    },
+    {
+      "name": "DiscordBotTokenDetector"
+    },
+    {
+      "name": "GitHubTokenDetector"
+    },
+    {
+      "name": "GitLabTokenDetector"
+    },
+    {
+      "name": "HexHighEntropyString",
+      "limit": 3.0
+    },
+    {
+      "name": "IbmCloudIamDetector"
+    },
+    {
+      "name": "IbmCosHmacDetector"
+    },
+    {
+      "name": "IPPublicDetector"
+    },
+    {
+      "name": "JwtTokenDetector"
+    },
+    {
+      "name": "KeywordDetector",
+      "keyword_exclude": ""
+    },
+    {
+      "name": "MailchimpDetector"
+    },
+    {
+      "name": "NpmDetector"
+    },
+    {
+      "name": "OpenAIDetector"
+    },
+    {
+      "name": "PrivateKeyDetector"
+    },
+    {
+      "name": "PypiTokenDetector"
+    },
+    {
+      "name": "SendGridDetector"
+    },
+    {
+      "name": "SlackDetector"
+    },
+    {
+      "name": "SoftlayerDetector"
+    },
+    {
+      "name": "SquareOAuthDetector"
+    },
+    {
+      "name": "StripeDetector"
+    },
+    {
+      "name": "TelegramBotTokenDetector"
+    },
+    {
+      "name": "TwilioKeyDetector"
+    }
+  ],
+  "filters_used": [
+    {
+      "path": "detect_secrets.filters.allowlist.is_line_allowlisted"
+    },
+    {
+      "path": "detect_secrets.filters.common.is_baseline_file",
+      "filename": ".secrets.baseline"
+    },
+    {
+      "path": "detect_secrets.filters.common.is_ignored_due_to_verification_policies",
+      "min_level": 2
+    },
+    {
+      "path": "detect_secrets.filters.heuristic.is_indirect_reference"
+    },
+    {
+      "path": "detect_secrets.filters.heuristic.is_likely_id_string"
+    },
+    {
+      "path": "detect_secrets.filters.heuristic.is_lock_file"
+    },
+    {
+      "path": "detect_secrets.filters.heuristic.is_not_alphanumeric_string"
+    },
+    {
+      "path": "detect_secrets.filters.heuristic.is_potential_uuid"
+    },
+    {
+      "path": "detect_secrets.filters.heuristic.is_prefixed_with_dollar_sign"
+    },
+    {
+      "path": "detect_secrets.filters.heuristic.is_sequential_string"
+    },
+    {
+      "path": "detect_secrets.filters.heuristic.is_swagger_file"
+    },
+    {
+      "path": "detect_secrets.filters.heuristic.is_templated_secret"
+    },
+    {
+      "path": "detect_secrets.filters.regex.should_exclude_file",
+      "pattern": [
+        "(^|/)pnpm-lock\\.yaml$"
+      ]
+    },
+    {
+      "path": "detect_secrets.filters.regex.should_exclude_line",
+      "pattern": [
+        "key_content\\.include\\?\\(\"BEGIN PRIVATE KEY\"\\)",
+        "case \\.apiKeyEnv: \"API key \\(env var\\)\"",
+        "case apikey = \"apiKey\"",
+        "\"gateway\\.remote\\.password\"",
+        "\"gateway\\.auth\\.password\"",
+        "\"talk\\.apiKey\"",
+        "=== \"string\"",
+        "typeof remote\\?\\.password === \"string\""
+      ]
+    }
+  ],
+  "results": {
+    ".env.example": [
+      {
+        "type": "Twilio API Key",
+        "filename": ".env.example",
+        "hashed_secret": "3c7206eff845bc69cf12d904d0f95f9aec15535e",
+        "is_verified": false,
+        "line_number": 2
+      }
+    ],
+    "appcast.xml": [
+      {
+        "type": "Base64 High Entropy String",
+        "filename": "appcast.xml",
+        "hashed_secret": "1b1c2b73eca84e441a823c37a06c71c9fadcfe24",
+        "is_verified": false,
+        "line_number": 19
+      },
+      {
+        "type": "Base64 High Entropy String",
+        "filename": "appcast.xml",
+        "hashed_secret": "5c47736fee5151b26b3bb61bb38955da0e8937c6",
+        "is_verified": false,
+        "line_number": 35
+      },
+      {
+        "type": "Base64 High Entropy String",
+        "filename": "appcast.xml",
+        "hashed_secret": "bbbca47179268f154c63affa0ca441c6e49e650f",
+        "is_verified": false,
+        "line_number": 52
+      }
+    ],
+    "apps/macos/Tests/ClawdbotIPCTests/AnthropicAuthResolverTests.swift": [
+      {
+        "type": "Secret Keyword",
+        "filename": "apps/macos/Tests/ClawdbotIPCTests/AnthropicAuthResolverTests.swift",
+        "hashed_secret": "e761624445731fcb8b15da94343c6b92e507d190",
+        "is_verified": false,
+        "line_number": 26
+      },
+      {
+        "type": "Secret Keyword",
+        "filename": "apps/macos/Tests/ClawdbotIPCTests/AnthropicAuthResolverTests.swift",
+        "hashed_secret": "a23c8630c8a5fbaa21f095e0269c135c20d21689",
+        "is_verified": false,
+        "line_number": 42
+      }
+    ],
+    "apps/macos/Tests/ClawdbotIPCTests/ConnectionsSettingsSmokeTests.swift": [
+      {
+        "type": "Secret Keyword",
+        "filename": "apps/macos/Tests/ClawdbotIPCTests/ConnectionsSettingsSmokeTests.swift",
+        "hashed_secret": "e5e9fa1ba31ecd1ae84f75caaa474f3a663f05f4",
+        "is_verified": false,
+        "line_number": 83
+      }
+    ],
+    "apps/macos/Tests/ClawdbotIPCTests/TailscaleIntegrationSectionTests.swift": [
+      {
+        "type": "Secret Keyword",
+        "filename": "apps/macos/Tests/ClawdbotIPCTests/TailscaleIntegrationSectionTests.swift",
+        "hashed_secret": "e5e9fa1ba31ecd1ae84f75caaa474f3a663f05f4",
+        "is_verified": false,
+        "line_number": 27
+      }
+    ],
+    "docs/configuration.md": [
+      {
+        "type": "Secret Keyword",
+        "filename": "docs/configuration.md",
+        "hashed_secret": "e5e9fa1ba31ecd1ae84f75caaa474f3a663f05f4",
+        "is_verified": false,
+        "line_number": 268
+      },
+      {
+        "type": "Secret Keyword",
+        "filename": "docs/configuration.md",
+        "hashed_secret": "1188d5a8ed7edcff5144a9472af960243eacf12e",
+        "is_verified": false,
+        "line_number": 465
+      },
+      {
+        "type": "Secret Keyword",
+        "filename": "docs/configuration.md",
+        "hashed_secret": "22af290a1a3d5e941193a41a3d3a9e4ca8da5e27",
+        "is_verified": false,
+        "line_number": 718
+      },
+      {
+        "type": "Secret Keyword",
+        "filename": "docs/configuration.md",
+        "hashed_secret": "16c249e04e2be318050cb883c40137361c0c7209",
+        "is_verified": false,
+        "line_number": 760
+      },
+      {
+        "type": "Secret Keyword",
+        "filename": "docs/configuration.md",
+        "hashed_secret": "c1e6ee547fd492df1441ac492e8bb294974712bd",
+        "is_verified": false,
+        "line_number": 859
+      },
+      {
+        "type": "Secret Keyword",
+        "filename": "docs/configuration.md",
+        "hashed_secret": "45d676e7c6ab44cf4b8fa366ef2d8fccd3e6d6e6",
+        "is_verified": false,
+        "line_number": 982
+      }
+    ],
+    "docs/faq.md": [
+      {
+        "type": "Secret Keyword",
+        "filename": "docs/faq.md",
+        "hashed_secret": "a219d7693c25cd2d93313512e200ff3eb374d281",
+        "is_verified": false,
+        "line_number": 593
+      },
+      {
+        "type": "Secret Keyword",
+        "filename": "docs/faq.md",
+        "hashed_secret": "ec3810e10fb78db55ce38b9c18d1c3eb1db739e0",
+        "is_verified": false,
+        "line_number": 650
+      }
+    ],
+    "docs/skills-config.md": [
+      {
+        "type": "Secret Keyword",
+        "filename": "docs/skills-config.md",
+        "hashed_secret": "c1e6ee547fd492df1441ac492e8bb294974712bd",
+        "is_verified": false,
+        "line_number": 28
+      }
+    ],
+    "docs/skills.md": [
+      {
+        "type": "Secret Keyword",
+        "filename": "docs/skills.md",
+        "hashed_secret": "c1e6ee547fd492df1441ac492e8bb294974712bd",
+        "is_verified": false,
+        "line_number": 97
+      }
+    ],
+    "docs/tailscale.md": [
+      {
+        "type": "Secret Keyword",
+        "filename": "docs/tailscale.md",
+        "hashed_secret": "9cb0dc5383312aa15b9dc6745645bde18ff5ade9",
+        "is_verified": false,
+        "line_number": 52
+      }
+    ],
+    "docs/talk.md": [
+      {
+        "type": "Secret Keyword",
+        "filename": "docs/talk.md",
+        "hashed_secret": "1188d5a8ed7edcff5144a9472af960243eacf12e",
+        "is_verified": false,
+        "line_number": 50
+      }
+    ],
+    "docs/telegram.md": [
+      {
+        "type": "Secret Keyword",
+        "filename": "docs/telegram.md",
+        "hashed_secret": "e9fe51f94eadabf54dbf2fbbd57188b9abee436e",
+        "is_verified": false,
+        "line_number": 57
+      }
+    ],
+    "skills/local-places/SERVER_README.md": [
+      {
+        "type": "Secret Keyword",
+        "filename": "skills/local-places/SERVER_README.md",
+        "hashed_secret": "6d9c68c603e465077bdd49c62347fe54717f83a3",
+        "is_verified": false,
+        "line_number": 28
+      }
+    ],
+    "skills/openai-whisper-api/SKILL.md": [
+      {
+        "type": "Secret Keyword",
+        "filename": "skills/openai-whisper-api/SKILL.md",
+        "hashed_secret": "1077361f94d70e1ddcc7c6dc581a489532a81d03",
+        "is_verified": false,
+        "line_number": 39
+      }
+    ],
+    "skills/trello/SKILL.md": [
+      {
+        "type": "Secret Keyword",
+        "filename": "skills/trello/SKILL.md",
+        "hashed_secret": "11fa7c37d697f30e6aee828b4426a10f83ab2380",
+        "is_verified": false,
+        "line_number": 18
+      }
+    ],
+    "src/agents/models-config.test.ts": [
+      {
+        "type": "Secret Keyword",
+        "filename": "src/agents/models-config.test.ts",
+        "hashed_secret": "7cf31e8b6cda49f70c31f1f25af05d46f924142d",
+        "is_verified": false,
+        "line_number": 25
+      },
+      {
+        "type": "Secret Keyword",
+        "filename": "src/agents/models-config.test.ts",
+        "hashed_secret": "3a81eb091f80c845232225be5663d270e90dacb7",
+        "is_verified": false,
+        "line_number": 90
+      }
+    ],
+    "src/agents/skills.test.ts": [
+      {
+        "type": "Secret Keyword",
+        "filename": "src/agents/skills.test.ts",
+        "hashed_secret": "3acfb2c2b433c0ea7ff107e33df91b18e52f960f",
+        "is_verified": false,
+        "line_number": 158
+      },
+      {
+        "type": "Secret Keyword",
+        "filename": "src/agents/skills.test.ts",
+        "hashed_secret": "7a85f4764bbd6daf1c3545efbbf0f279a6dc0beb",
+        "is_verified": false,
+        "line_number": 265
+      },
+      {
+        "type": "Secret Keyword",
+        "filename": "src/agents/skills.test.ts",
+        "hashed_secret": "5df3a673d724e8a1eb673a8baf623e183940804d",
+        "is_verified": false,
+        "line_number": 462
+      },
+      {
+        "type": "Secret Keyword",
+        "filename": "src/agents/skills.test.ts",
+        "hashed_secret": "8921daaa546693e52bc1f9c40bdcf15e816e0448",
+        "is_verified": false,
+        "line_number": 490
+      }
+    ],
+    "src/browser/target-id.test.ts": [
+      {
+        "type": "Hex High Entropy String",
+        "filename": "src/browser/target-id.test.ts",
+        "hashed_secret": "4e126c049580d66ca1549fa534d95a7263f27f46",
+        "is_verified": false,
+        "line_number": 16
+      }
+    ],
+    "src/commands/antigravity-oauth.ts": [
+      {
+        "type": "Base64 High Entropy String",
+        "filename": "src/commands/antigravity-oauth.ts",
+        "hashed_secret": "709d0f232b6ac4f8d24dec3e4fabfdb14257174f",
+        "is_verified": false,
+        "line_number": 17
+      },
+      {
+        "type": "Base64 High Entropy String",
+        "filename": "src/commands/antigravity-oauth.ts",
+        "hashed_secret": "3848603b8e866f62d07c206ff622279b9dcb0238",
+        "is_verified": false,
+        "line_number": 20
+      }
+    ],
+    "src/commands/onboard-auth.ts": [
+      {
+        "type": "Secret Keyword",
+        "filename": "src/commands/onboard-auth.ts",
+        "hashed_secret": "16c249e04e2be318050cb883c40137361c0c7209",
+        "is_verified": false,
+        "line_number": 50
+      }
+    ],
+    "src/config/config.test.ts": [
+      {
+        "type": "Secret Keyword",
+        "filename": "src/config/config.test.ts",
+        "hashed_secret": "bea2f7b64fab8d1d414d0449530b1e088d36d5b1",
+        "is_verified": false,
+        "line_number": 520
+      }
+    ],
+    "src/gateway/server.auth.test.ts": [
+      {
+        "type": "Secret Keyword",
+        "filename": "src/gateway/server.auth.test.ts",
+        "hashed_secret": "e5e9fa1ba31ecd1ae84f75caaa474f3a663f05f4",
+        "is_verified": false,
+        "line_number": 89
+      },
+      {
+        "type": "Secret Keyword",
+        "filename": "src/gateway/server.auth.test.ts",
+        "hashed_secret": "a4b48a81cdab1e1a5dd37907d6c85ca1c61ddc7c",
+        "is_verified": false,
+        "line_number": 109
+      }
+    ],
+    "src/infra/env.test.ts": [
+      {
+        "type": "Secret Keyword",
+        "filename": "src/infra/env.test.ts",
+        "hashed_secret": "df98a117ddabf85991b9fe0e268214dc0e1254dc",
+        "is_verified": false,
+        "line_number": 10
+      },
+      {
+        "type": "Secret Keyword",
+        "filename": "src/infra/env.test.ts",
+        "hashed_secret": "6d811dc1f59a55ca1a3d38b5042a062b9f79e8ec",
+        "is_verified": false,
+        "line_number": 25
+      }
+    ],
+    "src/infra/shell-env.test.ts": [
+      {
+        "type": "Secret Keyword",
+        "filename": "src/infra/shell-env.test.ts",
+        "hashed_secret": "65c10dc3549fe07424148a8a4790a3341ecbc253",
+        "is_verified": false,
+        "line_number": 35
+      },
+      {
+        "type": "Base64 High Entropy String",
+        "filename": "src/infra/shell-env.test.ts",
+        "hashed_secret": "64db6bf7f0e5a0491df4419f0eb1bbcc402989e8",
+        "is_verified": false,
+        "line_number": 56
+      },
+      {
+        "type": "Secret Keyword",
+        "filename": "src/infra/shell-env.test.ts",
+        "hashed_secret": "e013ffda590d2178607c16d11b1ea42f75ceb0e7",
+        "is_verified": false,
+        "line_number": 73
+      },
+      {
+        "type": "Base64 High Entropy String",
+        "filename": "src/infra/shell-env.test.ts",
+        "hashed_secret": "be6ee9a6bf9f2dad84a5a67d6c0576a5bacc391e",
+        "is_verified": false,
+        "line_number": 75
+      }
+    ],
+    "src/web/qr-image.test.ts": [
+      {
+        "type": "Hex High Entropy String",
+        "filename": "src/web/qr-image.test.ts",
+        "hashed_secret": "564666dc1ca6e7318b2d5feeb1ce7b5bf717411e",
+        "is_verified": false,
+        "line_number": 12
+      }
+    ],
+    "vendor/a2ui/README.md": [
+      {
+        "type": "Secret Keyword",
+        "filename": "vendor/a2ui/README.md",
+        "hashed_secret": "2619a5397a5d054dab3fe24e6a8da1fbd76ec3a6",
+        "is_verified": false,
+        "line_number": 123
+      }
+    ]
+  },
+  "generated_at": "2026-01-05T13:01:00Z"
+}
diff --git a/SECURITY.md b/SECURITY.md
new file mode 100644
index 000000000..d2af462ba
--- /dev/null
+++ b/SECURITY.md
@@ -0,0 +1,15 @@
+# Security Policy
+
+If you believe you’ve found a security issue in Clawdbot, please report it privately.
+
+## Reporting
+
+- Email: `steipete@gmail.com`
+- What to include: reproduction steps, impact assessment, and (if possible) a minimal PoC.
+
+## Operational Guidance
+
+For threat model + hardening guidance (including `clawdbot security audit --deep` and `--fix`), see:
+
+- `https://docs.clawd.bot/gateway/security`
+
diff --git a/assets/chrome-extension/README.md b/assets/chrome-extension/README.md
new file mode 100644
index 000000000..670089321
--- /dev/null
+++ b/assets/chrome-extension/README.md
@@ -0,0 +1,22 @@
+# Clawdbot Chrome Extension (Browser Relay)
+
+Purpose: attach Clawdbot to an existing Chrome tab so the Gateway can automate it (via the local CDP relay server).
+
+## Dev / load unpacked
+
+1. Build/run Clawdbot Gateway with browser control enabled.
+2. Ensure the relay server is reachable at `http://127.0.0.1:18792/` (default).
+3. Install the extension to a stable path:
+
+   ```bash
+   clawdbot browser extension install
+   clawdbot browser extension path
+   ```
+
+4. Chrome → `chrome://extensions` → enable “Developer mode”.
+5. “Load unpacked” → select the path printed above.
+6. Pin the extension. Click the icon on a tab to attach/detach.
+
+## Options
+
+- `Relay port`: defaults to `18792`.
diff --git a/assets/chrome-extension/background.js b/assets/chrome-extension/background.js
new file mode 100644
index 000000000..268fade73
--- /dev/null
+++ b/assets/chrome-extension/background.js
@@ -0,0 +1,438 @@
+const DEFAULT_PORT = 18792
+
+const BADGE = {
+  on: { text: 'ON', color: '#FF5A36' },
+  off: { text: '', color: '#000000' },
+  connecting: { text: '…', color: '#F59E0B' },
+  error: { text: '!', color: '#B91C1C' },
+}
+
+/** @type {WebSocket|null} */
+let relayWs = null
+/** @type {Promise<void>|null} */
+let relayConnectPromise = null
+
+let debuggerListenersInstalled = false
+
+let nextSession = 1
+
+/** @type {Map<number, {state:'connecting'|'connected', sessionId?:string, targetId?:string, attachOrder?:number}>} */
+const tabs = new Map()
+/** @type {Map<string, number>} */
+const tabBySession = new Map()
+/** @type {Map<string, number>} */
+const childSessionToTab = new Map()
+
+/** @type {Map<number, {resolve:(v:any)=>void, reject:(e:Error)=>void}>} */
+const pending = new Map()
+
+function nowStack() {
+  try {
+    return new Error().stack || ''
+  } catch {
+    return ''
+  }
+}
+
+async function getRelayPort() {
+  const stored = await chrome.storage.local.get(['relayPort'])
+  const raw = stored.relayPort
+  const n = Number.parseInt(String(raw || ''), 10)
+  if (!Number.isFinite(n) || n <= 0 || n > 65535) return DEFAULT_PORT
+  return n
+}
+
+function setBadge(tabId, kind) {
+  const cfg = BADGE[kind]
+  void chrome.action.setBadgeText({ tabId, text: cfg.text })
+  void chrome.action.setBadgeBackgroundColor({ tabId, color: cfg.color })
+  void chrome.action.setBadgeTextColor({ tabId, color: '#FFFFFF' }).catch(() => {})
+}
+
+async function ensureRelayConnection() {
+  if (relayWs && relayWs.readyState === WebSocket.OPEN) return
+  if (relayConnectPromise) return await relayConnectPromise
+
+  relayConnectPromise = (async () => {
+    const port = await getRelayPort()
+    const httpBase = `http://127.0.0.1:${port}`
+    const wsUrl = `ws://127.0.0.1:${port}/extension`
+
+    // Fast preflight: is the relay server up?
+    try {
+      await fetch(`${httpBase}/`, { method: 'HEAD', signal: AbortSignal.timeout(2000) })
+    } catch (err) {
+      throw new Error(`Relay server not reachable at ${httpBase} (${String(err)})`)
+    }
+
+    const ws = new WebSocket(wsUrl)
+    relayWs = ws
+
+    await new Promise((resolve, reject) => {
+      const t = setTimeout(() => reject(new Error('WebSocket connect timeout')), 5000)
+      ws.onopen = () => {
+        clearTimeout(t)
+        resolve()
+      }
+      ws.onerror = () => {
+        clearTimeout(t)
+        reject(new Error('WebSocket connect failed'))
+      }
+      ws.onclose = (ev) => {
+        clearTimeout(t)
+        reject(new Error(`WebSocket closed (${ev.code} ${ev.reason || 'no reason'})`))
+      }
+    })
+
+    ws.onmessage = (event) => void onRelayMessage(String(event.data || ''))
+    ws.onclose = () => onRelayClosed('closed')
+    ws.onerror = () => onRelayClosed('error')
+
+    if (!debuggerListenersInstalled) {
+      debuggerListenersInstalled = true
+      chrome.debugger.onEvent.addListener(onDebuggerEvent)
+      chrome.debugger.onDetach.addListener(onDebuggerDetach)
+    }
+  })()
+
+  try {
+    await relayConnectPromise
+  } finally {
+    relayConnectPromise = null
+  }
+}
+
+function onRelayClosed(reason) {
+  relayWs = null
+  for (const [id, p] of pending.entries()) {
+    pending.delete(id)
+    p.reject(new Error(`Relay disconnected (${reason})`))
+  }
+
+  for (const tabId of tabs.keys()) {
+    void chrome.debugger.detach({ tabId }).catch(() => {})
+    setBadge(tabId, 'connecting')
+    void chrome.action.setTitle({
+      tabId,
+      title: 'Clawdbot Browser Relay: disconnected (click to re-attach)',
+    })
+  }
+  tabs.clear()
+  tabBySession.clear()
+  childSessionToTab.clear()
+}
+
+function sendToRelay(payload) {
+  const ws = relayWs
+  if (!ws || ws.readyState !== WebSocket.OPEN) {
+    throw new Error('Relay not connected')
+  }
+  ws.send(JSON.stringify(payload))
+}
+
+async function maybeOpenHelpOnce() {
+  try {
+    const stored = await chrome.storage.local.get(['helpOnErrorShown'])
+    if (stored.helpOnErrorShown === true) return
+    await chrome.storage.local.set({ helpOnErrorShown: true })
+    await chrome.runtime.openOptionsPage()
+  } catch {
+    // ignore
+  }
+}
+
+function requestFromRelay(command) {
+  const id = command.id
+  return new Promise((resolve, reject) => {
+    pending.set(id, { resolve, reject })
+    try {
+      sendToRelay(command)
+    } catch (err) {
+      pending.delete(id)
+      reject(err instanceof Error ? err : new Error(String(err)))
+    }
+  })
+}
+
+async function onRelayMessage(text) {
+  /** @type {any} */
+  let msg
+  try {
+    msg = JSON.parse(text)
+  } catch {
+    return
+  }
+
+  if (msg && msg.method === 'ping') {
+    try {
+      sendToRelay({ method: 'pong' })
+    } catch {
+      // ignore
+    }
+    return
+  }
+
+  if (msg && typeof msg.id === 'number' && (msg.result !== undefined || msg.error !== undefined)) {
+    const p = pending.get(msg.id)
+    if (!p) return
+    pending.delete(msg.id)
+    if (msg.error) p.reject(new Error(String(msg.error)))
+    else p.resolve(msg.result)
+    return
+  }
+
+  if (msg && typeof msg.id === 'number' && msg.method === 'forwardCDPCommand') {
+    try {
+      const result = await handleForwardCdpCommand(msg)
+      sendToRelay({ id: msg.id, result })
+    } catch (err) {
+      sendToRelay({ id: msg.id, error: err instanceof Error ? err.message : String(err) })
+    }
+  }
+}
+
+function getTabBySessionId(sessionId) {
+  const direct = tabBySession.get(sessionId)
+  if (direct) return { tabId: direct, kind: 'main' }
+  const child = childSessionToTab.get(sessionId)
+  if (child) return { tabId: child, kind: 'child' }
+  return null
+}
+
+function getTabByTargetId(targetId) {
+  for (const [tabId, tab] of tabs.entries()) {
+    if (tab.targetId === targetId) return tabId
+  }
+  return null
+}
+
+async function attachTab(tabId, opts = {}) {
+  const debuggee = { tabId }
+  await chrome.debugger.attach(debuggee, '1.3')
+  await chrome.debugger.sendCommand(debuggee, 'Page.enable').catch(() => {})
+
+  const info = /** @type {any} */ (await chrome.debugger.sendCommand(debuggee, 'Target.getTargetInfo'))
+  const targetInfo = info?.targetInfo
+  const targetId = String(targetInfo?.targetId || '').trim()
+  if (!targetId) {
+    throw new Error('Target.getTargetInfo returned no targetId')
+  }
+
+  const sessionId = `cb-tab-${nextSession++}`
+  const attachOrder = nextSession
+
+  tabs.set(tabId, { state: 'connected', sessionId, targetId, attachOrder })
+  tabBySession.set(sessionId, tabId)
+  void chrome.action.setTitle({
+    tabId,
+    title: 'Clawdbot Browser Relay: attached (click to detach)',
+  })
+
+  if (!opts.skipAttachedEvent) {
+    sendToRelay({
+      method: 'forwardCDPEvent',
+      params: {
+        method: 'Target.attachedToTarget',
+        params: {
+          sessionId,
+          targetInfo: { ...targetInfo, attached: true },
+          waitingForDebugger: false,
+        },
+      },
+    })
+  }
+
+  setBadge(tabId, 'on')
+  return { sessionId, targetId }
+}
+
+async function detachTab(tabId, reason) {
+  const tab = tabs.get(tabId)
+  if (tab?.sessionId && tab?.targetId) {
+    try {
+      sendToRelay({
+        method: 'forwardCDPEvent',
+        params: {
+          method: 'Target.detachedFromTarget',
+          params: { sessionId: tab.sessionId, targetId: tab.targetId, reason },
+        },
+      })
+    } catch {
+      // ignore
+    }
+  }
+
+  if (tab?.sessionId) tabBySession.delete(tab.sessionId)
+  tabs.delete(tabId)
+
+  for (const [childSessionId, parentTabId] of childSessionToTab.entries()) {
+    if (parentTabId === tabId) childSessionToTab.delete(childSessionId)
+  }
+
+  try {
+    await chrome.debugger.detach({ tabId })
+  } catch {
+    // ignore
+  }
+
+  setBadge(tabId, 'off')
+  void chrome.action.setTitle({
+    tabId,
+    title: 'Clawdbot Browser Relay (click to attach/detach)',
+  })
+}
+
+async function connectOrToggleForActiveTab() {
+  const [active] = await chrome.tabs.query({ active: true, currentWindow: true })
+  const tabId = active?.id
+  if (!tabId) return
+
+  const existing = tabs.get(tabId)
+  if (existing?.state === 'connected') {
+    await detachTab(tabId, 'toggle')
+    return
+  }
+
+  tabs.set(tabId, { state: 'connecting' })
+  setBadge(tabId, 'connecting')
+  void chrome.action.setTitle({
+    tabId,
+    title: 'Clawdbot Browser Relay: connecting to local relay…',
+  })
+
+  try {
+    await ensureRelayConnection()
+    await attachTab(tabId)
+  } catch (err) {
+    tabs.delete(tabId)
+    setBadge(tabId, 'error')
+    void chrome.action.setTitle({
+      tabId,
+      title: 'Clawdbot Browser Relay: relay not running (open options for setup)',
+    })
+    void maybeOpenHelpOnce()
+    // Extra breadcrumbs in chrome://extensions service worker logs.
+    const message = err instanceof Error ? err.message : String(err)
+    console.warn('attach failed', message, nowStack())
+  }
+}
+
+async function handleForwardCdpCommand(msg) {
+  const method = String(msg?.params?.method || '').trim()
+  const params = msg?.params?.params || undefined
+  const sessionId = typeof msg?.params?.sessionId === 'string' ? msg.params.sessionId : undefined
+
+  // Map command to tab
+  const bySession = sessionId ? getTabBySessionId(sessionId) : null
+  const targetId = typeof params?.targetId === 'string' ? params.targetId : undefined
+  const tabId =
+    bySession?.tabId ||
+    (targetId ? getTabByTargetId(targetId) : null) ||
+    (() => {
+      // No sessionId: pick the first connected tab (stable-ish).
+      for (const [id, tab] of tabs.entries()) {
+        if (tab.state === 'connected') return id
+      }
+      return null
+    })()
+
+  if (!tabId) throw new Error(`No attached tab for method ${method}`)
+
+  /** @type {chrome.debugger.DebuggerSession} */
+  const debuggee = { tabId }
+
+  if (method === 'Runtime.enable') {
+    try {
+      await chrome.debugger.sendCommand(debuggee, 'Runtime.disable')
+      await new Promise((r) => setTimeout(r, 50))
+    } catch {
+      // ignore
+    }
+    return await chrome.debugger.sendCommand(debuggee, 'Runtime.enable', params)
+  }
+
+  if (method === 'Target.createTarget') {
+    const url = typeof params?.url === 'string' ? params.url : 'about:blank'
+    const tab = await chrome.tabs.create({ url, active: false })
+    if (!tab.id) throw new Error('Failed to create tab')
+    await new Promise((r) => setTimeout(r, 100))
+    const attached = await attachTab(tab.id)
+    return { targetId: attached.targetId }
+  }
+
+  if (method === 'Target.closeTarget') {
+    const target = typeof params?.targetId === 'string' ? params.targetId : ''
+    const toClose = target ? getTabByTargetId(target) : tabId
+    if (!toClose) return { success: false }
+    try {
+      await chrome.tabs.remove(toClose)
+    } catch {
+      return { success: false }
+    }
+    return { success: true }
+  }
+
+  if (method === 'Target.activateTarget') {
+    const target = typeof params?.targetId === 'string' ? params.targetId : ''
+    const toActivate = target ? getTabByTargetId(target) : tabId
+    if (!toActivate) return {}
+    const tab = await chrome.tabs.get(toActivate).catch(() => null)
+    if (!tab) return {}
+    if (tab.windowId) {
+      await chrome.windows.update(tab.windowId, { focused: true }).catch(() => {})
+    }
+    await chrome.tabs.update(toActivate, { active: true }).catch(() => {})
+    return {}
+  }
+
+  const tabState = tabs.get(tabId)
+  const mainSessionId = tabState?.sessionId
+  const debuggerSession =
+    sessionId && mainSessionId && sessionId !== mainSessionId
+      ? { ...debuggee, sessionId }
+      : debuggee
+
+  return await chrome.debugger.sendCommand(debuggerSession, method, params)
+}
+
+function onDebuggerEvent(source, method, params) {
+  const tabId = source.tabId
+  if (!tabId) return
+  const tab = tabs.get(tabId)
+  if (!tab?.sessionId) return
+
+  if (method === 'Target.attachedToTarget' && params?.sessionId) {
+    childSessionToTab.set(String(params.sessionId), tabId)
+  }
+
+  if (method === 'Target.detachedFromTarget' && params?.sessionId) {
+    childSessionToTab.delete(String(params.sessionId))
+  }
+
+  try {
+    sendToRelay({
+      method: 'forwardCDPEvent',
+      params: {
+        sessionId: source.sessionId || tab.sessionId,
+        method,
+        params,
+      },
+    })
+  } catch {
+    // ignore
+  }
+}
+
+function onDebuggerDetach(source, reason) {
+  const tabId = source.tabId
+  if (!tabId) return
+  if (!tabs.has(tabId)) return
+  void detachTab(tabId, reason)
+}
+
+chrome.action.onClicked.addListener(() => void connectOrToggleForActiveTab())
+
+chrome.runtime.onInstalled.addListener(() => {
+  // Useful: first-time instructions.
+  void chrome.runtime.openOptionsPage()
+})
diff --git a/assets/chrome-extension/icons/icon128.png b/assets/chrome-extension/icons/icon128.png
new file mode 100644
index 000000000..533cc812d
Binary files /dev/null and b/assets/chrome-extension/icons/icon128.png differ
diff --git a/assets/chrome-extension/icons/icon16.png b/assets/chrome-extension/icons/icon16.png
new file mode 100644
index 000000000..1be23ae89
Binary files /dev/null and b/assets/chrome-extension/icons/icon16.png differ
diff --git a/assets/chrome-extension/icons/icon32.png b/assets/chrome-extension/icons/icon32.png
new file mode 100644
index 000000000..f4c1be8a6
Binary files /dev/null and b/assets/chrome-extension/icons/icon32.png differ
diff --git a/assets/chrome-extension/icons/icon48.png b/assets/chrome-extension/icons/icon48.png
new file mode 100644
index 000000000..d2a278af5
Binary files /dev/null and b/assets/chrome-extension/icons/icon48.png differ
diff --git a/assets/chrome-extension/manifest.json b/assets/chrome-extension/manifest.json
new file mode 100644
index 000000000..1e8e3db0c
--- /dev/null
+++ b/assets/chrome-extension/manifest.json
@@ -0,0 +1,25 @@
+{
+  "manifest_version": 3,
+  "name": "Clawdbot Browser Relay",
+  "version": "0.1.0",
+  "description": "Attach Clawdbot to your existing Chrome tab via a local CDP relay server.",
+  "icons": {
+    "16": "icons/icon16.png",
+    "32": "icons/icon32.png",
+    "48": "icons/icon48.png",
+    "128": "icons/icon128.png"
+  },
+  "permissions": ["debugger", "tabs", "activeTab", "storage"],
+  "host_permissions": ["http://127.0.0.1/*", "http://localhost/*"],
+  "background": { "service_worker": "background.js", "type": "module" },
+  "action": {
+    "default_title": "Clawdbot Browser Relay (click to attach/detach)",
+    "default_icon": {
+      "16": "icons/icon16.png",
+      "32": "icons/icon32.png",
+      "48": "icons/icon48.png",
+      "128": "icons/icon128.png"
+    }
+  },
+  "options_ui": { "page": "options.html", "open_in_tab": true }
+}
diff --git a/assets/chrome-extension/options.html b/assets/chrome-extension/options.html
new file mode 100644
index 000000000..4e701826d
--- /dev/null
+++ b/assets/chrome-extension/options.html
@@ -0,0 +1,197 @@
+<!doctype html>
+<html lang="en">
+  <head>
+    <meta charset="utf-8" />
+    <meta name="viewport" content="width=device-width, initial-scale=1" />
+    <title>Clawdbot Browser Relay</title>
+    <style>
+      :root {
+        color-scheme: light dark;
+        --accent: #ff5a36;
+        --panel: color-mix(in oklab, canvas 92%, canvasText 8%);
+        --border: color-mix(in oklab, canvasText 18%, transparent);
+        --muted: color-mix(in oklab, canvasText 70%, transparent);
+        --shadow: 0 10px 30px color-mix(in oklab, canvasText 18%, transparent);
+        font-family: ui-rounded, system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Rounded",
+          "SF Pro Display", "Segoe UI", sans-serif;
+        line-height: 1.4;
+      }
+      body {
+        margin: 0;
+        min-height: 100vh;
+        background:
+          radial-gradient(1000px 500px at 10% 0%, color-mix(in oklab, var(--accent) 30%, transparent), transparent 70%),
+          radial-gradient(900px 450px at 90% 0%, color-mix(in oklab, var(--accent) 18%, transparent), transparent 75%),
+          canvas;
+        color: canvasText;
+      }
+      .wrap {
+        max-width: 820px;
+        margin: 36px auto;
+        padding: 0 24px 48px 24px;
+      }
+      header {
+        display: flex;
+        align-items: center;
+        gap: 12px;
+        margin-bottom: 18px;
+      }
+      .logo {
+        width: 44px;
+        height: 44px;
+        border-radius: 14px;
+        background: color-mix(in oklab, var(--accent) 18%, transparent);
+        border: 1px solid color-mix(in oklab, var(--accent) 35%, transparent);
+        box-shadow: var(--shadow);
+        display: grid;
+        place-items: center;
+      }
+      .logo img {
+        width: 28px;
+        height: 28px;
+        image-rendering: pixelated;
+      }
+      h1 {
+        font-size: 20px;
+        margin: 0;
+        letter-spacing: -0.01em;
+      }
+      .subtitle {
+        margin: 2px 0 0 0;
+        color: var(--muted);
+        font-size: 13px;
+      }
+      .grid {
+        display: grid;
+        grid-template-columns: 1fr;
+        gap: 14px;
+      }
+      .card {
+        background: var(--panel);
+        border: 1px solid var(--border);
+        border-radius: 16px;
+        padding: 16px;
+        box-shadow: var(--shadow);
+      }
+      .card h2 {
+        margin: 0 0 10px 0;
+        font-size: 14px;
+        letter-spacing: 0.01em;
+      }
+      .card p {
+        margin: 8px 0 0 0;
+        color: var(--muted);
+        font-size: 13px;
+      }
+      .row {
+        display: flex;
+        align-items: center;
+        gap: 8px;
+        flex-wrap: wrap;
+      }
+      label {
+        display: block;
+        font-size: 12px;
+        color: var(--muted);
+        margin-bottom: 6px;
+      }
+      input {
+        width: 160px;
+        padding: 10px 12px;
+        border-radius: 12px;
+        border: 1px solid var(--border);
+        background: color-mix(in oklab, canvas 92%, canvasText 8%);
+        color: canvasText;
+        outline: none;
+      }
+      input:focus {
+        border-color: color-mix(in oklab, var(--accent) 70%, transparent);
+        box-shadow: 0 0 0 4px color-mix(in oklab, var(--accent) 20%, transparent);
+      }
+      button {
+        padding: 10px 14px;
+        border-radius: 12px;
+        border: 1px solid color-mix(in oklab, var(--accent) 55%, transparent);
+        background: linear-gradient(
+          180deg,
+          color-mix(in oklab, var(--accent) 80%, white 20%),
+          var(--accent)
+        );
+        color: white;
+        font-weight: 650;
+        letter-spacing: 0.01em;
+        cursor: pointer;
+      }
+      button:active {
+        transform: translateY(1px);
+      }
+      .hint {
+        margin-top: 10px;
+        font-size: 12px;
+        color: var(--muted);
+      }
+      code {
+        font-family: ui-monospace, Menlo, Monaco, Consolas, "SF Mono", monospace;
+        font-size: 12px;
+      }
+      a {
+        color: color-mix(in oklab, var(--accent) 85%, canvasText 15%);
+      }
+      .status {
+        margin-top: 10px;
+        font-size: 12px;
+        color: color-mix(in oklab, var(--accent) 70%, canvasText 30%);
+        min-height: 16px;
+      }
+      .status[data-kind='ok'] {
+        color: color-mix(in oklab, #16a34a 75%, canvasText 25%);
+      }
+      .status[data-kind='error'] {
+        color: color-mix(in oklab, #ef4444 75%, canvasText 25%);
+      }
+    </style>
+  </head>
+  <body>
+    <div class="wrap">
+      <header>
+        <div class="logo" aria-hidden="true">
+          <img src="icons/icon128.png" alt="" />
+        </div>
+        <div>
+          <h1>Clawdbot Browser Relay</h1>
+          <p class="subtitle">Click the toolbar button on a tab to attach / detach.</p>
+        </div>
+      </header>
+
+      <div class="grid">
+        <div class="card">
+          <h2>Getting started</h2>
+          <p>
+            If you see a red <code>!</code> badge on the extension icon, the relay server is not reachable.
+            Start Clawdbot’s browser relay on this machine (Gateway or <code>clawdbot browser serve</code>),
+            then click the toolbar button again.
+          </p>
+          <p>
+            Full guide (install, remote Gateway, security): <a href="https://docs.clawd.bot/tools/chrome-extension" target="_blank" rel="noreferrer">docs.clawd.bot/tools/chrome-extension</a>
+          </p>
+        </div>
+
+        <div class="card">
+          <h2>Relay port</h2>
+          <label for="port">Port</label>
+          <div class="row">
+            <input id="port" inputmode="numeric" pattern="[0-9]*" />
+            <button id="save" type="button">Save</button>
+          </div>
+          <div class="hint">
+            Default: <code>18792</code>. Extension connects to: <code id="relay-url">http://127.0.0.1:&lt;port&gt;/</code>.
+            Only change this if your Clawdbot profile uses a different <code>cdpUrl</code> port.
+          </div>
+          <div class="status" id="status"></div>
+        </div>
+      </div>
+
+      <script type="module" src="options.js"></script>
+    </div>
+  </body>
+</html>
diff --git a/assets/chrome-extension/options.js b/assets/chrome-extension/options.js
new file mode 100644
index 000000000..e0f3a9a50
--- /dev/null
+++ b/assets/chrome-extension/options.js
@@ -0,0 +1,59 @@
+const DEFAULT_PORT = 18792
+
+function clampPort(value) {
+  const n = Number.parseInt(String(value || ''), 10)
+  if (!Number.isFinite(n)) return DEFAULT_PORT
+  if (n <= 0 || n > 65535) return DEFAULT_PORT
+  return n
+}
+
+function updateRelayUrl(port) {
+  const el = document.getElementById('relay-url')
+  if (!el) return
+  el.textContent = `http://127.0.0.1:${port}/`
+}
+
+function setStatus(kind, message) {
+  const status = document.getElementById('status')
+  if (!status) return
+  status.dataset.kind = kind || ''
+  status.textContent = message || ''
+}
+
+async function checkRelayReachable(port) {
+  const url = `http://127.0.0.1:${port}/`
+  const ctrl = new AbortController()
+  const t = setTimeout(() => ctrl.abort(), 900)
+  try {
+    const res = await fetch(url, { method: 'HEAD', signal: ctrl.signal })
+    if (!res.ok) throw new Error(`HTTP ${res.status}`)
+    setStatus('ok', `Relay reachable at ${url}`)
+  } catch {
+    setStatus(
+      'error',
+      `Relay not reachable at ${url}. Start Clawdbot’s browser relay on this machine, then click the toolbar button again.`,
+    )
+  } finally {
+    clearTimeout(t)
+  }
+}
+
+async function load() {
+  const stored = await chrome.storage.local.get(['relayPort'])
+  const port = clampPort(stored.relayPort)
+  document.getElementById('port').value = String(port)
+  updateRelayUrl(port)
+  await checkRelayReachable(port)
+}
+
+async function save() {
+  const input = document.getElementById('port')
+  const port = clampPort(input.value)
+  await chrome.storage.local.set({ relayPort: port })
+  input.value = String(port)
+  updateRelayUrl(port)
+  await checkRelayReachable(port)
+}
+
+document.getElementById('save').addEventListener('click', () => void save())
+void load()
diff --git a/docs/channels/zalo.md b/docs/channels/zalo.md
new file mode 100644
index 000000000..80e89f6f6
--- /dev/null
+++ b/docs/channels/zalo.md
@@ -0,0 +1,165 @@
+---
+summary: "Zalo bot support status, capabilities, and configuration"
+read_when:
+  - Working on Zalo features or webhooks
+---
+# Zalo (Bot API)
+
+Status: experimental. Direct messages only; groups coming soon per Zalo docs.
+
+## Plugin required
+Zalo ships as a plugin and is not bundled with the core install.
+- Install via CLI: `clawdbot plugins install @clawdbot/zalo`
+- Or select **Zalo** during onboarding and confirm the install prompt
+- Details: [Plugins](/plugin)
+
+## Quick setup (beginner)
+1) Install the Zalo plugin:
+   - From a source checkout: `clawdbot plugins install ./extensions/zalo`
+   - From npm (if published): `clawdbot plugins install @clawdbot/zalo`
+   - Or pick **Zalo** in onboarding and confirm the install prompt
+2) Set the token:
+   - Env: `ZALO_BOT_TOKEN=...`
+   - Or config: `channels.zalo.botToken: "..."`.
+3) Restart the gateway (or finish onboarding).
+4) DM access is pairing by default; approve the pairing code on first contact.
+
+Minimal config:
+```json5
+{
+  channels: {
+    zalo: {
+      enabled: true,
+      botToken: "12345689:abc-xyz",
+      dmPolicy: "pairing"
+    }
+  }
+}
+```
+
+## What it is
+- A Zalo Bot API channel owned by the Gateway.
+- Deterministic routing: replies go back to Zalo; the model never chooses channels.
+- DMs share the agent's main session.
+- Groups are not yet supported (Zalo docs state "coming soon").
+
+## Setup (fast path)
+
+### 1) Create a bot token (Zalo Bot Platform)
+1) Go to **https://bot.zaloplatforms.com** and sign in.
+2) Create a new bot and configure its settings.
+3) Copy the bot token (format: `12345689:abc-xyz`).
+
+### 2) Configure the token (env or config)
+Example:
+
+```json5
+{
+  channels: {
+    zalo: {
+      enabled: true,
+      botToken: "12345689:abc-xyz",
+      dmPolicy: "pairing"
+    }
+  }
+}
+```
+
+Env option: `ZALO_BOT_TOKEN=...` (works for the default account only).
+
+Multi-account support: use `channels.zalo.accounts` with per-account tokens and optional `name`.
+
+3) Restart the gateway. Zalo starts when a token is resolved (env or config).
+4) DM access defaults to pairing. Approve the code when the bot is first contacted.
+
+## How it works (behavior)
+- Inbound messages are normalized into the shared channel envelope with media placeholders.
+- Replies always route back to the same Zalo chat.
+- Long-polling by default; webhook mode available with `channels.zalo.webhookUrl`.
+
+## Limits
+- Outbound text is chunked to 2000 characters (Zalo API limit).
+- Media downloads/uploads are capped by `channels.zalo.mediaMaxMb` (default 5).
+- Streaming is blocked by default due to the 2000 char limit making streaming less useful.
+
+## Access control (DMs)
+
+### DM access
+- Default: `channels.zalo.dmPolicy = "pairing"`. Unknown senders receive a pairing code; messages are ignored until approved (codes expire after 1 hour).
+- Approve via:
+  - `clawdbot pairing list zalo`
+  - `clawdbot pairing approve zalo <CODE>`
+- Pairing is the default token exchange. Details: [Pairing](/start/pairing)
+- `channels.zalo.allowFrom` accepts numeric user IDs.
+
+## Long-polling vs webhook
+- Default: long-polling (no public URL required).
+- Webhook mode: set `channels.zalo.webhookUrl` and `channels.zalo.webhookSecret`.
+  - The webhook secret must be 8-256 characters.
+  - Webhook URL must use HTTPS.
+  - Zalo sends events with `X-Bot-Api-Secret-Token` header for verification.
+  - Gateway HTTP handles webhook requests at `channels.zalo.webhookPath` (defaults to the webhook URL path).
+
+**Note:** getUpdates (polling) and webhook are mutually exclusive per Zalo API docs.
+
+## Supported message types
+- **Text messages**: Full support with 2000 character chunking.
+- **Image messages**: Download and process inbound images; send images via `sendPhoto`.
+- **Stickers**: Logged but not fully processed (no agent response).
+- **Unsupported types**: Logged (e.g., messages from protected users).
+
+## Capabilities
+| Feature | Status |
+|---------|--------|
+| Direct messages | ✅ Supported |
+| Groups | ❌ Coming soon (per Zalo docs) |
+| Media (images) | ✅ Supported |
+| Reactions | ❌ Not supported |
+| Threads | ❌ Not supported |
+| Polls | ❌ Not supported |
+| Native commands | ❌ Not supported |
+| Streaming | ⚠️ Blocked (2000 char limit) |
+
+## Delivery targets (CLI/cron)
+- Use a chat id as the target.
+- Example: `clawdbot message send --channel zalo --to 123456789 --message "hi"`.
+
+## Troubleshooting
+
+**Bot doesn't respond:**
+- Check that the token is valid: `clawdbot channels status --probe`
+- Verify the sender is approved (pairing or allowFrom)
+- Check gateway logs: `clawdbot logs --follow`
+
+**Webhook not receiving events:**
+- Ensure webhook URL uses HTTPS
+- Verify secret token is 8-256 characters
+- Confirm the gateway HTTP endpoint is reachable on the configured path
+- Check that getUpdates polling is not running (they're mutually exclusive)
+
+## Configuration reference (Zalo)
+Full configuration: [Configuration](/gateway/configuration)
+
+Provider options:
+- `channels.zalo.enabled`: enable/disable channel startup.
+- `channels.zalo.botToken`: bot token from Zalo Bot Platform.
+- `channels.zalo.tokenFile`: read token from file path.
+- `channels.zalo.dmPolicy`: `pairing | allowlist | open | disabled` (default: pairing).
+- `channels.zalo.allowFrom`: DM allowlist (user IDs). `open` requires `"*"`.
+- `channels.zalo.mediaMaxMb`: inbound/outbound media cap (MB, default 5).
+- `channels.zalo.webhookUrl`: enable webhook mode (HTTPS required).
+- `channels.zalo.webhookSecret`: webhook secret (8-256 chars).
+- `channels.zalo.webhookPath`: webhook path on the gateway HTTP server.
+- `channels.zalo.proxy`: proxy URL for API requests.
+
+Multi-account options:
+- `channels.zalo.accounts.<id>.botToken`: per-account token.
+- `channels.zalo.accounts.<id>.tokenFile`: per-account token file.
+- `channels.zalo.accounts.<id>.name`: display name.
+- `channels.zalo.accounts.<id>.enabled`: enable/disable account.
+- `channels.zalo.accounts.<id>.dmPolicy`: per-account DM policy.
+- `channels.zalo.accounts.<id>.allowFrom`: per-account allowlist.
+- `channels.zalo.accounts.<id>.webhookUrl`: per-account webhook URL.
+- `channels.zalo.accounts.<id>.webhookSecret`: per-account webhook secret.
+- `channels.zalo.accounts.<id>.webhookPath`: per-account webhook path.
+- `channels.zalo.accounts.<id>.proxy`: per-account proxy URL.
diff --git a/docs/cli/browser.md b/docs/cli/browser.md
new file mode 100644
index 000000000..9c25d563f
--- /dev/null
+++ b/docs/cli/browser.md
@@ -0,0 +1,106 @@
+---
+summary: "CLI reference for `clawdbot browser` (profiles, tabs, actions, extension relay, remote serve)"
+read_when:
+  - You use `clawdbot browser` and want examples for common tasks
+  - You want to control a remote browser via `browser.controlUrl`
+  - You want to use the Chrome extension relay (attach/detach via toolbar button)
+---
+
+# `clawdbot browser`
+
+Manage Clawdbot’s browser control server and run browser actions (tabs, snapshots, screenshots, navigation, clicks, typing).
+
+Related:
+- Browser tool + API: [Browser tool](/tools/browser)
+- Chrome extension relay: [Chrome extension](/tools/chrome-extension)
+
+## Common flags
+
+- `--url <controlUrl>`: override `browser.controlUrl` for this command invocation.
+- `--browser-profile <name>`: choose a browser profile (default comes from config).
+- `--json`: machine-readable output (where supported).
+
+## Quick start (local)
+
+```bash
+clawdbot browser status
+clawdbot browser start
+clawdbot browser tabs
+clawdbot browser open https://example.com
+clawdbot browser snapshot
+```
+
+## Profiles
+
+Profiles are named browser instances with their own data directory and CDP settings.
+
+```bash
+clawdbot browser profiles
+clawdbot browser create-profile --name work --color "#FF5A36"
+clawdbot browser delete-profile --name work
+```
+
+Use a specific profile:
+
+```bash
+clawdbot browser --browser-profile work tabs
+```
+
+## Tabs
+
+```bash
+clawdbot browser tabs
+clawdbot browser open https://docs.clawd.bot
+clawdbot browser focus <targetId>
+clawdbot browser close <targetId>
+```
+
+## Snapshot / screenshot / actions
+
+Snapshot:
+
+```bash
+clawdbot browser snapshot
+```
+
+Screenshot:
+
+```bash
+clawdbot browser screenshot
+```
+
+Navigate/click/type (ref-based UI automation):
+
+```bash
+clawdbot browser navigate https://example.com
+clawdbot browser click <ref>
+clawdbot browser type <ref> "hello"
+```
+
+## Chrome extension relay (attach via toolbar button)
+
+This mode lets the agent control an existing Chrome tab that you attach manually (it does not auto-attach).
+
+Install the unpacked extension to a stable path:
+
+```bash
+clawdbot browser extension install
+clawdbot browser extension path
+```
+
+Then Chrome → `chrome://extensions` → enable “Developer mode” → “Load unpacked” → select the printed folder.
+
+Full guide: [Chrome extension](/tools/chrome-extension)
+
+## Remote browser control (`clawdbot browser serve`)
+
+If the Gateway runs on a different machine than the browser, run a standalone browser control server on the machine that runs Chrome:
+
+```bash
+clawdbot browser serve --bind 127.0.0.1 --port 18791 --token <token>
+```
+
+Then point the Gateway at it using `browser.controlUrl` + `browser.controlToken` (or `CLAWDBOT_BROWSER_CONTROL_TOKEN`).
+
+Security + TLS best-practices: [Browser tool](/tools/browser), [Tailscale](/gateway/tailscale), [Security](/gateway/security)
+
diff --git a/docs/concepts/context.md b/docs/concepts/context.md
new file mode 100644
index 000000000..c9cb6c143
--- /dev/null
+++ b/docs/concepts/context.md
@@ -0,0 +1,152 @@
+---
+summary: "Context: what the model sees, how it is built, and how to inspect it"
+read_when:
+  - You want to understand what “context” means in Clawdbot
+  - You are debugging why the model “knows” something (or forgot it)
+  - You want to reduce context overhead (/context, /status, /compact)
+---
+# Context
+
+“Context” is **everything Clawdbot sends to the model for a run**. It is bounded by the model’s **context window** (token limit).
+
+Beginner mental model:
+- **System prompt** (Clawdbot-built): rules, tools, skills list, time/runtime, and injected workspace files.
+- **Conversation history**: your messages + the assistant’s messages for this session.
+- **Tool calls/results + attachments**: command output, file reads, images/audio, etc.
+
+Context is *not the same thing* as “memory”: memory can be stored on disk and reloaded later; context is what’s inside the model’s current window.
+
+## Quick start (inspect context)
+
+- `/status` → quick “how full is my window?” view + session settings.
+- `/context list` → what’s injected + rough sizes (per file + totals).
+- `/context detail` → deeper breakdown: per-file, per-tool schema sizes, per-skill entry sizes, and system prompt size.
+- `/cost on` → append per-reply usage line to normal replies.
+- `/compact` → summarize older history into a compact entry to free window space.
+
+See also: [Slash commands](/tools/slash-commands), [Token use & costs](/token-use), [Compaction](/concepts/compaction).
+
+## Example output
+
+Values vary by model, provider, tool policy, and what’s in your workspace.
+
+### `/context list`
+
+```
+🧠 Context breakdown
+Workspace: <workspaceDir>
+Bootstrap max/file: 20,000 chars
+Sandbox: mode=non-main sandboxed=false
+System prompt (run): 38,412 chars (~9,603 tok) (Project Context 23,901 chars (~5,976 tok))
+
+Injected workspace files:
+- AGENTS.md: OK | raw 1,742 chars (~436 tok) | injected 1,742 chars (~436 tok)
+- SOUL.md: OK | raw 912 chars (~228 tok) | injected 912 chars (~228 tok)
+- TOOLS.md: TRUNCATED | raw 54,210 chars (~13,553 tok) | injected 20,962 chars (~5,241 tok)
+- IDENTITY.md: OK | raw 211 chars (~53 tok) | injected 211 chars (~53 tok)
+- USER.md: OK | raw 388 chars (~97 tok) | injected 388 chars (~97 tok)
+- HEARTBEAT.md: MISSING | raw 0 | injected 0
+- BOOTSTRAP.md: OK | raw 0 chars (~0 tok) | injected 0 chars (~0 tok)
+
+Skills list (system prompt text): 2,184 chars (~546 tok) (12 skills)
+Tools: read, edit, write, exec, process, browser, message, sessions_send, …
+Tool list (system prompt text): 1,032 chars (~258 tok)
+Tool schemas (JSON): 31,988 chars (~7,997 tok) (counts toward context; not shown as text)
+Tools: (same as above)
+
+Session tokens (cached): 14,250 total / ctx=32,000
+```
+
+### `/context detail`
+
+```
+🧠 Context breakdown (detailed)
+…
+Top skills (prompt entry size):
+- frontend-design: 412 chars (~103 tok)
+- oracle: 401 chars (~101 tok)
+… (+10 more skills)
+
+Top tools (schema size):
+- browser: 9,812 chars (~2,453 tok)
+- exec: 6,240 chars (~1,560 tok)
+… (+N more tools)
+```
+
+## What counts toward the context window
+
+Everything the model receives counts, including:
+- System prompt (all sections).
+- Conversation history.
+- Tool calls + tool results.
+- Attachments/transcripts (images/audio/files).
+- Compaction summaries and pruning artifacts.
+- Provider “wrappers” or hidden headers (not visible, still counted).
+
+## How Clawdbot builds the system prompt
+
+The system prompt is **Clawdbot-owned** and rebuilt each run. It includes:
+- Tool list + short descriptions.
+- Skills list (metadata only; see below).
+- Workspace location.
+- Time (UTC + converted user time if configured).
+- Runtime metadata (host/OS/model/thinking).
+- Injected workspace bootstrap files under **Project Context**.
+
+Full breakdown: [System Prompt](/concepts/system-prompt).
+
+## Injected workspace files (Project Context)
+
+By default, Clawdbot injects a fixed set of workspace files (if present):
+- `AGENTS.md`
+- `SOUL.md`
+- `TOOLS.md`
+- `IDENTITY.md`
+- `USER.md`
+- `HEARTBEAT.md`
+- `BOOTSTRAP.md` (first-run only)
+
+Large files are truncated per-file using `agents.defaults.bootstrapMaxChars` (default `20000` chars). `/context` shows **raw vs injected** sizes and whether truncation happened.
+
+## Skills: what’s injected vs loaded on-demand
+
+The system prompt includes a compact **skills list** (name + description + location). This list has real overhead.
+
+Skill instructions are *not* included by default. The model is expected to `read` the skill’s `SKILL.md` **only when needed**.
+
+## Tools: there are two costs
+
+Tools affect context in two ways:
+1) **Tool list text** in the system prompt (what you see as “Tooling”).
+2) **Tool schemas** (JSON). These are sent to the model so it can call tools. They count toward context even though you don’t see them as plain text.
+
+`/context detail` breaks down the biggest tool schemas so you can see what dominates.
+
+## Commands, directives, and “inline shortcuts”
+
+Slash commands are handled by the Gateway. There are a few different behaviors:
+- **Standalone commands**: a message that is only `/...` runs as a command.
+- **Directives**: `/think`, `/verbose`, `/reasoning`, `/elevated`, `/model`, `/queue` are stripped before the model sees the message.
+  - Directive-only messages persist session settings.
+  - Inline directives in a normal message act as per-message hints.
+- **Inline shortcuts** (allowlisted senders only): certain `/...` tokens inside a normal message can run immediately (example: “hey /status”), and are stripped before the model sees the remaining text.
+
+Details: [Slash commands](/tools/slash-commands).
+
+## Sessions, compaction, and pruning (what persists)
+
+What persists across messages depends on the mechanism:
+- **Normal history** persists in the session transcript until compacted/pruned by policy.
+- **Compaction** persists a summary into the transcript and keeps recent messages intact.
+- **Pruning** removes old tool results from the *in-memory* prompt for a run, but does not rewrite the transcript.
+
+Docs: [Session](/concepts/session), [Compaction](/concepts/compaction), [Session pruning](/concepts/session-pruning).
+
+## What `/context` actually reports
+
+`/context` prefers the latest **run-built** system prompt report when available:
+- `System prompt (run)` = captured from the last embedded (tool-capable) run and persisted in the session store.
+- `System prompt (estimate)` = computed on the fly when no run report exists (or when running via a CLI backend that doesn’t generate the report).
+
+Either way, it reports sizes and top contributors; it does **not** dump the full system prompt or tool schemas.
+
diff --git a/docs/concepts/markdown-formatting.md b/docs/concepts/markdown-formatting.md
new file mode 100644
index 000000000..da2c1b268
--- /dev/null
+++ b/docs/concepts/markdown-formatting.md
@@ -0,0 +1,108 @@
+---
+summary: "Markdown formatting pipeline for outbound channels"
+read_when:
+  - You are changing markdown formatting or chunking for outbound channels
+  - You are adding a new channel formatter or style mapping
+  - You are debugging formatting regressions across channels
+---
+# Markdown formatting
+
+Clawdbot formats outbound Markdown by converting it into a shared intermediate
+representation (IR) before rendering channel-specific output. The IR keeps the
+source text intact while carrying style/link spans so chunking and rendering can
+stay consistent across channels.
+
+## Goals
+
+- **Consistency:** one parse step, multiple renderers.
+- **Safe chunking:** split text before rendering so inline formatting never
+  breaks across chunks.
+- **Channel fit:** map the same IR to Slack mrkdwn, Telegram HTML, and Signal
+  style ranges without re-parsing Markdown.
+
+## Pipeline
+
+1. **Parse Markdown -> IR**
+   - IR is plain text plus style spans (bold/italic/strike/code/spoiler) and link spans.
+   - Offsets are UTF-16 code units so Signal style ranges align with its API.
+2. **Chunk IR (format-first)**
+   - Chunking happens on the IR text before rendering.
+   - Inline formatting does not split across chunks; spans are sliced per chunk.
+3. **Render per channel**
+   - **Slack:** mrkdwn tokens (bold/italic/strike/code), links as `<url|label>`.
+   - **Telegram:** HTML tags (`<b>`, `<i>`, `<s>`, `<code>`, `<pre><code>`, `<a href>`).
+   - **Signal:** plain text + `text-style` ranges; links become `label (url)` when label differs.
+
+## IR example
+
+Input Markdown:
+
+```markdown
+Hello **world** — see [docs](https://docs.clawd.bot).
+```
+
+IR (schematic):
+
+```json
+{
+  "text": "Hello world — see docs.",
+  "styles": [
+    { "start": 6, "end": 11, "style": "bold" }
+  ],
+  "links": [
+    { "start": 19, "end": 23, "href": "https://docs.clawd.bot" }
+  ]
+}
+```
+
+## Where it is used
+
+- Slack, Telegram, and Signal outbound adapters render from the IR.
+- Other channels (WhatsApp, iMessage, MS Teams, Discord) still use plain text or
+  their own formatting rules.
+
+## Chunking rules
+
+- Chunk limits come from channel adapters/config and are applied to the IR text.
+- Code fences are preserved as a single block with a trailing newline so channels
+  render them correctly.
+- List prefixes and blockquote prefixes are part of the IR text, so chunking
+  does not split mid-prefix.
+- Inline styles (bold/italic/strike/inline-code/spoiler) are never split across
+  chunks; the renderer reopens styles inside each chunk.
+
+If you need more on chunking behavior across channels, see
+[Streaming + chunking](/concepts/streaming).
+
+## Link policy
+
+- **Slack:** `[label](url)` -> `<url|label>`; bare URLs remain bare. Autolink
+  is disabled during parse to avoid double-linking.
+- **Telegram:** `[label](url)` -> `<a href="url">label</a>` (HTML parse mode).
+- **Signal:** `[label](url)` -> `label (url)` unless label matches the URL.
+
+## Spoilers
+
+Spoiler markers (`||spoiler||`) are parsed only for Signal, where they map to
+SPOILER style ranges. Other channels treat them as plain text.
+
+## How to add or update a channel formatter
+
+1. **Parse once:** use the shared `markdownToIR(...)` helper with channel-appropriate
+   options (autolink, heading style, blockquote prefix).
+2. **Render:** implement a renderer with `renderMarkdownWithMarkers(...)` and a
+   style marker map (or Signal style ranges).
+3. **Chunk:** call `chunkMarkdownIR(...)` before rendering; render each chunk.
+4. **Wire adapter:** update the channel outbound adapter to use the new chunker
+   and renderer.
+5. **Test:** add or update format tests and an outbound delivery test if the
+   channel uses chunking.
+
+## Common gotchas
+
+- Slack angle-bracket tokens (`<@U123>`, `<#C123>`, `<https://...>`) must be
+  preserved; escape raw HTML safely.
+- Telegram HTML requires escaping text outside tags to avoid broken markup.
+- Signal style ranges depend on UTF-16 offsets; do not use code point offsets.
+- Preserve trailing newlines for fenced code blocks so closing markers land on
+  their own line.
diff --git a/docs/docs.json b/docs/docs.json
index 0cf1606da..ff55cf71f 100644
--- a/docs/docs.json
+++ b/docs/docs.json
@@ -861,7 +861,8 @@
           "providers/openrouter",
           "providers/opencode",
           "providers/glm",
-          "providers/zai"
+          "providers/zai",
+          "providers/clawline"
         ]
       },
       {
diff --git a/docs/providers/clawline.md b/docs/providers/clawline.md
new file mode 100644
index 000000000..731507f65
--- /dev/null
+++ b/docs/providers/clawline.md
@@ -0,0 +1,63 @@
+---
+title: Clawline
+sidebarTitle: Clawline
+description: Local mobile provider for the Clawline iOS/Android clients.
+---
+
+# Clawline Provider
+
+Clawline exposes a pairing/token-authenticated WebSocket + HTTP server that the
+Clawline iOS/Android apps can connect to for chat, uploads, and downloads. The
+service runs inside the Clawdbot gateway process, so it shares the same runtime
+configuration and adapters as the rest of your deployment.
+
+## Enabling
+
+The provider is enabled by default. Add a `clawline` block to configure bind
+address, port, or media paths:
+
+```json5
+{
+  clawline: {
+    // Bind to loopback by default; set allowInsecurePublic to true if you bind to 0.0.0.0 or a LAN IP.
+    network: {
+      bindAddress: "127.0.0.1",
+      allowInsecurePublic: false,
+      allowedOrigins: ["null"]
+    },
+    port: 18792,
+    statePath: "~/.clawdbot/clawline",
+    media: {
+      storagePath: "~/.clawdbot/clawline-media"
+    }
+  }
+}
+```
+
+Set `clawline.enabled` to `false` to disable the service entirely.
+
+## Adapter overrides
+
+Clawline reuses the default agent configuration (model, CLI backend, workspace,
+timeouts) when generating assistant replies. You can override those settings for
+mobile clients without touching the global agent configuration:
+
+```json5
+{
+  clawline: {
+    adapter: {
+      provider: "anthropic",
+      model: "claude-sonnet-4-5",
+      timeoutSeconds: 120,
+      responseFallback: "Sorry, something went wrong."
+    }
+  }
+}
+```
+
+## Transport security
+
+The server binds to `127.0.0.1` by default. When binding to any other address
+you **must** set `clawline.network.allowInsecurePublic = true` and provide an
+allowlist of `network.allowedOrigins`. Run Clawline behind Tailscale, a VPN, or
+a reverse proxy with TLS termination for production use.
diff --git a/docs/tools/chrome-extension.md b/docs/tools/chrome-extension.md
new file mode 100644
index 000000000..c96a45a78
--- /dev/null
+++ b/docs/tools/chrome-extension.md
@@ -0,0 +1,181 @@
+---
+summary: "Chrome extension: let Clawdbot drive your existing Chrome tab"
+read_when:
+  - You want the agent to drive an existing Chrome tab (toolbar button)
+  - You need remote Gateway + local browser automation via Tailscale
+  - You want to understand the security implications of browser takeover
+---
+
+# Chrome extension (browser relay)
+
+The Clawdbot Chrome extension lets the agent control your **existing Chrome tabs** (your normal Chrome window) instead of launching a separate clawd-managed Chrome profile.
+
+Attach/detach happens via a **single Chrome toolbar button**.
+
+## What it is (concept)
+
+There are three parts:
+- **Browser control server** (HTTP): the API the agent/tool calls (`browser.controlUrl`)
+- **Local relay server** (loopback CDP): bridges between the control server and the extension (`http://127.0.0.1:18792` by default)
+- **Chrome MV3 extension**: attaches to the active tab using `chrome.debugger` and pipes CDP messages to the relay
+
+Clawdbot then controls the attached tab through the normal `browser` tool surface (selecting the right profile).
+
+## Install / load (unpacked)
+
+1) Install the extension to a stable local path:
+
+```bash
+clawdbot browser extension install
+```
+
+2) Print the installed extension directory path:
+
+```bash
+clawdbot browser extension path
+```
+
+3) Chrome → `chrome://extensions`
+- Enable “Developer mode”
+- “Load unpacked” → select the directory printed above
+
+4) Pin the extension.
+
+## Updates (no build step)
+
+The extension ships inside the Clawdbot release (npm package) as static files. There is no separate “build” step.
+
+After upgrading Clawdbot:
+- Re-run `clawdbot browser extension install` to refresh the installed files under your Clawdbot state directory.
+- Chrome → `chrome://extensions` → click “Reload” on the extension.
+
+## Create a browser profile for the extension
+
+```bash
+clawdbot browser create-profile \
+  --name chrome \
+  --driver extension \
+  --cdp-url http://127.0.0.1:18792 \
+  --color "#00AA00"
+```
+
+Then target it:
+- CLI: `clawdbot browser --browser-profile chrome tabs`
+- Agent tool: `browser` with `profile="chrome"`
+
+## Attach / detach (toolbar button)
+
+- Open the tab you want Clawdbot to control.
+- Click the extension icon.
+  - Badge shows `ON` when attached.
+- Click again to detach.
+
+## Which tab does it control?
+
+- It does **not** automatically control “whatever tab you’re looking at”.
+- It controls **only the tab(s) you explicitly attached** by clicking the toolbar button.
+- To switch: open the other tab and click the extension icon there.
+
+## Badge + common errors
+
+- `ON`: attached; Clawdbot can drive that tab.
+- `…`: connecting to the local relay.
+- `!`: relay not reachable (most common: browser relay server isn’t running on this machine).
+
+If you see `!`:
+- Make sure the Gateway is running locally (default setup), or run `clawdbot browser serve` on this machine (remote gateway setup).
+- Open the extension Options page; it shows whether the relay is reachable.
+
+## Do I need `clawdbot browser serve`?
+
+### Local Gateway (same machine as Chrome) — usually **no**
+
+If the Gateway is running on the same machine as Chrome and your `browser.controlUrl` is loopback (default),
+you typically **do not** need `clawdbot browser serve`.
+
+The Gateway’s built-in browser control server will start on `http://127.0.0.1:18791/` and Clawdbot will
+auto-start the local relay server when you use a profile with `driver="extension"`.
+
+### Remote Gateway (Gateway runs elsewhere) — **yes**
+
+If your Gateway runs on another machine, run `clawdbot browser serve` on the machine that runs Chrome
+(and publish it via Tailscale Serve / TLS). See the section below.
+
+## Sandboxing (tool containers)
+
+If your agent session is sandboxed (`agents.defaults.sandbox.mode != "off"`), the `browser` tool can be restricted:
+
+- By default, sandboxed sessions often target the **sandbox browser** (`target="sandbox"`), not your host Chrome.
+- Chrome extension relay takeover requires controlling the **host** browser control server.
+
+Options:
+- Easiest: use the extension from a **non-sandboxed** session/agent.
+- Or allow host browser control for sandboxed sessions:
+
+```json5
+{
+  agents: {
+    defaults: {
+      sandbox: {
+        browser: {
+          allowHostControl: true
+        }
+      }
+    }
+  }
+}
+```
+
+Then ensure the tool isn’t denied by tool policy, and (if needed) call `browser` with `target="host"`.
+
+Debugging: `clawdbot sandbox explain`
+
+## Remote Gateway (recommended: Tailscale Serve)
+
+Goal: Gateway runs on one machine, but Chrome runs somewhere else.
+
+On the **browser machine**:
+
+```bash
+clawdbot browser serve --bind 127.0.0.1 --port 18791 --token <token>
+tailscale serve https / http://127.0.0.1:18791
+```
+
+On the **Gateway machine**:
+- Set `browser.controlUrl` to the HTTPS Serve URL (MagicDNS/ts.net).
+- Provide the token (prefer env):
+
+```bash
+export CLAWDBOT_BROWSER_CONTROL_TOKEN="<token>"
+```
+
+Then the agent can drive the browser by calling the remote `browser.controlUrl` API, while the extension + relay stay local on the browser machine.
+
+## How “extension path” works
+
+`clawdbot browser extension path` prints the **installed** on-disk directory containing the extension files.
+
+The CLI intentionally does **not** print a `node_modules` path. Always run `clawdbot browser extension install` first to copy the extension to a stable location under your Clawdbot state directory.
+
+If you move or delete that install directory, Chrome will mark the extension as broken until you reload it from a valid path.
+
+## Security implications (read this)
+
+This is powerful and risky. Treat it like giving the model “hands on your browser”.
+
+- The extension uses Chrome’s debugger API (`chrome.debugger`). When attached, the model can:
+  - click/type/navigate in that tab
+  - read page content
+  - access whatever the tab’s logged-in session can access
+- **This is not isolated** like the dedicated clawd-managed profile.
+  - If you attach to your daily-driver profile/tab, you’re granting access to that account state.
+
+Recommendations:
+- Prefer a dedicated Chrome profile (separate from your personal browsing) for extension relay usage.
+- Keep the browser control server tailnet-only (Tailscale) and require a token.
+- Avoid exposing browser control over LAN (`0.0.0.0`) and avoid Funnel (public).
+
+Related:
+- Browser tool overview: [Browser](/tools/browser)
+- Security audit: [Security](/gateway/security)
+- Tailscale setup: [Tailscale](/gateway/tailscale)
diff --git a/docs/tools/web.md b/docs/tools/web.md
new file mode 100644
index 000000000..eb0b8e968
--- /dev/null
+++ b/docs/tools/web.md
@@ -0,0 +1,113 @@
+---
+summary: "Web search + fetch tools (Brave Search API)"
+read_when:
+  - You want to enable web_search or web_fetch
+  - You need Brave Search API key setup
+---
+
+# Web tools
+
+Clawdbot ships two lightweight web tools:
+
+- `web_search` — Brave Search API queries (fast, structured results).
+- `web_fetch` — HTTP fetch + readable extraction (HTML → markdown/text).
+
+These are **not** browser automation. For JS-heavy sites or logins, use the
+[Browser tool](/tools/browser).
+
+## How it works
+
+- `web_search` calls Brave’s Search API and returns structured results
+  (title, URL, snippet). No browser is involved.
+- Results are cached by query for 15 minutes (configurable).
+- `web_fetch` does a plain HTTP GET and extracts readable content
+  (HTML → markdown/text). It does **not** execute JavaScript.
+- In sandboxed sessions, `web_fetch` is enabled automatically (unless explicitly disabled).
+
+## Getting a Brave API key
+
+1) Create a Brave Search API account at https://brave.com/search/api/
+2) Generate an API key in the dashboard.
+3) Run `clawdbot configure --section web` to store the key in config (recommended), or set `BRAVE_API_KEY` in your environment.
+
+Brave provides a free tier plus paid plans; check the Brave API portal for the
+current limits and pricing.
+
+### Where to set the key (recommended)
+
+**Recommended:** run `clawdbot configure --section web`. It stores the key in
+`~/.clawdbot/clawdbot.json` under `tools.web.search.apiKey`.
+
+**Environment alternative:** set `BRAVE_API_KEY` in the Gateway process
+environment. For a daemon install, put it in `~/.clawdbot/.env` (or your
+service environment). See [Env vars](/start/faq#how-does-clawdbot-load-environment-variables).
+
+## web_search
+
+Search the web with Brave’s API.
+
+### Requirements
+
+- `tools.web.search.enabled: true`
+- Brave API key (recommended: `clawdbot configure --section web`, or set `BRAVE_API_KEY`)
+
+### Config
+
+```json5
+{
+  tools: {
+    web: {
+      search: {
+        enabled: true,
+        apiKey: "BRAVE_API_KEY_HERE", // optional if BRAVE_API_KEY is set
+        maxResults: 5,
+        timeoutSeconds: 30,
+        cacheTtlMinutes: 15
+      }
+    }
+  }
+}
+```
+
+### Tool parameters
+
+- `query` (required)
+- `count` (1–10; default from config)
+
+## web_fetch
+
+Fetch a URL and extract readable content.
+
+### Requirements
+
+- `tools.web.fetch.enabled: true`
+
+### Config
+
+```json5
+{
+  tools: {
+    web: {
+      fetch: {
+        enabled: true,
+        maxChars: 50000,
+        timeoutSeconds: 30,
+        cacheTtlMinutes: 15,
+        userAgent: "clawdbot/2026.1.14"
+      }
+    }
+  }
+}
+```
+
+### Tool parameters
+
+- `url` (required, http/https only)
+- `extractMode` (`markdown` | `text`)
+- `maxChars` (truncate long pages)
+
+Notes:
+- `web_fetch` is best-effort extraction; some sites will need the browser tool.
+- Responses are cached (default 15 minutes) to reduce repeated fetches.
+- If you use tool profiles/allowlists, add `web_search`/`web_fetch` or `group:web`.
+ - If the Brave key is missing, `web_search` returns a short setup hint with a docs link.
diff --git a/extensions/zalo/CHANGELOG.md b/extensions/zalo/CHANGELOG.md
new file mode 100644
index 000000000..3c2e37730
--- /dev/null
+++ b/extensions/zalo/CHANGELOG.md
@@ -0,0 +1,10 @@
+# Changelog
+
+## 0.1.0
+
+### Features
+- Zalo Bot API channel plugin with token-based auth (env/config/file).
+- Direct message support (DMs only) with pairing/allowlist/open/disabled policies.
+- Polling and webhook delivery modes.
+- Text + image messaging with 2000-char chunking and media size caps.
+- Multi-account support with per-account config.
diff --git a/extensions/zalo/README.md b/extensions/zalo/README.md
new file mode 100644
index 000000000..1d9d3483a
--- /dev/null
+++ b/extensions/zalo/README.md
@@ -0,0 +1,50 @@
+# @clawdbot/zalo
+
+Zalo channel plugin for Clawdbot (Bot API).
+
+## Install (local checkout)
+
+```bash
+clawdbot plugins install ./extensions/zalo
+```
+
+## Install (npm)
+
+```bash
+clawdbot plugins install @clawdbot/zalo
+```
+
+Onboarding: select Zalo and confirm the install prompt to fetch the plugin automatically.
+
+## Config
+
+```json5
+{
+  channels: {
+    zalo: {
+      enabled: true,
+      botToken: "12345689:abc-xyz",
+      dmPolicy: "pairing",
+      proxy: "http://proxy.local:8080"
+    }
+  }
+}
+```
+
+## Webhook mode
+
+```json5
+{
+  channels: {
+    zalo: {
+      webhookUrl: "https://example.com/zalo-webhook",
+      webhookSecret: "your-secret-8-plus-chars",
+      webhookPath: "/zalo-webhook"
+    }
+  }
+}
+```
+
+If `webhookPath` is omitted, the plugin uses the webhook URL path.
+
+Restart the gateway after config changes.
diff --git a/extensions/zalo/index.ts b/extensions/zalo/index.ts
new file mode 100644
index 000000000..aa85bead4
--- /dev/null
+++ b/extensions/zalo/index.ts
@@ -0,0 +1,16 @@
+import type { ClawdbotPluginApi } from "../../src/plugins/types.js";
+
+import { zaloDock, zaloPlugin } from "./src/channel.js";
+import { handleZaloWebhookRequest } from "./src/monitor.js";
+
+const plugin = {
+  id: "zalo",
+  name: "Zalo",
+  description: "Zalo channel plugin (Bot API)",
+  register(api: ClawdbotPluginApi) {
+    api.registerChannel({ plugin: zaloPlugin, dock: zaloDock });
+    api.registerHttpHandler(handleZaloWebhookRequest);
+  },
+};
+
+export default plugin;
diff --git a/extensions/zalo/package.json b/extensions/zalo/package.json
new file mode 100644
index 000000000..fff36d6d4
--- /dev/null
+++ b/extensions/zalo/package.json
@@ -0,0 +1,12 @@
+{
+  "name": "@clawdbot/zalo",
+  "version": "0.1.0",
+  "type": "module",
+  "description": "Clawdbot Zalo channel plugin",
+  "clawdbot": {
+    "extensions": ["./index.ts"]
+  },
+  "dependencies": {
+    "undici": "7.18.2"
+  }
+}
diff --git a/extensions/zalo/src/accounts.ts b/extensions/zalo/src/accounts.ts
new file mode 100644
index 000000000..c9dc3c069
--- /dev/null
+++ b/extensions/zalo/src/accounts.ts
@@ -0,0 +1,74 @@
+import type {
+  CoreConfig,
+  ResolvedZaloAccount,
+  ZaloAccountConfig,
+  ZaloConfig,
+} from "./types.js";
+import { resolveZaloToken } from "./token.js";
+import { DEFAULT_ACCOUNT_ID, normalizeAccountId } from "./shared/account-ids.js";
+
+function listConfiguredAccountIds(cfg: CoreConfig): string[] {
+  const accounts = (cfg.channels?.zalo as ZaloConfig | undefined)?.accounts;
+  if (!accounts || typeof accounts !== "object") return [];
+  return Object.keys(accounts).filter(Boolean);
+}
+
+export function listZaloAccountIds(cfg: CoreConfig): string[] {
+  const ids = listConfiguredAccountIds(cfg);
+  if (ids.length === 0) return [DEFAULT_ACCOUNT_ID];
+  return ids.sort((a, b) => a.localeCompare(b));
+}
+
+export function resolveDefaultZaloAccountId(cfg: CoreConfig): string {
+  const zaloConfig = cfg.channels?.zalo as ZaloConfig | undefined;
+  if (zaloConfig?.defaultAccount?.trim()) return zaloConfig.defaultAccount.trim();
+  const ids = listZaloAccountIds(cfg);
+  if (ids.includes(DEFAULT_ACCOUNT_ID)) return DEFAULT_ACCOUNT_ID;
+  return ids[0] ?? DEFAULT_ACCOUNT_ID;
+}
+
+function resolveAccountConfig(
+  cfg: CoreConfig,
+  accountId: string,
+): ZaloAccountConfig | undefined {
+  const accounts = (cfg.channels?.zalo as ZaloConfig | undefined)?.accounts;
+  if (!accounts || typeof accounts !== "object") return undefined;
+  return accounts[accountId] as ZaloAccountConfig | undefined;
+}
+
+function mergeZaloAccountConfig(cfg: CoreConfig, accountId: string): ZaloAccountConfig {
+  const raw = (cfg.channels?.zalo ?? {}) as ZaloConfig;
+  const { accounts: _ignored, defaultAccount: _ignored2, ...base } = raw;
+  const account = resolveAccountConfig(cfg, accountId) ?? {};
+  return { ...base, ...account };
+}
+
+export function resolveZaloAccount(params: {
+  cfg: CoreConfig;
+  accountId?: string | null;
+}): ResolvedZaloAccount {
+  const accountId = normalizeAccountId(params.accountId);
+  const baseEnabled = (params.cfg.channels?.zalo as ZaloConfig | undefined)?.enabled !== false;
+  const merged = mergeZaloAccountConfig(params.cfg, accountId);
+  const accountEnabled = merged.enabled !== false;
+  const enabled = baseEnabled && accountEnabled;
+  const tokenResolution = resolveZaloToken(
+    params.cfg.channels?.zalo as ZaloConfig | undefined,
+    accountId,
+  );
+
+  return {
+    accountId,
+    name: merged.name?.trim() || undefined,
+    enabled,
+    token: tokenResolution.token,
+    tokenSource: tokenResolution.source,
+    config: merged,
+  };
+}
+
+export function listEnabledZaloAccounts(cfg: CoreConfig): ResolvedZaloAccount[] {
+  return listZaloAccountIds(cfg)
+    .map((accountId) => resolveZaloAccount({ cfg, accountId }))
+    .filter((account) => account.enabled);
+}
diff --git a/extensions/zalo/src/actions.ts b/extensions/zalo/src/actions.ts
new file mode 100644
index 000000000..aeaece1bc
--- /dev/null
+++ b/extensions/zalo/src/actions.ts
@@ -0,0 +1,59 @@
+import type { ChannelMessageActionAdapter, ChannelMessageActionName } from "../../src/channels/plugins/types.js";
+
+import type { CoreConfig } from "./types.js";
+import { listEnabledZaloAccounts } from "./accounts.js";
+import { sendMessageZalo } from "./send.js";
+import { jsonResult, readStringParam } from "./tool-helpers.js";
+
+const providerId = "zalo";
+
+function listEnabledAccounts(cfg: CoreConfig) {
+  return listEnabledZaloAccounts(cfg).filter(
+    (account) => account.enabled && account.tokenSource !== "none",
+  );
+}
+
+export const zaloMessageActions: ChannelMessageActionAdapter = {
+  listActions: ({ cfg }) => {
+    const accounts = listEnabledAccounts(cfg as CoreConfig);
+    if (accounts.length === 0) return [];
+    const actions = new Set<ChannelMessageActionName>(["send"]);
+    return Array.from(actions);
+  },
+  supportsButtons: () => false,
+  extractToolSend: ({ args }) => {
+    const action = typeof args.action === "string" ? args.action.trim() : "";
+    if (action !== "sendMessage") return null;
+    const to = typeof args.to === "string" ? args.to : undefined;
+    if (!to) return null;
+    const accountId = typeof args.accountId === "string" ? args.accountId.trim() : undefined;
+    return { to, accountId };
+  },
+  handleAction: async ({ action, params, cfg, accountId }) => {
+    if (action === "send") {
+      const to = readStringParam(params, "to", { required: true });
+      const content = readStringParam(params, "message", {
+        required: true,
+        allowEmpty: true,
+      });
+      const mediaUrl = readStringParam(params, "media", { trim: false });
+
+      const result = await sendMessageZalo(to ?? "", content ?? "", {
+        accountId: accountId ?? undefined,
+        mediaUrl: mediaUrl ?? undefined,
+        cfg: cfg as CoreConfig,
+      });
+
+      if (!result.ok) {
+        return jsonResult({
+          ok: false,
+          error: result.error ?? "Failed to send Zalo message",
+        });
+      }
+
+      return jsonResult({ ok: true, to, messageId: result.messageId });
+    }
+
+    throw new Error(`Action ${action} is not supported for provider ${providerId}.`);
+  },
+};
diff --git a/extensions/zalo/src/api.ts b/extensions/zalo/src/api.ts
new file mode 100644
index 000000000..63c04351a
--- /dev/null
+++ b/extensions/zalo/src/api.ts
@@ -0,0 +1,206 @@
+/**
+ * Zalo Bot API client
+ * @see https://bot.zaloplatforms.com/docs
+ */
+
+const ZALO_API_BASE = "https://bot-api.zaloplatforms.com";
+
+export type ZaloFetch = (input: string, init?: RequestInit) => Promise<Response>;
+
+export type ZaloApiResponse<T = unknown> = {
+  ok: boolean;
+  result?: T;
+  error_code?: number;
+  description?: string;
+};
+
+export type ZaloBotInfo = {
+  id: string;
+  name: string;
+  avatar?: string;
+};
+
+export type ZaloMessage = {
+  message_id: string;
+  from: {
+    id: string;
+    name?: string;
+    avatar?: string;
+  };
+  chat: {
+    id: string;
+    chat_type: "PRIVATE" | "GROUP";
+  };
+  date: number;
+  text?: string;
+  photo?: string;
+  caption?: string;
+  sticker?: string;
+};
+
+export type ZaloUpdate = {
+  event_name:
+    | "message.text.received"
+    | "message.image.received"
+    | "message.sticker.received"
+    | "message.unsupported.received";
+  message?: ZaloMessage;
+};
+
+export type ZaloSendMessageParams = {
+  chat_id: string;
+  text: string;
+};
+
+export type ZaloSendPhotoParams = {
+  chat_id: string;
+  photo: string;
+  caption?: string;
+};
+
+export type ZaloSetWebhookParams = {
+  url: string;
+  secret_token: string;
+};
+
+export type ZaloGetUpdatesParams = {
+  /** Timeout in seconds (passed as string to API) */
+  timeout?: number;
+};
+
+export class ZaloApiError extends Error {
+  constructor(
+    message: string,
+    public readonly errorCode?: number,
+    public readonly description?: string,
+  ) {
+    super(message);
+    this.name = "ZaloApiError";
+  }
+
+  /** True if this is a long-polling timeout (no updates available) */
+  get isPollingTimeout(): boolean {
+    return this.errorCode === 408;
+  }
+}
+
+/**
+ * Call the Zalo Bot API
+ */
+export async function callZaloApi<T = unknown>(
+  method: string,
+  token: string,
+  body?: Record<string, unknown>,
+  options?: { timeoutMs?: number; fetch?: ZaloFetch },
+): Promise<ZaloApiResponse<T>> {
+  const url = `${ZALO_API_BASE}/bot${token}/${method}`;
+  const controller = new AbortController();
+  const timeoutId = options?.timeoutMs
+    ? setTimeout(() => controller.abort(), options.timeoutMs)
+    : undefined;
+  const fetcher = options?.fetch ?? fetch;
+
+  try {
+    const response = await fetcher(url, {
+      method: "POST",
+      headers: {
+        "Content-Type": "application/json",
+      },
+      body: body ? JSON.stringify(body) : undefined,
+      signal: controller.signal,
+    });
+
+    const data = (await response.json()) as ZaloApiResponse<T>;
+
+    if (!data.ok) {
+      throw new ZaloApiError(
+        data.description ?? `Zalo API error: ${method}`,
+        data.error_code,
+        data.description,
+      );
+    }
+
+    return data;
+  } finally {
+    if (timeoutId) clearTimeout(timeoutId);
+  }
+}
+
+/**
+ * Validate bot token and get bot info
+ */
+export async function getMe(
+  token: string,
+  timeoutMs?: number,
+  fetcher?: ZaloFetch,
+): Promise<ZaloApiResponse<ZaloBotInfo>> {
+  return callZaloApi<ZaloBotInfo>("getMe", token, undefined, { timeoutMs, fetch: fetcher });
+}
+
+/**
+ * Send a text message
+ */
+export async function sendMessage(
+  token: string,
+  params: ZaloSendMessageParams,
+  fetcher?: ZaloFetch,
+): Promise<ZaloApiResponse<ZaloMessage>> {
+  return callZaloApi<ZaloMessage>("sendMessage", token, params, { fetch: fetcher });
+}
+
+/**
+ * Send a photo message
+ */
+export async function sendPhoto(
+  token: string,
+  params: ZaloSendPhotoParams,
+  fetcher?: ZaloFetch,
+): Promise<ZaloApiResponse<ZaloMessage>> {
+  return callZaloApi<ZaloMessage>("sendPhoto", token, params, { fetch: fetcher });
+}
+
+/**
+ * Get updates using long polling (dev/testing only)
+ * Note: Zalo returns a single update per call, not an array like Telegram
+ */
+export async function getUpdates(
+  token: string,
+  params?: ZaloGetUpdatesParams,
+  fetcher?: ZaloFetch,
+): Promise<ZaloApiResponse<ZaloUpdate>> {
+  const pollTimeoutSec = params?.timeout ?? 30;
+  const timeoutMs = (pollTimeoutSec + 5) * 1000;
+  const body = { timeout: String(pollTimeoutSec) };
+  return callZaloApi<ZaloUpdate>("getUpdates", token, body, { timeoutMs, fetch: fetcher });
+}
+
+/**
+ * Set webhook URL for receiving updates
+ */
+export async function setWebhook(
+  token: string,
+  params: ZaloSetWebhookParams,
+  fetcher?: ZaloFetch,
+): Promise<ZaloApiResponse<boolean>> {
+  return callZaloApi<boolean>("setWebhook", token, params, { fetch: fetcher });
+}
+
+/**
+ * Delete webhook configuration
+ */
+export async function deleteWebhook(
+  token: string,
+  fetcher?: ZaloFetch,
+): Promise<ZaloApiResponse<boolean>> {
+  return callZaloApi<boolean>("deleteWebhook", token, undefined, { fetch: fetcher });
+}
+
+/**
+ * Get current webhook info
+ */
+export async function getWebhookInfo(
+  token: string,
+  fetcher?: ZaloFetch,
+): Promise<ZaloApiResponse<{ url?: string; has_custom_certificate?: boolean }>> {
+  return callZaloApi("getWebhookInfo", token, undefined, { fetch: fetcher });
+}
diff --git a/extensions/zalo/src/channel.ts b/extensions/zalo/src/channel.ts
new file mode 100644
index 000000000..d03812653
--- /dev/null
+++ b/extensions/zalo/src/channel.ts
@@ -0,0 +1,370 @@
+import type { ChannelDock, ChannelPlugin } from "../../src/channels/plugins/types.js";
+import type { ChannelAccountSnapshot } from "../../src/channels/plugins/types.js";
+
+import { listZaloAccountIds, resolveDefaultZaloAccountId, resolveZaloAccount, type ResolvedZaloAccount } from "./accounts.js";
+import { zaloMessageActions } from "./actions.js";
+import {
+  deleteAccountFromConfigSection,
+  setAccountEnabledInConfigSection,
+} from "./shared/channel-config.js";
+import { zaloOnboardingAdapter } from "./onboarding.js";
+import { formatPairingApproveHint, PAIRING_APPROVED_MESSAGE } from "./shared/pairing.js";
+import { resolveZaloProxyFetch } from "./proxy.js";
+import { probeZalo } from "./probe.js";
+import { sendMessageZalo } from "./send.js";
+import {
+  applyAccountNameToChannelSection,
+  migrateBaseNameToDefaultAccount,
+} from "./shared/channel-setup.js";
+import { collectZaloStatusIssues } from "./status-issues.js";
+import type { CoreConfig } from "./types.js";
+import { DEFAULT_ACCOUNT_ID, normalizeAccountId } from "./shared/account-ids.js";
+
+const meta = {
+  id: "zalo",
+  label: "Zalo",
+  selectionLabel: "Zalo (Bot API)",
+  docsPath: "/channels/zalo",
+  docsLabel: "zalo",
+  blurb: "Vietnam-focused messaging platform with Bot API.",
+  aliases: ["zl"],
+  order: 80,
+  quickstartAllowFrom: true,
+};
+
+
+function normalizeZaloMessagingTarget(raw: string): string | undefined {
+  const trimmed = raw?.trim();
+  if (!trimmed) return undefined;
+  return trimmed.replace(/^(zalo|zl):/i, "");
+}
+
+export const zaloDock: ChannelDock = {
+  id: "zalo",
+  capabilities: {
+    chatTypes: ["direct"],
+    media: true,
+    blockStreaming: true,
+  },
+  outbound: { textChunkLimit: 2000 },
+  config: {
+    resolveAllowFrom: ({ cfg, accountId }) =>
+      (resolveZaloAccount({ cfg: cfg as CoreConfig, accountId }).config.allowFrom ?? []).map(
+        (entry) => String(entry),
+      ),
+    formatAllowFrom: ({ allowFrom }) =>
+      allowFrom
+        .map((entry) => String(entry).trim())
+        .filter(Boolean)
+        .map((entry) => entry.replace(/^(zalo|zl):/i, ""))
+        .map((entry) => entry.toLowerCase()),
+  },
+  groups: {
+    resolveRequireMention: () => true,
+  },
+  threading: {
+    resolveReplyToMode: () => "off",
+  },
+};
+
+export const zaloPlugin: ChannelPlugin<ResolvedZaloAccount> = {
+  id: "zalo",
+  meta,
+  onboarding: zaloOnboardingAdapter,
+  capabilities: {
+    chatTypes: ["direct"],
+    media: true,
+    reactions: false,
+    threads: false,
+    polls: false,
+    nativeCommands: false,
+    blockStreaming: true,
+  },
+  reload: { configPrefixes: ["channels.zalo"] },
+  config: {
+    listAccountIds: (cfg) => listZaloAccountIds(cfg as CoreConfig),
+    resolveAccount: (cfg, accountId) => resolveZaloAccount({ cfg: cfg as CoreConfig, accountId }),
+    defaultAccountId: (cfg) => resolveDefaultZaloAccountId(cfg as CoreConfig),
+    setAccountEnabled: ({ cfg, accountId, enabled }) =>
+      setAccountEnabledInConfigSection({
+        cfg: cfg as CoreConfig,
+        sectionKey: "zalo",
+        accountId,
+        enabled,
+        allowTopLevel: true,
+      }),
+    deleteAccount: ({ cfg, accountId }) =>
+      deleteAccountFromConfigSection({
+        cfg: cfg as CoreConfig,
+        sectionKey: "zalo",
+        accountId,
+        clearBaseFields: ["botToken", "tokenFile", "name"],
+      }),
+    isConfigured: (account) => Boolean(account.token?.trim()),
+    describeAccount: (account): ChannelAccountSnapshot => ({
+      accountId: account.accountId,
+      name: account.name,
+      enabled: account.enabled,
+      configured: Boolean(account.token?.trim()),
+      tokenSource: account.tokenSource,
+    }),
+    resolveAllowFrom: ({ cfg, accountId }) =>
+      (resolveZaloAccount({ cfg: cfg as CoreConfig, accountId }).config.allowFrom ?? []).map(
+        (entry) => String(entry),
+      ),
+    formatAllowFrom: ({ allowFrom }) =>
+      allowFrom
+        .map((entry) => String(entry).trim())
+        .filter(Boolean)
+        .map((entry) => entry.replace(/^(zalo|zl):/i, ""))
+        .map((entry) => entry.toLowerCase()),
+  },
+  security: {
+    resolveDmPolicy: ({ cfg, accountId, account }) => {
+      const resolvedAccountId = accountId ?? account.accountId ?? DEFAULT_ACCOUNT_ID;
+      const useAccountPath = Boolean(
+        (cfg as CoreConfig).channels?.zalo?.accounts?.[resolvedAccountId],
+      );
+      const basePath = useAccountPath
+        ? `channels.zalo.accounts.${resolvedAccountId}.`
+        : "channels.zalo.";
+      return {
+        policy: account.config.dmPolicy ?? "pairing",
+        allowFrom: account.config.allowFrom ?? [],
+        policyPath: `${basePath}dmPolicy`,
+        allowFromPath: basePath,
+        approveHint: formatPairingApproveHint("zalo"),
+        normalizeEntry: (raw) => raw.replace(/^(zalo|zl):/i, ""),
+      };
+    },
+  },
+  groups: {
+    resolveRequireMention: () => true,
+  },
+  threading: {
+    resolveReplyToMode: () => "off",
+  },
+  actions: zaloMessageActions,
+  messaging: {
+    normalizeTarget: normalizeZaloMessagingTarget,
+  },
+  setup: {
+    resolveAccountId: ({ accountId }) => normalizeAccountId(accountId),
+    applyAccountName: ({ cfg, accountId, name }) =>
+      applyAccountNameToChannelSection({
+        cfg: cfg as CoreConfig,
+        channelKey: "zalo",
+        accountId,
+        name,
+      }),
+    validateInput: ({ accountId, input }) => {
+      if (input.useEnv && accountId !== DEFAULT_ACCOUNT_ID) {
+        return "ZALO_BOT_TOKEN can only be used for the default account.";
+      }
+      if (!input.useEnv && !input.token && !input.tokenFile) {
+        return "Zalo requires --token or --token-file (or --use-env).";
+      }
+      return null;
+    },
+    applyAccountConfig: ({ cfg, accountId, input }) => {
+      const namedConfig = applyAccountNameToChannelSection({
+        cfg: cfg as CoreConfig,
+        channelKey: "zalo",
+        accountId,
+        name: input.name,
+      });
+      const next =
+        accountId !== DEFAULT_ACCOUNT_ID
+          ? migrateBaseNameToDefaultAccount({
+              cfg: namedConfig,
+              channelKey: "zalo",
+            })
+          : namedConfig;
+      if (accountId === DEFAULT_ACCOUNT_ID) {
+        return {
+          ...next,
+          channels: {
+            ...next.channels,
+            zalo: {
+              ...next.channels?.zalo,
+              enabled: true,
+              ...(input.useEnv
+                ? {}
+                : input.tokenFile
+                  ? { tokenFile: input.tokenFile }
+                  : input.token
+                    ? { botToken: input.token }
+                    : {}),
+            },
+          },
+        } as CoreConfig;
+      }
+      return {
+        ...next,
+        channels: {
+          ...next.channels,
+          zalo: {
+            ...next.channels?.zalo,
+            enabled: true,
+            accounts: {
+              ...(next.channels?.zalo?.accounts ?? {}),
+              [accountId]: {
+                ...(next.channels?.zalo?.accounts?.[accountId] ?? {}),
+                enabled: true,
+                ...(input.tokenFile
+                  ? { tokenFile: input.tokenFile }
+                  : input.token
+                    ? { botToken: input.token }
+                    : {}),
+              },
+            },
+          },
+        },
+      } as CoreConfig;
+    },
+  },
+  pairing: {
+    idLabel: "zaloUserId",
+    normalizeAllowEntry: (entry) => entry.replace(/^(zalo|zl):/i, ""),
+    notifyApproval: async ({ cfg, id }) => {
+      const account = resolveZaloAccount({ cfg: cfg as CoreConfig });
+      if (!account.token) throw new Error("Zalo token not configured");
+      await sendMessageZalo(id, PAIRING_APPROVED_MESSAGE, { token: account.token });
+    },
+  },
+  outbound: {
+    deliveryMode: "direct",
+    chunker: (text, limit) => {
+      if (!text) return [];
+      if (limit <= 0 || text.length <= limit) return [text];
+      const chunks: string[] = [];
+      let remaining = text;
+      while (remaining.length > limit) {
+        const window = remaining.slice(0, limit);
+        const lastNewline = window.lastIndexOf("\n");
+        const lastSpace = window.lastIndexOf(" ");
+        let breakIdx = lastNewline > 0 ? lastNewline : lastSpace;
+        if (breakIdx <= 0) breakIdx = limit;
+        const rawChunk = remaining.slice(0, breakIdx);
+        const chunk = rawChunk.trimEnd();
+        if (chunk.length > 0) chunks.push(chunk);
+        const brokeOnSeparator = breakIdx < remaining.length && /\s/.test(remaining[breakIdx]);
+        const nextStart = Math.min(remaining.length, breakIdx + (brokeOnSeparator ? 1 : 0));
+        remaining = remaining.slice(nextStart).trimStart();
+      }
+      if (remaining.length) chunks.push(remaining);
+      return chunks;
+    },
+    textChunkLimit: 2000,
+    resolveTarget: ({ to }) => {
+      const trimmed = to?.trim();
+      if (!trimmed) {
+        return {
+          ok: false,
+          error: new Error("Delivering to Zalo requires --to <chatId>"),
+        };
+      }
+      return { ok: true, to: trimmed };
+    },
+    sendText: async ({ to, text, accountId, cfg }) => {
+      const result = await sendMessageZalo(to, text, {
+        accountId: accountId ?? undefined,
+        cfg: cfg as CoreConfig,
+      });
+      return {
+        channel: "zalo",
+        ok: result.ok,
+        messageId: result.messageId ?? "",
+        error: result.error ? new Error(result.error) : undefined,
+      };
+    },
+    sendMedia: async ({ to, text, mediaUrl, accountId, cfg }) => {
+      const result = await sendMessageZalo(to, text, {
+        accountId: accountId ?? undefined,
+        mediaUrl,
+        cfg: cfg as CoreConfig,
+      });
+      return {
+        channel: "zalo",
+        ok: result.ok,
+        messageId: result.messageId ?? "",
+        error: result.error ? new Error(result.error) : undefined,
+      };
+    },
+  },
+  status: {
+    defaultRuntime: {
+      accountId: DEFAULT_ACCOUNT_ID,
+      running: false,
+      lastStartAt: null,
+      lastStopAt: null,
+      lastError: null,
+    },
+    collectStatusIssues: collectZaloStatusIssues,
+    buildChannelSummary: ({ snapshot }) => ({
+      configured: snapshot.configured ?? false,
+      tokenSource: snapshot.tokenSource ?? "none",
+      running: snapshot.running ?? false,
+      mode: snapshot.mode ?? null,
+      lastStartAt: snapshot.lastStartAt ?? null,
+      lastStopAt: snapshot.lastStopAt ?? null,
+      lastError: snapshot.lastError ?? null,
+      probe: snapshot.probe,
+      lastProbeAt: snapshot.lastProbeAt ?? null,
+    }),
+    probeAccount: async ({ account, timeoutMs }) =>
+      probeZalo(account.token, timeoutMs, resolveZaloProxyFetch(account.config.proxy)),
+    buildAccountSnapshot: ({ account, runtime }) => {
+      const configured = Boolean(account.token?.trim());
+      return {
+        accountId: account.accountId,
+        name: account.name,
+        enabled: account.enabled,
+        configured,
+        tokenSource: account.tokenSource,
+        running: runtime?.running ?? false,
+        lastStartAt: runtime?.lastStartAt ?? null,
+        lastStopAt: runtime?.lastStopAt ?? null,
+        lastError: runtime?.lastError ?? null,
+        mode: account.config.webhookUrl ? "webhook" : "polling",
+        lastInboundAt: runtime?.lastInboundAt ?? null,
+        lastOutboundAt: runtime?.lastOutboundAt ?? null,
+        dmPolicy: account.config.dmPolicy ?? "pairing",
+      };
+    },
+  },
+  gateway: {
+    startAccount: async (ctx) => {
+      const account = ctx.account;
+      const token = account.token.trim();
+      let zaloBotLabel = "";
+      const fetcher = resolveZaloProxyFetch(account.config.proxy);
+      try {
+        const probe = await probeZalo(token, 2500, fetcher);
+        const name = probe.ok ? probe.bot?.name?.trim() : null;
+        if (name) zaloBotLabel = ` (${name})`;
+        ctx.setStatus({
+          accountId: account.accountId,
+          bot: probe.bot,
+        });
+      } catch {
+        // ignore probe errors
+      }
+      ctx.log?.info(`[${account.accountId}] starting provider${zaloBotLabel}`);
+      const { monitorZaloProvider } = await import("./monitor.js");
+      return monitorZaloProvider({
+        token,
+        account,
+        config: ctx.cfg as CoreConfig,
+        runtime: ctx.runtime,
+        abortSignal: ctx.abortSignal,
+        useWebhook: Boolean(account.config.webhookUrl),
+        webhookUrl: account.config.webhookUrl,
+        webhookSecret: account.config.webhookSecret,
+        webhookPath: account.config.webhookPath,
+        fetcher,
+        statusSink: (patch) => ctx.setStatus({ accountId: ctx.accountId, ...patch }),
+      });
+    },
+  },
+};
diff --git a/extensions/zalo/src/core-bridge.ts b/extensions/zalo/src/core-bridge.ts
new file mode 100644
index 000000000..46162412b
--- /dev/null
+++ b/extensions/zalo/src/core-bridge.ts
@@ -0,0 +1,171 @@
+import fs from "node:fs";
+import path from "node:path";
+import { fileURLToPath, pathToFileURL } from "node:url";
+
+export type CoreChannelDeps = {
+  chunkMarkdownText: (text: string, limit: number) => string[];
+  formatAgentEnvelope: (params: {
+    channel: string;
+    from: string;
+    timestamp?: number;
+    body: string;
+  }) => string;
+  dispatchReplyWithBufferedBlockDispatcher: (params: {
+    ctx: unknown;
+    cfg: unknown;
+    dispatcherOptions: {
+      deliver: (payload: unknown) => Promise<void>;
+      onError?: (err: unknown, info: { kind: string }) => void;
+    };
+  }) => Promise<void>;
+  resolveAgentRoute: (params: {
+    cfg: unknown;
+    channel: string;
+    accountId: string;
+    peer: { kind: "dm" | "group" | "channel"; id: string };
+  }) => { sessionKey: string; accountId: string };
+  buildPairingReply: (params: { channel: string; idLine: string; code: string }) => string;
+  readChannelAllowFromStore: (channel: string) => Promise<string[]>;
+  upsertChannelPairingRequest: (params: {
+    channel: string;
+    id: string;
+    meta?: { name?: string };
+  }) => Promise<{ code: string; created: boolean }>;
+  fetchRemoteMedia: (params: { url: string }) => Promise<{ buffer: Buffer; contentType?: string }>;
+  saveMediaBuffer: (
+    buffer: Buffer,
+    contentType: string | undefined,
+    type: "inbound" | "outbound",
+    maxBytes: number,
+  ) => Promise<{ path: string; contentType: string }>;
+  shouldLogVerbose: () => boolean;
+};
+
+let coreRootCache: string | null = null;
+let coreDepsPromise: Promise<CoreChannelDeps> | null = null;
+
+function findPackageRoot(startDir: string, name: string): string | null {
+  let dir = startDir;
+  for (;;) {
+    const pkgPath = path.join(dir, "package.json");
+    try {
+      if (fs.existsSync(pkgPath)) {
+        const raw = fs.readFileSync(pkgPath, "utf8");
+        const pkg = JSON.parse(raw) as { name?: string };
+        if (pkg.name === name) return dir;
+      }
+    } catch {
+      // ignore parse errors
+    }
+    const parent = path.dirname(dir);
+    if (parent === dir) return null;
+    dir = parent;
+  }
+}
+
+function resolveClawdbotRoot(): string {
+  if (coreRootCache) return coreRootCache;
+  const override = process.env.CLAWDBOT_ROOT?.trim();
+  if (override) {
+    coreRootCache = override;
+    return override;
+  }
+
+  const candidates = new Set<string>();
+  if (process.argv[1]) {
+    candidates.add(path.dirname(process.argv[1]));
+  }
+  candidates.add(process.cwd());
+  try {
+    const urlPath = fileURLToPath(import.meta.url);
+    candidates.add(path.dirname(urlPath));
+  } catch {
+    // ignore
+  }
+
+  for (const start of candidates) {
+    const found = findPackageRoot(start, "clawdbot");
+    if (found) {
+      coreRootCache = found;
+      return found;
+    }
+  }
+
+  throw new Error(
+    "Unable to resolve Clawdbot root. Set CLAWDBOT_ROOT to the package root.",
+  );
+}
+
+async function importCoreModule<T>(relativePath: string): Promise<T> {
+  const root = resolveClawdbotRoot();
+  const distPath = path.join(root, "dist", relativePath);
+  if (!fs.existsSync(distPath)) {
+    throw new Error(
+      `Missing core module at ${distPath}. Run \`pnpm build\` or install the official package.`,
+    );
+  }
+  return (await import(pathToFileURL(distPath).href)) as T;
+}
+
+export async function loadCoreChannelDeps(): Promise<CoreChannelDeps> {
+  if (coreDepsPromise) return coreDepsPromise;
+
+  coreDepsPromise = (async () => {
+    const [
+      chunk,
+      envelope,
+      dispatcher,
+      routing,
+      pairingMessages,
+      pairingStore,
+      mediaFetch,
+      mediaStore,
+      globals,
+    ] = await Promise.all([
+      importCoreModule<{ chunkMarkdownText: CoreChannelDeps["chunkMarkdownText"] }>(
+        "auto-reply/chunk.js",
+      ),
+      importCoreModule<{ formatAgentEnvelope: CoreChannelDeps["formatAgentEnvelope"] }>(
+        "auto-reply/envelope.js",
+      ),
+      importCoreModule<{
+        dispatchReplyWithBufferedBlockDispatcher: CoreChannelDeps["dispatchReplyWithBufferedBlockDispatcher"];
+      }>("auto-reply/reply/provider-dispatcher.js"),
+      importCoreModule<{ resolveAgentRoute: CoreChannelDeps["resolveAgentRoute"] }>(
+        "routing/resolve-route.js",
+      ),
+      importCoreModule<{ buildPairingReply: CoreChannelDeps["buildPairingReply"] }>(
+        "pairing/pairing-messages.js",
+      ),
+      importCoreModule<{
+        readChannelAllowFromStore: CoreChannelDeps["readChannelAllowFromStore"];
+        upsertChannelPairingRequest: CoreChannelDeps["upsertChannelPairingRequest"];
+      }>("pairing/pairing-store.js"),
+      importCoreModule<{ fetchRemoteMedia: CoreChannelDeps["fetchRemoteMedia"] }>(
+        "media/fetch.js",
+      ),
+      importCoreModule<{ saveMediaBuffer: CoreChannelDeps["saveMediaBuffer"] }>(
+        "media/store.js",
+      ),
+      importCoreModule<{ shouldLogVerbose: CoreChannelDeps["shouldLogVerbose"] }>(
+        "globals.js",
+      ),
+    ]);
+
+    return {
+      chunkMarkdownText: chunk.chunkMarkdownText,
+      formatAgentEnvelope: envelope.formatAgentEnvelope,
+      dispatchReplyWithBufferedBlockDispatcher:
+        dispatcher.dispatchReplyWithBufferedBlockDispatcher,
+      resolveAgentRoute: routing.resolveAgentRoute,
+      buildPairingReply: pairingMessages.buildPairingReply,
+      readChannelAllowFromStore: pairingStore.readChannelAllowFromStore,
+      upsertChannelPairingRequest: pairingStore.upsertChannelPairingRequest,
+      fetchRemoteMedia: mediaFetch.fetchRemoteMedia,
+      saveMediaBuffer: mediaStore.saveMediaBuffer,
+      shouldLogVerbose: globals.shouldLogVerbose,
+    };
+  })();
+
+  return coreDepsPromise;
+}
diff --git a/extensions/zalo/src/monitor.ts b/extensions/zalo/src/monitor.ts
new file mode 100644
index 000000000..6770cf53b
--- /dev/null
+++ b/extensions/zalo/src/monitor.ts
@@ -0,0 +1,679 @@
+import type { IncomingMessage, ServerResponse } from "node:http";
+
+import type { ResolvedZaloAccount } from "./accounts.js";
+import {
+  ZaloApiError,
+  deleteWebhook,
+  getUpdates,
+  sendMessage,
+  sendPhoto,
+  setWebhook,
+  type ZaloFetch,
+  type ZaloMessage,
+  type ZaloUpdate,
+} from "./api.js";
+import { loadCoreChannelDeps } from "./core-bridge.js";
+import { resolveZaloProxyFetch } from "./proxy.js";
+import type { CoreConfig } from "./types.js";
+
+export type ZaloRuntimeEnv = {
+  log?: (message: string) => void;
+  error?: (message: string) => void;
+};
+
+export type ZaloMonitorOptions = {
+  token: string;
+  account: ResolvedZaloAccount;
+  config: CoreConfig;
+  runtime: ZaloRuntimeEnv;
+  abortSignal: AbortSignal;
+  useWebhook?: boolean;
+  webhookUrl?: string;
+  webhookSecret?: string;
+  webhookPath?: string;
+  fetcher?: ZaloFetch;
+  statusSink?: (patch: { lastInboundAt?: number; lastOutboundAt?: number }) => void;
+};
+
+export type ZaloMonitorResult = {
+  stop: () => void;
+};
+
+const ZALO_TEXT_LIMIT = 2000;
+const DEFAULT_MEDIA_MAX_MB = 5;
+
+function logVerbose(deps: Awaited<ReturnType<typeof loadCoreChannelDeps>>, message: string): void {
+  if (deps.shouldLogVerbose()) {
+    console.log(`[zalo] ${message}`);
+  }
+}
+
+function isSenderAllowed(senderId: string, allowFrom: string[]): boolean {
+  if (allowFrom.includes("*")) return true;
+  const normalizedSenderId = senderId.toLowerCase();
+  return allowFrom.some((entry) => {
+    const normalized = entry.toLowerCase().replace(/^(zalo|zl):/i, "");
+    return normalized === normalizedSenderId;
+  });
+}
+
+async function readJsonBody(req: IncomingMessage, maxBytes: number) {
+  const chunks: Buffer[] = [];
+  let total = 0;
+  return await new Promise<{ ok: boolean; value?: unknown; error?: string }>((resolve) => {
+    req.on("data", (chunk: Buffer) => {
+      total += chunk.length;
+      if (total > maxBytes) {
+        resolve({ ok: false, error: "payload too large" });
+        req.destroy();
+        return;
+      }
+      chunks.push(chunk);
+    });
+    req.on("end", () => {
+      try {
+        const raw = Buffer.concat(chunks).toString("utf8");
+        if (!raw.trim()) {
+          resolve({ ok: false, error: "empty payload" });
+          return;
+        }
+        resolve({ ok: true, value: JSON.parse(raw) as unknown });
+      } catch (err) {
+        resolve({ ok: false, error: err instanceof Error ? err.message : String(err) });
+      }
+    });
+    req.on("error", (err) => {
+      resolve({ ok: false, error: err instanceof Error ? err.message : String(err) });
+    });
+  });
+}
+
+type WebhookTarget = {
+  token: string;
+  account: ResolvedZaloAccount;
+  config: CoreConfig;
+  runtime: ZaloRuntimeEnv;
+  deps: Awaited<ReturnType<typeof loadCoreChannelDeps>>;
+  secret: string;
+  path: string;
+  mediaMaxMb: number;
+  statusSink?: (patch: { lastInboundAt?: number; lastOutboundAt?: number }) => void;
+  fetcher?: ZaloFetch;
+};
+
+const webhookTargets = new Map<string, WebhookTarget[]>();
+
+function normalizeWebhookPath(raw: string): string {
+  const trimmed = raw.trim();
+  if (!trimmed) return "/";
+  const withSlash = trimmed.startsWith("/") ? trimmed : `/${trimmed}`;
+  if (withSlash.length > 1 && withSlash.endsWith("/")) {
+    return withSlash.slice(0, -1);
+  }
+  return withSlash;
+}
+
+function resolveWebhookPath(webhookPath?: string, webhookUrl?: string): string | null {
+  const trimmedPath = webhookPath?.trim();
+  if (trimmedPath) return normalizeWebhookPath(trimmedPath);
+  if (webhookUrl?.trim()) {
+    try {
+      const parsed = new URL(webhookUrl);
+      return normalizeWebhookPath(parsed.pathname || "/");
+    } catch {
+      return null;
+    }
+  }
+  return null;
+}
+
+export function registerZaloWebhookTarget(target: WebhookTarget): () => void {
+  const key = normalizeWebhookPath(target.path);
+  const normalizedTarget = { ...target, path: key };
+  const existing = webhookTargets.get(key) ?? [];
+  const next = [...existing, normalizedTarget];
+  webhookTargets.set(key, next);
+  return () => {
+    const updated = (webhookTargets.get(key) ?? []).filter(
+      (entry) => entry !== normalizedTarget,
+    );
+    if (updated.length > 0) {
+      webhookTargets.set(key, updated);
+    } else {
+      webhookTargets.delete(key);
+    }
+  };
+}
+
+export async function handleZaloWebhookRequest(
+  req: IncomingMessage,
+  res: ServerResponse,
+): Promise<boolean> {
+  const url = new URL(req.url ?? "/", "http://localhost");
+  const path = normalizeWebhookPath(url.pathname);
+  const targets = webhookTargets.get(path);
+  if (!targets || targets.length === 0) return false;
+
+  if (req.method !== "POST") {
+    res.statusCode = 405;
+    res.setHeader("Allow", "POST");
+    res.end("Method Not Allowed");
+    return true;
+  }
+
+  const headerToken = String(req.headers["x-bot-api-secret-token"] ?? "");
+  const target = targets.find((entry) => entry.secret === headerToken);
+  if (!target) {
+    res.statusCode = 401;
+    res.end("unauthorized");
+    return true;
+  }
+
+  const body = await readJsonBody(req, 1024 * 1024);
+  if (!body.ok) {
+    res.statusCode = body.error === "payload too large" ? 413 : 400;
+    res.end(body.error ?? "invalid payload");
+    return true;
+  }
+
+  const payload = body.value as { ok?: boolean; result?: ZaloUpdate };
+  if (!payload?.ok || !payload.result) {
+    res.statusCode = 400;
+    res.end("invalid payload");
+    return true;
+  }
+
+  target.statusSink?.({ lastInboundAt: Date.now() });
+  processUpdate(
+    payload.result,
+    target.token,
+    target.account,
+    target.config,
+    target.runtime,
+    target.deps,
+    target.mediaMaxMb,
+    target.statusSink,
+    target.fetcher,
+  ).catch((err) => {
+    target.runtime.error?.(`[${target.account.accountId}] Zalo webhook failed: ${String(err)}`);
+  });
+
+  res.statusCode = 200;
+  res.end("ok");
+  return true;
+}
+
+function startPollingLoop(params: {
+  token: string;
+  account: ResolvedZaloAccount;
+  config: CoreConfig;
+  runtime: ZaloRuntimeEnv;
+  deps: Awaited<ReturnType<typeof loadCoreChannelDeps>>;
+  abortSignal: AbortSignal;
+  isStopped: () => boolean;
+  mediaMaxMb: number;
+  statusSink?: (patch: { lastInboundAt?: number; lastOutboundAt?: number }) => void;
+  fetcher?: ZaloFetch;
+}) {
+  const {
+    token,
+    account,
+    config,
+    runtime,
+    deps,
+    abortSignal,
+    isStopped,
+    mediaMaxMb,
+    statusSink,
+    fetcher,
+  } = params;
+  const pollTimeout = 30;
+
+  const poll = async () => {
+    if (isStopped() || abortSignal.aborted) return;
+
+    try {
+      const response = await getUpdates(token, { timeout: pollTimeout }, fetcher);
+      if (response.ok && response.result) {
+        statusSink?.({ lastInboundAt: Date.now() });
+        await processUpdate(
+          response.result,
+          token,
+          account,
+          config,
+          runtime,
+          deps,
+          mediaMaxMb,
+          statusSink,
+          fetcher,
+        );
+      }
+    } catch (err) {
+      if (err instanceof ZaloApiError && err.isPollingTimeout) {
+        // no updates
+      } else if (!isStopped() && !abortSignal.aborted) {
+        console.error(`[${account.accountId}] Zalo polling error:`, err);
+        await new Promise((resolve) => setTimeout(resolve, 5000));
+      }
+    }
+
+    if (!isStopped() && !abortSignal.aborted) {
+      setImmediate(poll);
+    }
+  };
+
+  void poll();
+}
+
+async function processUpdate(
+  update: ZaloUpdate,
+  token: string,
+  account: ResolvedZaloAccount,
+  config: CoreConfig,
+  runtime: ZaloRuntimeEnv,
+  deps: Awaited<ReturnType<typeof loadCoreChannelDeps>>,
+  mediaMaxMb: number,
+  statusSink?: (patch: { lastInboundAt?: number; lastOutboundAt?: number }) => void,
+  fetcher?: ZaloFetch,
+): Promise<void> {
+  const { event_name, message } = update;
+  if (!message) return;
+
+  switch (event_name) {
+    case "message.text.received":
+      await handleTextMessage(
+        message,
+        token,
+        account,
+        config,
+        runtime,
+        deps,
+        statusSink,
+        fetcher,
+      );
+      break;
+    case "message.image.received":
+      await handleImageMessage(
+        message,
+        token,
+        account,
+        config,
+        runtime,
+        deps,
+        mediaMaxMb,
+        statusSink,
+        fetcher,
+      );
+      break;
+    case "message.sticker.received":
+      console.log(`[${account.accountId}] Received sticker from ${message.from.id}`);
+      break;
+    case "message.unsupported.received":
+      console.log(
+        `[${account.accountId}] Received unsupported message type from ${message.from.id}`,
+      );
+      break;
+  }
+}
+
+async function handleTextMessage(
+  message: ZaloMessage,
+  token: string,
+  account: ResolvedZaloAccount,
+  config: CoreConfig,
+  runtime: ZaloRuntimeEnv,
+  deps: Awaited<ReturnType<typeof loadCoreChannelDeps>>,
+  statusSink?: (patch: { lastInboundAt?: number; lastOutboundAt?: number }) => void,
+  fetcher?: ZaloFetch,
+): Promise<void> {
+  const { text } = message;
+  if (!text?.trim()) return;
+
+  await processMessageWithPipeline({
+    message,
+    token,
+    account,
+    config,
+    runtime,
+    deps,
+    text,
+    mediaPath: undefined,
+    mediaType: undefined,
+    statusSink,
+    fetcher,
+  });
+}
+
+async function handleImageMessage(
+  message: ZaloMessage,
+  token: string,
+  account: ResolvedZaloAccount,
+  config: CoreConfig,
+  runtime: ZaloRuntimeEnv,
+  deps: Awaited<ReturnType<typeof loadCoreChannelDeps>>,
+  mediaMaxMb: number,
+  statusSink?: (patch: { lastInboundAt?: number; lastOutboundAt?: number }) => void,
+  fetcher?: ZaloFetch,
+): Promise<void> {
+  const { photo, caption } = message;
+
+  let mediaPath: string | undefined;
+  let mediaType: string | undefined;
+
+  if (photo) {
+    try {
+      const maxBytes = mediaMaxMb * 1024 * 1024;
+      const fetched = await deps.fetchRemoteMedia({ url: photo });
+      const saved = await deps.saveMediaBuffer(
+        fetched.buffer,
+        fetched.contentType,
+        "inbound",
+        maxBytes,
+      );
+      mediaPath = saved.path;
+      mediaType = saved.contentType;
+    } catch (err) {
+      console.error(`[${account.accountId}] Failed to download Zalo image:`, err);
+    }
+  }
+
+  await processMessageWithPipeline({
+    message,
+    token,
+    account,
+    config,
+    runtime,
+    deps,
+    text: caption,
+    mediaPath,
+    mediaType,
+    statusSink,
+    fetcher,
+  });
+}
+
+async function processMessageWithPipeline(params: {
+  message: ZaloMessage;
+  token: string;
+  account: ResolvedZaloAccount;
+  config: CoreConfig;
+  runtime: ZaloRuntimeEnv;
+  deps: Awaited<ReturnType<typeof loadCoreChannelDeps>>;
+  text?: string;
+  mediaPath?: string;
+  mediaType?: string;
+  statusSink?: (patch: { lastInboundAt?: number; lastOutboundAt?: number }) => void;
+  fetcher?: ZaloFetch;
+}): Promise<void> {
+  const {
+    message,
+    token,
+    account,
+    config,
+    runtime,
+    deps,
+    text,
+    mediaPath,
+    mediaType,
+    statusSink,
+    fetcher,
+  } = params;
+  const { from, chat, message_id, date } = message;
+
+  const isGroup = chat.chat_type === "GROUP";
+  const chatId = chat.id;
+  const senderId = from.id;
+  const senderName = from.name;
+
+  const dmPolicy = account.config.dmPolicy ?? "pairing";
+  const configAllowFrom = (account.config.allowFrom ?? []).map((v) => String(v));
+
+  if (!isGroup) {
+    if (dmPolicy === "disabled") {
+      logVerbose(deps, `Blocked zalo DM from ${senderId} (dmPolicy=disabled)`);
+      return;
+    }
+
+    if (dmPolicy !== "open") {
+      const storeAllowFrom = await deps.readChannelAllowFromStore("zalo").catch(() => []);
+      const effectiveAllowFrom = [...configAllowFrom, ...storeAllowFrom];
+      const allowed = isSenderAllowed(senderId, effectiveAllowFrom);
+
+      if (!allowed) {
+        if (dmPolicy === "pairing") {
+          const { code, created } = await deps.upsertChannelPairingRequest({
+            channel: "zalo",
+            id: senderId,
+            meta: { name: senderName ?? undefined },
+          });
+
+          if (created) {
+            logVerbose(deps, `zalo pairing request sender=${senderId}`);
+            try {
+              await sendMessage(
+                token,
+                {
+                  chat_id: chatId,
+                  text: deps.buildPairingReply({
+                    channel: "zalo",
+                    idLine: `Your Zalo user id: ${senderId}`,
+                    code,
+                  }),
+                },
+                fetcher,
+              );
+              statusSink?.({ lastOutboundAt: Date.now() });
+            } catch (err) {
+              logVerbose(deps, `zalo pairing reply failed for ${senderId}: ${String(err)}`);
+            }
+          }
+        } else {
+          logVerbose(deps, `Blocked unauthorized zalo sender ${senderId} (dmPolicy=${dmPolicy})`);
+        }
+        return;
+      }
+    }
+  }
+
+  const route = deps.resolveAgentRoute({
+    cfg: config,
+    channel: "zalo",
+    accountId: account.accountId,
+    peer: {
+      kind: isGroup ? "group" : "dm",
+      id: chatId,
+    },
+  });
+
+  const rawBody = text?.trim() || (mediaPath ? "<media:image>" : "");
+  const fromLabel = isGroup
+    ? `group:${chatId} from ${senderName || senderId}`
+    : senderName || `user:${senderId}`;
+  const body = deps.formatAgentEnvelope({
+    channel: "Zalo",
+    from: fromLabel,
+    timestamp: date ? date * 1000 : undefined,
+    body: rawBody,
+  });
+
+  const ctxPayload = {
+    Body: body,
+    RawBody: rawBody,
+    CommandBody: rawBody,
+    From: isGroup ? `group:${chatId}` : `zalo:${senderId}`,
+    To: `zalo:${chatId}`,
+    SessionKey: route.sessionKey,
+    AccountId: route.accountId,
+    ChatType: isGroup ? "group" : "direct",
+    SenderName: senderName || undefined,
+    SenderId: senderId,
+    Provider: "zalo",
+    Surface: "zalo",
+    MessageSid: message_id,
+    MediaPath: mediaPath,
+    MediaType: mediaType,
+    MediaUrl: mediaPath,
+    OriginatingChannel: "zalo",
+    OriginatingTo: `zalo:${chatId}`,
+  };
+
+  await deps.dispatchReplyWithBufferedBlockDispatcher({
+    ctx: ctxPayload,
+    cfg: config,
+    dispatcherOptions: {
+      deliver: async (payload) => {
+        await deliverZaloReply({
+          payload,
+          token,
+          chatId,
+          runtime,
+          deps,
+          statusSink,
+          fetcher,
+        });
+      },
+      onError: (err, info) => {
+        runtime.error?.(`[${account.accountId}] Zalo ${info.kind} reply failed: ${String(err)}`);
+      },
+    },
+  });
+}
+
+async function deliverZaloReply(params: {
+  payload: { text?: string; mediaUrls?: string[]; mediaUrl?: string };
+  token: string;
+  chatId: string;
+  runtime: ZaloRuntimeEnv;
+  deps: Awaited<ReturnType<typeof loadCoreChannelDeps>>;
+  statusSink?: (patch: { lastInboundAt?: number; lastOutboundAt?: number }) => void;
+  fetcher?: ZaloFetch;
+}): Promise<void> {
+  const { payload, token, chatId, runtime, deps, statusSink, fetcher } = params;
+
+  const mediaList = payload.mediaUrls?.length
+    ? payload.mediaUrls
+    : payload.mediaUrl
+      ? [payload.mediaUrl]
+      : [];
+
+  if (mediaList.length > 0) {
+    let first = true;
+    for (const mediaUrl of mediaList) {
+      const caption = first ? payload.text : undefined;
+      first = false;
+      try {
+        await sendPhoto(token, { chat_id: chatId, photo: mediaUrl, caption }, fetcher);
+        statusSink?.({ lastOutboundAt: Date.now() });
+      } catch (err) {
+        runtime.error?.(`Zalo photo send failed: ${String(err)}`);
+      }
+    }
+    return;
+  }
+
+  if (payload.text) {
+    const chunks = deps.chunkMarkdownText(payload.text, ZALO_TEXT_LIMIT);
+    for (const chunk of chunks) {
+      try {
+        await sendMessage(token, { chat_id: chatId, text: chunk }, fetcher);
+        statusSink?.({ lastOutboundAt: Date.now() });
+      } catch (err) {
+        runtime.error?.(`Zalo message send failed: ${String(err)}`);
+      }
+    }
+  }
+}
+
+export async function monitorZaloProvider(
+  options: ZaloMonitorOptions,
+): Promise<ZaloMonitorResult> {
+  const {
+    token,
+    account,
+    config,
+    runtime,
+    abortSignal,
+    useWebhook,
+    webhookUrl,
+    webhookSecret,
+    webhookPath,
+    statusSink,
+    fetcher: fetcherOverride,
+  } = options;
+
+  const deps = await loadCoreChannelDeps();
+  const effectiveMediaMaxMb = account.config.mediaMaxMb ?? DEFAULT_MEDIA_MAX_MB;
+  const fetcher = fetcherOverride ?? resolveZaloProxyFetch(account.config.proxy);
+
+  let stopped = false;
+  const stopHandlers: Array<() => void> = [];
+
+  const stop = () => {
+    stopped = true;
+    for (const handler of stopHandlers) {
+      handler();
+    }
+  };
+
+  if (useWebhook) {
+    if (!webhookUrl || !webhookSecret) {
+      throw new Error("Zalo webhookUrl and webhookSecret are required for webhook mode");
+    }
+    if (!webhookUrl.startsWith("https://")) {
+      throw new Error("Zalo webhook URL must use HTTPS");
+    }
+    if (webhookSecret.length < 8 || webhookSecret.length > 256) {
+      throw new Error("Zalo webhook secret must be 8-256 characters");
+    }
+
+    const path = resolveWebhookPath(webhookPath, webhookUrl);
+    if (!path) {
+      throw new Error("Zalo webhookPath could not be derived");
+    }
+
+    await setWebhook(token, { url: webhookUrl, secret_token: webhookSecret }, fetcher);
+
+    const unregister = registerZaloWebhookTarget({
+      token,
+      account,
+      config,
+      runtime,
+      deps,
+      path,
+      secret: webhookSecret,
+      statusSink: (patch) => statusSink?.(patch),
+      mediaMaxMb: effectiveMediaMaxMb,
+      fetcher,
+    });
+    stopHandlers.push(unregister);
+    abortSignal.addEventListener(
+      "abort",
+      () => {
+        void deleteWebhook(token, fetcher).catch(() => {});
+      },
+      { once: true },
+    );
+    return { stop };
+  }
+
+  try {
+    await deleteWebhook(token, fetcher);
+  } catch {
+    // ignore
+  }
+
+  startPollingLoop({
+    token,
+    account,
+    config,
+    runtime,
+    deps,
+    abortSignal,
+    isStopped: () => stopped,
+    mediaMaxMb: effectiveMediaMaxMb,
+    statusSink,
+    fetcher,
+  });
+
+  return { stop };
+}
diff --git a/extensions/zalo/src/onboarding.ts b/extensions/zalo/src/onboarding.ts
new file mode 100644
index 000000000..1f60a841b
--- /dev/null
+++ b/extensions/zalo/src/onboarding.ts
@@ -0,0 +1,384 @@
+import type { ChannelOnboardingAdapter, ChannelOnboardingDmPolicy } from "../../src/channels/plugins/onboarding-types.js";
+import type { WizardPrompter } from "../../src/wizard/prompts.js";
+
+import { addWildcardAllowFrom, promptAccountId } from "./shared/onboarding.js";
+import { DEFAULT_ACCOUNT_ID, normalizeAccountId } from "./shared/account-ids.js";
+import {
+  listZaloAccountIds,
+  resolveDefaultZaloAccountId,
+  resolveZaloAccount,
+} from "./accounts.js";
+import type { CoreConfig } from "./types.js";
+
+const channel = "zalo" as const;
+
+type UpdateMode = "polling" | "webhook";
+
+function setZaloDmPolicy(cfg: CoreConfig, dmPolicy: "pairing" | "allowlist" | "open" | "disabled") {
+  const allowFrom = dmPolicy === "open" ? addWildcardAllowFrom(cfg.channels?.zalo?.allowFrom) : undefined;
+  return {
+    ...cfg,
+    channels: {
+      ...cfg.channels,
+      zalo: {
+        ...cfg.channels?.zalo,
+        dmPolicy,
+        ...(allowFrom ? { allowFrom } : {}),
+      },
+    },
+  } as CoreConfig;
+}
+
+function setZaloUpdateMode(
+  cfg: CoreConfig,
+  accountId: string,
+  mode: UpdateMode,
+  webhookUrl?: string,
+  webhookSecret?: string,
+  webhookPath?: string,
+): CoreConfig {
+  const isDefault = accountId === DEFAULT_ACCOUNT_ID;
+  if (mode === "polling") {
+    if (isDefault) {
+      const {
+        webhookUrl: _url,
+        webhookSecret: _secret,
+        webhookPath: _path,
+        ...rest
+      } = cfg.channels?.zalo ?? {};
+      return {
+        ...cfg,
+        channels: {
+          ...cfg.channels,
+          zalo: rest,
+        },
+      } as CoreConfig;
+    }
+    const accounts = { ...(cfg.channels?.zalo?.accounts ?? {}) } as Record<
+      string,
+      Record<string, unknown>
+    >;
+    const existing = accounts[accountId] ?? {};
+    const {
+      webhookUrl: _url,
+      webhookSecret: _secret,
+      webhookPath: _path,
+      ...rest
+    } = existing;
+    accounts[accountId] = rest;
+    return {
+      ...cfg,
+      channels: {
+        ...cfg.channels,
+        zalo: {
+          ...cfg.channels?.zalo,
+          accounts,
+        },
+      },
+    } as CoreConfig;
+  }
+
+  if (isDefault) {
+    return {
+      ...cfg,
+      channels: {
+        ...cfg.channels,
+        zalo: {
+          ...cfg.channels?.zalo,
+          webhookUrl,
+          webhookSecret,
+          webhookPath,
+        },
+      },
+    } as CoreConfig;
+  }
+
+  const accounts = { ...(cfg.channels?.zalo?.accounts ?? {}) } as Record<
+    string,
+    Record<string, unknown>
+  >;
+  accounts[accountId] = {
+    ...(accounts[accountId] ?? {}),
+    webhookUrl,
+    webhookSecret,
+    webhookPath,
+  };
+  return {
+    ...cfg,
+    channels: {
+      ...cfg.channels,
+      zalo: {
+        ...cfg.channels?.zalo,
+        accounts,
+      },
+    },
+  } as CoreConfig;
+}
+
+async function noteZaloTokenHelp(prompter: WizardPrompter): Promise<void> {
+  await prompter.note(
+    [
+      "1) Open Zalo Bot Platform: https://bot.zaloplatforms.com",
+      "2) Create a bot and get the token",
+      "3) Token looks like 12345689:abc-xyz",
+      "Tip: you can also set ZALO_BOT_TOKEN in your env.",
+      "Docs: https://docs.clawd.bot/channels/zalo",
+    ].join("\n"),
+    "Zalo bot token",
+  );
+}
+
+async function promptZaloAllowFrom(params: {
+  cfg: CoreConfig;
+  prompter: WizardPrompter;
+  accountId: string;
+}): Promise<CoreConfig> {
+  const { cfg, prompter, accountId } = params;
+  const resolved = resolveZaloAccount({ cfg, accountId });
+  const existingAllowFrom = resolved.config.allowFrom ?? [];
+  const entry = await prompter.text({
+    message: "Zalo allowFrom (user id)",
+    placeholder: "123456789",
+    initialValue: existingAllowFrom[0] ? String(existingAllowFrom[0]) : undefined,
+    validate: (value) => {
+      const raw = String(value ?? "").trim();
+      if (!raw) return "Required";
+      if (!/^\d+$/.test(raw)) return "Use a numeric Zalo user id";
+      return undefined;
+    },
+  });
+  const normalized = String(entry).trim();
+  const merged = [
+    ...existingAllowFrom.map((item) => String(item).trim()).filter(Boolean),
+    normalized,
+  ];
+  const unique = [...new Set(merged)];
+
+  if (accountId === DEFAULT_ACCOUNT_ID) {
+    return {
+      ...cfg,
+      channels: {
+        ...cfg.channels,
+        zalo: {
+          ...cfg.channels?.zalo,
+          enabled: true,
+          dmPolicy: "allowlist",
+          allowFrom: unique,
+        },
+      },
+    } as CoreConfig;
+  }
+
+  return {
+    ...cfg,
+    channels: {
+      ...cfg.channels,
+      zalo: {
+        ...cfg.channels?.zalo,
+        enabled: true,
+        accounts: {
+          ...(cfg.channels?.zalo?.accounts ?? {}),
+          [accountId]: {
+            ...(cfg.channels?.zalo?.accounts?.[accountId] ?? {}),
+            enabled: cfg.channels?.zalo?.accounts?.[accountId]?.enabled ?? true,
+            dmPolicy: "allowlist",
+            allowFrom: unique,
+          },
+        },
+      },
+    },
+  } as CoreConfig;
+}
+
+const dmPolicy: ChannelOnboardingDmPolicy = {
+  label: "Zalo",
+  channel,
+  policyKey: "channels.zalo.dmPolicy",
+  allowFromKey: "channels.zalo.allowFrom",
+  getCurrent: (cfg) => (cfg.channels?.zalo?.dmPolicy ?? "pairing") as "pairing",
+  setPolicy: (cfg, policy) => setZaloDmPolicy(cfg as CoreConfig, policy),
+};
+
+export const zaloOnboardingAdapter: ChannelOnboardingAdapter = {
+  channel,
+  dmPolicy,
+  getStatus: async ({ cfg }) => {
+    const configured = listZaloAccountIds(cfg as CoreConfig).some((accountId) =>
+      Boolean(resolveZaloAccount({ cfg: cfg as CoreConfig, accountId }).token),
+    );
+    return {
+      channel,
+      configured,
+      statusLines: [`Zalo: ${configured ? "configured" : "needs token"}`],
+      selectionHint: configured ? "recommended · configured" : "recommended · newcomer-friendly",
+      quickstartScore: configured ? 1 : 10,
+    };
+  },
+  configure: async ({ cfg, prompter, accountOverrides, shouldPromptAccountIds, forceAllowFrom }) => {
+    const zaloOverride = accountOverrides.zalo?.trim();
+    const defaultZaloAccountId = resolveDefaultZaloAccountId(cfg as CoreConfig);
+    let zaloAccountId = zaloOverride
+      ? normalizeAccountId(zaloOverride)
+      : defaultZaloAccountId;
+    if (shouldPromptAccountIds && !zaloOverride) {
+      zaloAccountId = await promptAccountId({
+        cfg: cfg as CoreConfig,
+        prompter,
+        label: "Zalo",
+        currentId: zaloAccountId,
+        listAccountIds: listZaloAccountIds,
+        defaultAccountId: defaultZaloAccountId,
+      });
+    }
+
+    let next = cfg as CoreConfig;
+    const resolvedAccount = resolveZaloAccount({ cfg: next, accountId: zaloAccountId });
+    const accountConfigured = Boolean(resolvedAccount.token);
+    const allowEnv = zaloAccountId === DEFAULT_ACCOUNT_ID;
+    const canUseEnv = allowEnv && Boolean(process.env.ZALO_BOT_TOKEN?.trim());
+    const hasConfigToken = Boolean(
+      resolvedAccount.config.botToken || resolvedAccount.config.tokenFile,
+    );
+
+    let token: string | null = null;
+    if (!accountConfigured) {
+      await noteZaloTokenHelp(prompter);
+    }
+    if (canUseEnv && !resolvedAccount.config.botToken) {
+      const keepEnv = await prompter.confirm({
+        message: "ZALO_BOT_TOKEN detected. Use env var?",
+        initialValue: true,
+      });
+      if (keepEnv) {
+        next = {
+          ...next,
+          channels: {
+            ...next.channels,
+            zalo: {
+              ...next.channels?.zalo,
+              enabled: true,
+            },
+          },
+        } as CoreConfig;
+      } else {
+        token = String(
+          await prompter.text({
+            message: "Enter Zalo bot token",
+            validate: (value) => (value?.trim() ? undefined : "Required"),
+          }),
+        ).trim();
+      }
+    } else if (hasConfigToken) {
+      const keep = await prompter.confirm({
+        message: "Zalo token already configured. Keep it?",
+        initialValue: true,
+      });
+      if (!keep) {
+        token = String(
+          await prompter.text({
+            message: "Enter Zalo bot token",
+            validate: (value) => (value?.trim() ? undefined : "Required"),
+          }),
+        ).trim();
+      }
+    } else {
+      token = String(
+        await prompter.text({
+          message: "Enter Zalo bot token",
+          validate: (value) => (value?.trim() ? undefined : "Required"),
+        }),
+      ).trim();
+    }
+
+    if (token) {
+      if (zaloAccountId === DEFAULT_ACCOUNT_ID) {
+        next = {
+          ...next,
+          channels: {
+            ...next.channels,
+            zalo: {
+              ...next.channels?.zalo,
+              enabled: true,
+              botToken: token,
+            },
+          },
+        } as CoreConfig;
+      } else {
+        next = {
+          ...next,
+          channels: {
+            ...next.channels,
+            zalo: {
+              ...next.channels?.zalo,
+              enabled: true,
+              accounts: {
+                ...(next.channels?.zalo?.accounts ?? {}),
+                [zaloAccountId]: {
+                  ...(next.channels?.zalo?.accounts?.[zaloAccountId] ?? {}),
+                  enabled: true,
+                  botToken: token,
+                },
+              },
+            },
+          },
+        } as CoreConfig;
+      }
+    }
+
+    const wantsWebhook = await prompter.confirm({
+      message: "Use webhook mode for Zalo?",
+      initialValue: false,
+    });
+    if (wantsWebhook) {
+      const webhookUrl = String(
+        await prompter.text({
+          message: "Webhook URL (https://...) ",
+          validate: (value) => (value?.trim()?.startsWith("https://") ? undefined : "HTTPS URL required"),
+        }),
+      ).trim();
+      const defaultPath = (() => {
+        try {
+          return new URL(webhookUrl).pathname || "/zalo-webhook";
+        } catch {
+          return "/zalo-webhook";
+        }
+      })();
+      const webhookSecret = String(
+        await prompter.text({
+          message: "Webhook secret (8-256 chars)",
+          validate: (value) => {
+            const raw = String(value ?? "");
+            if (raw.length < 8 || raw.length > 256) return "8-256 chars";
+            return undefined;
+          },
+        }),
+      ).trim();
+      const webhookPath = String(
+        await prompter.text({
+          message: "Webhook path (optional)",
+          initialValue: defaultPath,
+        }),
+      ).trim();
+      next = setZaloUpdateMode(
+        next,
+        zaloAccountId,
+        "webhook",
+        webhookUrl,
+        webhookSecret,
+        webhookPath || undefined,
+      );
+    } else {
+      next = setZaloUpdateMode(next, zaloAccountId, "polling");
+    }
+
+    if (forceAllowFrom) {
+      next = await promptZaloAllowFrom({
+        cfg: next,
+        prompter,
+        accountId: zaloAccountId,
+      });
+    }
+
+    return { cfg: next, accountId: zaloAccountId };
+  },
+};
diff --git a/extensions/zalo/src/probe.ts b/extensions/zalo/src/probe.ts
new file mode 100644
index 000000000..ebdb37a34
--- /dev/null
+++ b/extensions/zalo/src/probe.ts
@@ -0,0 +1,46 @@
+import { getMe, ZaloApiError, type ZaloBotInfo, type ZaloFetch } from "./api.js";
+
+export type ZaloProbeResult = {
+  ok: boolean;
+  bot?: ZaloBotInfo;
+  error?: string;
+  elapsedMs: number;
+};
+
+export async function probeZalo(
+  token: string,
+  timeoutMs = 5000,
+  fetcher?: ZaloFetch,
+): Promise<ZaloProbeResult> {
+  if (!token?.trim()) {
+    return { ok: false, error: "No token provided", elapsedMs: 0 };
+  }
+
+  const startTime = Date.now();
+
+  try {
+    const response = await getMe(token.trim(), timeoutMs, fetcher);
+    const elapsedMs = Date.now() - startTime;
+
+    if (response.ok && response.result) {
+      return { ok: true, bot: response.result, elapsedMs };
+    }
+
+    return { ok: false, error: "Invalid response from Zalo API", elapsedMs };
+  } catch (err) {
+    const elapsedMs = Date.now() - startTime;
+
+    if (err instanceof ZaloApiError) {
+      return { ok: false, error: err.description ?? err.message, elapsedMs };
+    }
+
+    if (err instanceof Error) {
+      if (err.name === "AbortError") {
+        return { ok: false, error: `Request timed out after ${timeoutMs}ms`, elapsedMs };
+      }
+      return { ok: false, error: err.message, elapsedMs };
+    }
+
+    return { ok: false, error: String(err), elapsedMs };
+  }
+}
diff --git a/extensions/zalo/src/proxy.ts b/extensions/zalo/src/proxy.ts
new file mode 100644
index 000000000..65d6e04af
--- /dev/null
+++ b/extensions/zalo/src/proxy.ts
@@ -0,0 +1,18 @@
+import { ProxyAgent, fetch as undiciFetch } from "undici";
+import type { Dispatcher } from "undici";
+
+import type { ZaloFetch } from "./api.js";
+
+const proxyCache = new Map<string, ZaloFetch>();
+
+export function resolveZaloProxyFetch(proxyUrl?: string | null): ZaloFetch | undefined {
+  const trimmed = proxyUrl?.trim();
+  if (!trimmed) return undefined;
+  const cached = proxyCache.get(trimmed);
+  if (cached) return cached;
+  const agent = new ProxyAgent(trimmed);
+  const fetcher: ZaloFetch = (input, init) =>
+    undiciFetch(input, { ...(init ?? {}), dispatcher: agent as Dispatcher });
+  proxyCache.set(trimmed, fetcher);
+  return fetcher;
+}
diff --git a/extensions/zalo/src/send.ts b/extensions/zalo/src/send.ts
new file mode 100644
index 000000000..202520cc8
--- /dev/null
+++ b/extensions/zalo/src/send.ts
@@ -0,0 +1,116 @@
+import type { CoreConfig } from "./types.js";
+import type { ZaloFetch } from "./api.js";
+import { sendMessage, sendPhoto } from "./api.js";
+import { resolveZaloAccount } from "./accounts.js";
+import { resolveZaloProxyFetch } from "./proxy.js";
+import { resolveZaloToken } from "./token.js";
+
+export type ZaloSendOptions = {
+  token?: string;
+  accountId?: string;
+  cfg?: CoreConfig;
+  mediaUrl?: string;
+  caption?: string;
+  verbose?: boolean;
+  proxy?: string;
+};
+
+export type ZaloSendResult = {
+  ok: boolean;
+  messageId?: string;
+  error?: string;
+};
+
+function resolveSendContext(options: ZaloSendOptions): {
+  token: string;
+  fetcher?: ZaloFetch;
+} {
+  if (options.cfg) {
+    const account = resolveZaloAccount({
+      cfg: options.cfg,
+      accountId: options.accountId,
+    });
+    const token = options.token || account.token;
+    const proxy = options.proxy ?? account.config.proxy;
+    return { token, fetcher: resolveZaloProxyFetch(proxy) };
+  }
+
+  const token = options.token ?? resolveZaloToken(undefined, options.accountId).token;
+  const proxy = options.proxy;
+  return { token: token || process.env.ZALO_BOT_TOKEN?.trim() || "", fetcher: resolveZaloProxyFetch(proxy) };
+}
+
+export async function sendMessageZalo(
+  chatId: string,
+  text: string,
+  options: ZaloSendOptions = {},
+): Promise<ZaloSendResult> {
+  const { token, fetcher } = resolveSendContext(options);
+
+  if (!token) {
+    return { ok: false, error: "No Zalo bot token configured" };
+  }
+
+  if (!chatId?.trim()) {
+    return { ok: false, error: "No chat_id provided" };
+  }
+
+  if (options.mediaUrl) {
+    return sendPhotoZalo(chatId, options.mediaUrl, {
+      ...options,
+      token,
+      caption: text || options.caption,
+    });
+  }
+
+  try {
+    const response = await sendMessage(token, {
+      chat_id: chatId.trim(),
+      text: text.slice(0, 2000),
+    }, fetcher);
+
+    if (response.ok && response.result) {
+      return { ok: true, messageId: response.result.message_id };
+    }
+
+    return { ok: false, error: "Failed to send message" };
+  } catch (err) {
+    return { ok: false, error: err instanceof Error ? err.message : String(err) };
+  }
+}
+
+export async function sendPhotoZalo(
+  chatId: string,
+  photoUrl: string,
+  options: ZaloSendOptions = {},
+): Promise<ZaloSendResult> {
+  const { token, fetcher } = resolveSendContext(options);
+
+  if (!token) {
+    return { ok: false, error: "No Zalo bot token configured" };
+  }
+
+  if (!chatId?.trim()) {
+    return { ok: false, error: "No chat_id provided" };
+  }
+
+  if (!photoUrl?.trim()) {
+    return { ok: false, error: "No photo URL provided" };
+  }
+
+  try {
+    const response = await sendPhoto(token, {
+      chat_id: chatId.trim(),
+      photo: photoUrl.trim(),
+      caption: options.caption?.slice(0, 2000),
+    }, fetcher);
+
+    if (response.ok && response.result) {
+      return { ok: true, messageId: response.result.message_id };
+    }
+
+    return { ok: false, error: "Failed to send photo" };
+  } catch (err) {
+    return { ok: false, error: err instanceof Error ? err.message : String(err) };
+  }
+}
diff --git a/extensions/zalo/src/shared/account-ids.ts b/extensions/zalo/src/shared/account-ids.ts
new file mode 100644
index 000000000..5edcd8376
--- /dev/null
+++ b/extensions/zalo/src/shared/account-ids.ts
@@ -0,0 +1,15 @@
+export const DEFAULT_ACCOUNT_ID = "default";
+
+export function normalizeAccountId(value: string | undefined | null): string {
+  const trimmed = (value ?? "").trim();
+  if (!trimmed) return DEFAULT_ACCOUNT_ID;
+  if (/^[a-z0-9][a-z0-9_-]{0,63}$/i.test(trimmed)) return trimmed;
+  return (
+    trimmed
+      .toLowerCase()
+      .replace(/[^a-z0-9_-]+/g, "-")
+      .replace(/^-+/, "")
+      .replace(/-+$/, "")
+      .slice(0, 64) || DEFAULT_ACCOUNT_ID
+  );
+}
diff --git a/extensions/zalo/src/shared/channel-config.ts b/extensions/zalo/src/shared/channel-config.ts
new file mode 100644
index 000000000..184b5cf12
--- /dev/null
+++ b/extensions/zalo/src/shared/channel-config.ts
@@ -0,0 +1,112 @@
+import { DEFAULT_ACCOUNT_ID } from "./account-ids.js";
+
+type ChannelSection = {
+  accounts?: Record<string, Record<string, unknown>>;
+  enabled?: boolean;
+};
+
+type ConfigWithChannels = {
+  channels?: Record<string, unknown>;
+};
+
+export function setAccountEnabledInConfigSection<T extends ConfigWithChannels>(params: {
+  cfg: T;
+  sectionKey: string;
+  accountId: string;
+  enabled: boolean;
+  allowTopLevel?: boolean;
+}): T {
+  const accountKey = params.accountId || DEFAULT_ACCOUNT_ID;
+  const channels = params.cfg.channels;
+  const base = (channels?.[params.sectionKey] as ChannelSection | undefined) ?? undefined;
+  const hasAccounts = Boolean(base?.accounts);
+  if (params.allowTopLevel && accountKey === DEFAULT_ACCOUNT_ID && !hasAccounts) {
+    return {
+      ...params.cfg,
+      channels: {
+        ...channels,
+        [params.sectionKey]: {
+          ...base,
+          enabled: params.enabled,
+        },
+      },
+    } as T;
+  }
+
+  const baseAccounts = (base?.accounts ?? {}) as Record<string, Record<string, unknown>>;
+  const existing = baseAccounts[accountKey] ?? {};
+  return {
+    ...params.cfg,
+    channels: {
+      ...channels,
+      [params.sectionKey]: {
+        ...base,
+        accounts: {
+          ...baseAccounts,
+          [accountKey]: {
+            ...existing,
+            enabled: params.enabled,
+          },
+        },
+      },
+    },
+  } as T;
+}
+
+export function deleteAccountFromConfigSection<T extends ConfigWithChannels>(params: {
+  cfg: T;
+  sectionKey: string;
+  accountId: string;
+  clearBaseFields?: string[];
+}): T {
+  const accountKey = params.accountId || DEFAULT_ACCOUNT_ID;
+  const channels = params.cfg.channels as Record<string, unknown> | undefined;
+  const base = (channels?.[params.sectionKey] as ChannelSection | undefined) ?? undefined;
+  if (!base) return params.cfg;
+
+  const baseAccounts =
+    base.accounts && typeof base.accounts === "object" ? { ...base.accounts } : undefined;
+
+  if (accountKey !== DEFAULT_ACCOUNT_ID) {
+    const accounts = baseAccounts ? { ...baseAccounts } : {};
+    delete accounts[accountKey];
+    return {
+      ...params.cfg,
+      channels: {
+        ...channels,
+        [params.sectionKey]: {
+          ...base,
+          accounts: Object.keys(accounts).length ? accounts : undefined,
+        },
+      },
+    } as T;
+  }
+
+  if (baseAccounts && Object.keys(baseAccounts).length > 0) {
+    delete baseAccounts[accountKey];
+    const baseRecord = { ...(base as Record<string, unknown>) };
+    for (const field of params.clearBaseFields ?? []) {
+      if (field in baseRecord) baseRecord[field] = undefined;
+    }
+    return {
+      ...params.cfg,
+      channels: {
+        ...channels,
+        [params.sectionKey]: {
+          ...baseRecord,
+          accounts: Object.keys(baseAccounts).length ? baseAccounts : undefined,
+        },
+      },
+    } as T;
+  }
+
+  const nextChannels = { ...channels } as Record<string, unknown>;
+  delete nextChannels[params.sectionKey];
+  const nextCfg = { ...params.cfg } as T;
+  if (Object.keys(nextChannels).length > 0) {
+    nextCfg.channels = nextChannels as T["channels"];
+  } else {
+    delete nextCfg.channels;
+  }
+  return nextCfg;
+}
diff --git a/extensions/zalo/src/shared/channel-setup.ts b/extensions/zalo/src/shared/channel-setup.ts
new file mode 100644
index 000000000..b164ed18f
--- /dev/null
+++ b/extensions/zalo/src/shared/channel-setup.ts
@@ -0,0 +1,114 @@
+import { DEFAULT_ACCOUNT_ID, normalizeAccountId } from "./account-ids.js";
+
+type ConfigWithChannels = {
+  channels?: Record<string, unknown>;
+};
+
+type ChannelSectionBase = {
+  name?: string;
+  accounts?: Record<string, Record<string, unknown>>;
+};
+
+function channelHasAccounts(cfg: ConfigWithChannels, channelKey: string): boolean {
+  const channels = cfg.channels as Record<string, unknown> | undefined;
+  const base = channels?.[channelKey] as ChannelSectionBase | undefined;
+  return Boolean(base?.accounts && Object.keys(base.accounts).length > 0);
+}
+
+function shouldStoreNameInAccounts(params: {
+  cfg: ConfigWithChannels;
+  channelKey: string;
+  accountId: string;
+  alwaysUseAccounts?: boolean;
+}): boolean {
+  if (params.alwaysUseAccounts) return true;
+  if (params.accountId !== DEFAULT_ACCOUNT_ID) return true;
+  return channelHasAccounts(params.cfg, params.channelKey);
+}
+
+export function applyAccountNameToChannelSection<T extends ConfigWithChannels>(params: {
+  cfg: T;
+  channelKey: string;
+  accountId: string;
+  name?: string;
+  alwaysUseAccounts?: boolean;
+}): T {
+  const trimmed = params.name?.trim();
+  if (!trimmed) return params.cfg;
+  const accountId = normalizeAccountId(params.accountId);
+  const channels = params.cfg.channels as Record<string, unknown> | undefined;
+  const baseConfig = channels?.[params.channelKey];
+  const base =
+    typeof baseConfig === "object" && baseConfig ? (baseConfig as ChannelSectionBase) : undefined;
+  const useAccounts = shouldStoreNameInAccounts({
+    cfg: params.cfg,
+    channelKey: params.channelKey,
+    accountId,
+    alwaysUseAccounts: params.alwaysUseAccounts,
+  });
+  if (!useAccounts && accountId === DEFAULT_ACCOUNT_ID) {
+    const safeBase = base ?? {};
+    return {
+      ...params.cfg,
+      channels: {
+        ...channels,
+        [params.channelKey]: {
+          ...safeBase,
+          name: trimmed,
+        },
+      },
+    } as T;
+  }
+  const baseAccounts: Record<string, Record<string, unknown>> = base?.accounts ?? {};
+  const existingAccount = baseAccounts[accountId] ?? {};
+  const baseWithoutName =
+    accountId === DEFAULT_ACCOUNT_ID
+      ? (({ name: _ignored, ...rest }) => rest)(base ?? {})
+      : (base ?? {});
+  return {
+    ...params.cfg,
+    channels: {
+      ...channels,
+      [params.channelKey]: {
+        ...baseWithoutName,
+        accounts: {
+          ...baseAccounts,
+          [accountId]: {
+            ...existingAccount,
+            name: trimmed,
+          },
+        },
+      },
+    },
+  } as T;
+}
+
+export function migrateBaseNameToDefaultAccount<T extends ConfigWithChannels>(params: {
+  cfg: T;
+  channelKey: string;
+  alwaysUseAccounts?: boolean;
+}): T {
+  if (params.alwaysUseAccounts) return params.cfg;
+  const channels = params.cfg.channels as Record<string, unknown> | undefined;
+  const base = channels?.[params.channelKey] as ChannelSectionBase | undefined;
+  const baseName = base?.name?.trim();
+  if (!baseName) return params.cfg;
+  const accounts: Record<string, Record<string, unknown>> = {
+    ...base?.accounts,
+  };
+  const defaultAccount = accounts[DEFAULT_ACCOUNT_ID] ?? {};
+  if (!defaultAccount.name) {
+    accounts[DEFAULT_ACCOUNT_ID] = { ...defaultAccount, name: baseName };
+  }
+  const { name: _ignored, ...rest } = base ?? {};
+  return {
+    ...params.cfg,
+    channels: {
+      ...channels,
+      [params.channelKey]: {
+        ...rest,
+        accounts,
+      },
+    },
+  } as T;
+}
diff --git a/extensions/zalo/src/shared/onboarding.ts b/extensions/zalo/src/shared/onboarding.ts
new file mode 100644
index 000000000..a998fb778
--- /dev/null
+++ b/extensions/zalo/src/shared/onboarding.ts
@@ -0,0 +1,53 @@
+import type { WizardPrompter } from "../../../src/wizard/prompts.js";
+
+import { DEFAULT_ACCOUNT_ID, normalizeAccountId } from "./account-ids.js";
+
+export type PromptAccountIdParams<TConfig> = {
+  cfg: TConfig;
+  prompter: WizardPrompter;
+  label: string;
+  currentId?: string;
+  listAccountIds: (cfg: TConfig) => string[];
+  defaultAccountId: string;
+};
+
+export async function promptAccountId<TConfig>(
+  params: PromptAccountIdParams<TConfig>,
+): Promise<string> {
+  const existingIds = params.listAccountIds(params.cfg);
+  const initial = params.currentId?.trim() || params.defaultAccountId || DEFAULT_ACCOUNT_ID;
+  const choice = (await params.prompter.select({
+    message: `${params.label} account`,
+    options: [
+      ...existingIds.map((id) => ({
+        value: id,
+        label: id === DEFAULT_ACCOUNT_ID ? "default (primary)" : id,
+      })),
+      { value: "__new__", label: "Add a new account" },
+    ],
+    initialValue: initial,
+  })) as string;
+
+  if (choice !== "__new__") return normalizeAccountId(choice);
+
+  const entered = await params.prompter.text({
+    message: `New ${params.label} account id`,
+    validate: (value) => (value?.trim() ? undefined : "Required"),
+  });
+  const normalized = normalizeAccountId(String(entered));
+  if (String(entered).trim() !== normalized) {
+    await params.prompter.note(
+      `Normalized account id to "${normalized}".`,
+      `${params.label} account`,
+    );
+  }
+  return normalized;
+}
+
+export function addWildcardAllowFrom(
+  allowFrom?: Array<string | number> | null,
+): Array<string | number> {
+  const next = (allowFrom ?? []).map((v) => String(v).trim()).filter(Boolean);
+  if (!next.includes("*")) next.push("*");
+  return next;
+}
diff --git a/extensions/zalo/src/shared/pairing.ts b/extensions/zalo/src/shared/pairing.ts
new file mode 100644
index 000000000..91e75fbab
--- /dev/null
+++ b/extensions/zalo/src/shared/pairing.ts
@@ -0,0 +1,6 @@
+export const PAIRING_APPROVED_MESSAGE =
+  "\u2705 Clawdbot access approved. Send a message to start chatting.";
+
+export function formatPairingApproveHint(channelId: string): string {
+  return `Approve via: clawdbot pairing list ${channelId} / clawdbot pairing approve ${channelId} <code>`;
+}
diff --git a/extensions/zalo/src/status-issues.ts b/extensions/zalo/src/status-issues.ts
new file mode 100644
index 000000000..c5ca219f3
--- /dev/null
+++ b/extensions/zalo/src/status-issues.ts
@@ -0,0 +1,50 @@
+import type { ChannelAccountSnapshot, ChannelStatusIssue } from "../../src/channels/plugins/types.js";
+
+type ZaloAccountStatus = {
+  accountId?: unknown;
+  enabled?: unknown;
+  configured?: unknown;
+  dmPolicy?: unknown;
+};
+
+const isRecord = (value: unknown): value is Record<string, unknown> =>
+  Boolean(value && typeof value === "object");
+
+const asString = (value: unknown): string | undefined =>
+  typeof value === "string" ? value : typeof value === "number" ? String(value) : undefined;
+
+function readZaloAccountStatus(value: ChannelAccountSnapshot): ZaloAccountStatus | null {
+  if (!isRecord(value)) return null;
+  return {
+    accountId: value.accountId,
+    enabled: value.enabled,
+    configured: value.configured,
+    dmPolicy: value.dmPolicy,
+  };
+}
+
+export function collectZaloStatusIssues(
+  accounts: ChannelAccountSnapshot[],
+): ChannelStatusIssue[] {
+  const issues: ChannelStatusIssue[] = [];
+  for (const entry of accounts) {
+    const account = readZaloAccountStatus(entry);
+    if (!account) continue;
+    const accountId = asString(account.accountId) ?? "default";
+    const enabled = account.enabled !== false;
+    const configured = account.configured === true;
+    if (!enabled || !configured) continue;
+
+    if (account.dmPolicy === "open") {
+      issues.push({
+        channel: "zalo",
+        accountId,
+        kind: "config",
+        message:
+          'Zalo dmPolicy is "open", allowing any user to message the bot without pairing.',
+        fix: 'Set channels.zalo.dmPolicy to "pairing" or "allowlist" to restrict access.',
+      });
+    }
+  }
+  return issues;
+}
diff --git a/extensions/zalo/src/token.ts b/extensions/zalo/src/token.ts
new file mode 100644
index 000000000..be3ee5dd9
--- /dev/null
+++ b/extensions/zalo/src/token.ts
@@ -0,0 +1,54 @@
+import { readFileSync } from "node:fs";
+
+import type { ZaloConfig } from "./types.js";
+import { DEFAULT_ACCOUNT_ID } from "./shared/account-ids.js";
+
+export type ZaloTokenResolution = {
+  token: string;
+  source: "env" | "config" | "configFile" | "none";
+};
+
+export function resolveZaloToken(
+  config: ZaloConfig | undefined,
+  accountId?: string | null,
+): ZaloTokenResolution {
+  const resolvedAccountId = accountId ?? DEFAULT_ACCOUNT_ID;
+  const isDefaultAccount = resolvedAccountId === DEFAULT_ACCOUNT_ID;
+  const baseConfig = config;
+  const accountConfig =
+    resolvedAccountId !== DEFAULT_ACCOUNT_ID
+      ? (baseConfig?.accounts?.[resolvedAccountId] as ZaloConfig | undefined)
+      : undefined;
+
+  if (accountConfig) {
+    const token = accountConfig.botToken?.trim();
+    if (token) return { token, source: "config" };
+    const tokenFile = accountConfig.tokenFile?.trim();
+    if (tokenFile) {
+      try {
+        const fileToken = readFileSync(tokenFile, "utf8").trim();
+        if (fileToken) return { token: fileToken, source: "configFile" };
+      } catch {
+        // ignore read failures
+      }
+    }
+  }
+
+  if (isDefaultAccount) {
+    const token = baseConfig?.botToken?.trim();
+    if (token) return { token, source: "config" };
+    const tokenFile = baseConfig?.tokenFile?.trim();
+    if (tokenFile) {
+      try {
+        const fileToken = readFileSync(tokenFile, "utf8").trim();
+        if (fileToken) return { token: fileToken, source: "configFile" };
+      } catch {
+        // ignore read failures
+      }
+    }
+    const envToken = process.env.ZALO_BOT_TOKEN?.trim();
+    if (envToken) return { token: envToken, source: "env" };
+  }
+
+  return { token: "", source: "none" };
+}
diff --git a/extensions/zalo/src/tool-helpers.ts b/extensions/zalo/src/tool-helpers.ts
new file mode 100644
index 000000000..358be47ac
--- /dev/null
+++ b/extensions/zalo/src/tool-helpers.ts
@@ -0,0 +1,30 @@
+export function readStringParam(
+  params: Record<string, unknown>,
+  key: string,
+  opts?: { required?: boolean; allowEmpty?: boolean; trim?: boolean },
+): string | undefined {
+  const raw = params[key];
+  if (raw === undefined || raw === null) {
+    if (opts?.required) throw new Error(`${key} is required`);
+    return undefined;
+  }
+  const value = String(raw);
+  const trimmed = opts?.trim === false ? value : value.trim();
+  if (!opts?.allowEmpty && !trimmed) {
+    if (opts?.required) throw new Error(`${key} is required`);
+    return undefined;
+  }
+  return trimmed;
+}
+
+export function jsonResult(payload: unknown) {
+  return {
+    content: [
+      {
+        type: "text",
+        text: JSON.stringify(payload, null, 2),
+      },
+    ],
+    details: payload,
+  };
+}
diff --git a/extensions/zalo/src/types.ts b/extensions/zalo/src/types.ts
new file mode 100644
index 000000000..8309654c7
--- /dev/null
+++ b/extensions/zalo/src/types.ts
@@ -0,0 +1,49 @@
+export type ZaloAccountConfig = {
+  /** Optional display name for this account (used in CLI/UI lists). */
+  name?: string;
+  /** If false, do not start this Zalo account. Default: true. */
+  enabled?: boolean;
+  /** Bot token from Zalo Bot Creator. */
+  botToken?: string;
+  /** Path to file containing the bot token. */
+  tokenFile?: string;
+  /** Webhook URL for receiving updates (HTTPS required). */
+  webhookUrl?: string;
+  /** Webhook secret token (8-256 chars) for request verification. */
+  webhookSecret?: string;
+  /** Webhook path for the gateway HTTP server (defaults to webhook URL path). */
+  webhookPath?: string;
+  /** Direct message access policy (default: pairing). */
+  dmPolicy?: "pairing" | "allowlist" | "open" | "disabled";
+  /** Allowlist for DM senders (Zalo user IDs). */
+  allowFrom?: Array<string | number>;
+  /** Max inbound media size in MB. */
+  mediaMaxMb?: number;
+  /** Proxy URL for API requests. */
+  proxy?: string;
+};
+
+export type ZaloConfig = {
+  /** Optional per-account Zalo configuration (multi-account). */
+  accounts?: Record<string, ZaloAccountConfig>;
+  /** Default account ID when multiple accounts are configured. */
+  defaultAccount?: string;
+} & ZaloAccountConfig;
+
+export type ZaloTokenSource = "env" | "config" | "configFile" | "none";
+
+export type ResolvedZaloAccount = {
+  accountId: string;
+  name?: string;
+  enabled: boolean;
+  token: string;
+  tokenSource: ZaloTokenSource;
+  config: ZaloAccountConfig;
+};
+
+export type CoreConfig = {
+  channels?: {
+    zalo?: ZaloConfig;
+  };
+  [key: string]: unknown;
+};
diff --git a/package.json b/package.json
index 6ec3c86c4..672d747d5 100644
--- a/package.json
+++ b/package.json
@@ -147,7 +147,9 @@
     "@slack/web-api": "^7.13.0",
     "@whiskeysockets/baileys": "7.0.0-rc.9",
     "ajv": "^8.17.1",
+    "better-sqlite3": "^12.6.0",
     "body-parser": "^2.2.2",
+    "busboy": "^1.6.0",
     "chalk": "^5.6.2",
     "chokidar": "^5.0.0",
     "chromium-bidi": "12.0.1",
@@ -161,6 +163,7 @@
     "grammy": "^1.39.2",
     "jiti": "^2.6.1",
     "json5": "^2.2.3",
+    "jsonwebtoken": "^9.0.3",
     "long": "5.3.2",
     "markdown-it": "^14.1.0",
     "node-llama-cpp": "3.14.5",
@@ -180,8 +183,11 @@
     "@lit-labs/signals": "^0.2.0",
     "@lit/context": "^1.1.6",
     "@mariozechner/mini-lit": "0.2.1",
+    "@types/better-sqlite3": "^7.6.13",
     "@types/body-parser": "^1.19.6",
+    "@types/busboy": "^1.5.4",
     "@types/express": "^5.0.6",
+    "@types/jsonwebtoken": "^9.0.10",
     "@types/markdown-it": "^14.1.2",
     "@types/node": "^25.0.6",
     "@types/proper-lockfile": "^4.1.4",
@@ -211,7 +217,16 @@
     },
     "patchedDependencies": {
       "@mariozechner/pi-ai@0.45.7": "patches/@mariozechner__pi-ai@0.45.7.patch"
-    }
+    },
+    "onlyBuiltDependencies": [
+      "@whiskeysockets/baileys",
+      "authenticate-pam",
+      "better-sqlite3",
+      "esbuild",
+      "node-llama-cpp",
+      "protobufjs",
+      "sharp"
+    ]
   },
   "vitest": {
     "coverage": {
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 7266472d5..8b9a51f10 100644
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -67,9 +67,15 @@ importers:
       ajv:
         specifier: ^8.17.1
         version: 8.17.1
+      better-sqlite3:
+        specifier: ^12.6.0
+        version: 12.6.0
       body-parser:
         specifier: ^2.2.2
         version: 2.2.2
+      busboy:
+        specifier: ^1.6.0
+        version: 1.6.0
       chalk:
         specifier: ^5.6.2
         version: 5.6.2
@@ -109,6 +115,9 @@ importers:
       json5:
         specifier: ^2.2.3
         version: 2.2.3
+      jsonwebtoken:
+        specifier: ^9.0.3
+        version: 9.0.3
       long:
         specifier: 5.3.2
         version: 5.3.2
@@ -161,12 +170,21 @@ importers:
       '@mariozechner/mini-lit':
         specifier: 0.2.1
         version: 0.2.1(lit@3.3.2)(tailwindcss@4.1.17)
+      '@types/better-sqlite3':
+        specifier: ^7.6.13
+        version: 7.6.13
       '@types/body-parser':
         specifier: ^1.19.6
         version: 1.19.6
+      '@types/busboy':
+        specifier: ^1.5.4
+        version: 1.5.4
       '@types/express':
         specifier: ^5.0.6
         version: 5.0.6
+      '@types/jsonwebtoken':
+        specifier: ^9.0.10
+        version: 9.0.10
       '@types/markdown-it':
         specifier: ^14.1.2
         version: 14.1.2
@@ -1851,12 +1869,18 @@ packages:
   '@types/aws-lambda@8.10.159':
     resolution: {integrity: sha512-SAP22WSGNN12OQ8PlCzGzRCZ7QDCwI85dQZbmpz7+mAk+L7j+wI7qnvmdKh+o7A5LaOp6QnOZ2NJphAZQTTHQg==}
 
+  '@types/better-sqlite3@7.6.13':
+    resolution: {integrity: sha512-NMv9ASNARoKksWtsq/SHakpYAYnhBrQgGD8zkLYk/jaK8jUGn08CfEdTRgYhMypUQAfzSP8W6gNLe0q19/t4VA==}
+
   '@types/body-parser@1.19.6':
     resolution: {integrity: sha512-HLFeCYgz89uk22N5Qg3dvGvsv46B8GLvKKo1zKG4NybA8U2DiEO3w9lqGg29t/tfLRJpJ6iQxnVw4OnB7MoM9g==}
 
   '@types/bun@1.3.3':
     resolution: {integrity: sha512-ogrKbJ2X5N0kWLLFKeytG0eHDleBYtngtlbu9cyBKFtNL3cnpDZkNdQj8flVf6WTZUX5ulI9AY1oa7ljhSrp+g==}
 
+  '@types/busboy@1.5.4':
+    resolution: {integrity: sha512-kG7WrUuAKK0NoyxfQHsVE6j1m01s6kMma64E+OZenQABMQyTJop1DumUWcLwAQ2JzpefU7PDYoRDKl8uZosFjw==}
+
   '@types/chai@5.2.3':
     resolution: {integrity: sha512-Mw558oeA9fFbv65/y4mHtXDs9bPnFMZAL/jxdPFUpOHHIXX91mcgEHbS5Lahr+pwZFR8A7GQleRWeI6cGFC2UA==}
 
@@ -2151,6 +2175,10 @@ packages:
   before-after-hook@4.0.0:
     resolution: {integrity: sha512-q6tR3RPqIB1pMiTRMFcZwuG5T8vwp+vUvEG0vuI6B+Rikh5BfPp2fQ82c925FOs+b0lcFQ8CFrL+KbilfZFhOQ==}
 
+  better-sqlite3@12.6.0:
+    resolution: {integrity: sha512-FXI191x+D6UPWSze5IzZjhz+i9MK9nsuHsmTX9bXVl52k06AfZ2xql0lrgIUuzsMsJ7Vgl5kIptvDgBLIV3ZSQ==}
+    engines: {node: 20.x || 22.x || 23.x || 24.x || 25.x}
+
   bignumber.js@9.3.1:
     resolution: {integrity: sha512-Ko0uX15oIUS7wJ3Rb30Fs6SkVbLmPBAKdlm7q9+ak9bbIeFf0MwuBsQV6z7+X768/cHsfg+WlysDWJcmthjsjQ==}
 
@@ -2158,6 +2186,12 @@ packages:
     resolution: {integrity: sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==}
     engines: {node: '>=8'}
 
+  bindings@1.5.0:
+    resolution: {integrity: sha512-p2q/t/mhvuOj/UeLlV6566GD/guowlr0hHxClI0W9m7MWYkL1F0hLo+0Aexs9HSPCtR1SXQ0TD3MMKrXZajbiQ==}
+
+  bl@4.1.0:
+    resolution: {integrity: sha512-1W07cM9gS6DcLperZfFSj+bWLtaPGSOHWhPiGzXmvVJbRLdG82sH/Kn8EtW1VqWVA54AKf2h5k5BbnIbwF3h6w==}
+
   body-parser@2.2.2:
     resolution: {integrity: sha512-oP5VkATKlNwcgvxi0vM0p/D3n2C3EReYVX+DNYs5TjZFn/oQt2j+4sVJtSMr18pdRr8wjTcBl6LoV+FUwzPmNA==}
     engines: {node: '>=18'}
@@ -2188,12 +2222,19 @@ packages:
   buffer-from@1.1.2:
     resolution: {integrity: sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==}
 
+  buffer@5.7.1:
+    resolution: {integrity: sha512-EHcyIPBQ4BSGlvjB16k5KgAJ27CIsHY/2JBmCRReo48y9rQ3MaUzWX3KVlBa4U7MyX02HdVj0K7C3WaB3ju7FQ==}
+
   buffer@6.0.3:
     resolution: {integrity: sha512-FTiCpNxtwiZZHEZbcbTIcZjERVICn9yq/pDFkTl95/AxzD1naBctN7YO68riM/gLSDY7sdrMby8hofADYuuqOA==}
 
   bun-types@1.3.3:
     resolution: {integrity: sha512-z3Xwlg7j2l9JY27x5Qn3Wlyos8YAp0kKRlrePAOjgjMGS5IG6E7Jnlx736vH9UVI4wUICwwhC9anYL++XeOgTQ==}
 
+  busboy@1.6.0:
+    resolution: {integrity: sha512-8SFQbg/0hQ9xy3UNTB0YEnsNBbWfhf7RtnzpL7TkBiTBRfrQ9Fxcnz7VJsleJpyp6rVLvXiuORqjlHi5q+PYuA==}
+    engines: {node: '>=10.16.0'}
+
   bytes@3.1.2:
     resolution: {integrity: sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==}
     engines: {node: '>= 0.8'}
@@ -2232,6 +2273,9 @@ packages:
     resolution: {integrity: sha512-TQMmc3w+5AxjpL8iIiwebF73dRDF4fBIieAqGn9RGCWaEVwQ6Fb2cGe31Yns0RRIzii5goJ1Y7xbMwo1TxMplw==}
     engines: {node: '>= 20.19.0'}
 
+  chownr@1.1.4:
+    resolution: {integrity: sha512-jJ0bqzaylmJtVnNgzTeSOs8DPavpbYgEr/b0YL8/2GO3xJEhInFmhKMUnEJQjZumK7KXGFhUy89PrsJWlakBVg==}
+
   chownr@2.0.0:
     resolution: {integrity: sha512-bIomtDF5KGpdogkLd9VspvFzk9KfpyyGlS8YFVZl7TGPBHL5snIOnxeshwVgPteQ9b4Eydl+pVbIyE1DcvCWgQ==}
     engines: {node: '>=10'}
@@ -2363,6 +2407,10 @@ packages:
       supports-color:
         optional: true
 
+  decompress-response@6.0.0:
+    resolution: {integrity: sha512-aW35yZM6Bb/4oJlZncMH2LCoZtJXTRxES17vE3hoRiowU2kWHaJKFkSBDnDR+cm9J+9QhXmREyIfv0pji9ejCQ==}
+    engines: {node: '>=10'}
+
   deep-extend@0.6.0:
     resolution: {integrity: sha512-LOHxIOaPYdHlJRtCQfDIVZtfw/ufM8+rVj649RIHzcm/vGwQRXFt6OPqIFWsm2XEMrNIEtWR64sY1LEKD2vAOA==}
     engines: {node: '>=4.0.0'}
@@ -2431,6 +2479,9 @@ packages:
     resolution: {integrity: sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==}
     engines: {node: '>= 0.8'}
 
+  end-of-stream@1.4.5:
+    resolution: {integrity: sha512-ooEGc6HP26xXq/N+GCGOT0JKCLDGrq2bQUZrQ7gyrJiZANJ/8YDTxTpQBXGMn+WbIQXNVpyWymm7KYVICQnyOg==}
+
   entities@4.5.0:
     resolution: {integrity: sha512-V0hjH4dGPh9Ao5p0MoRY6BVqtwCjhz6vI5LT8AJ55H+4g9/4vbHx1I54fS0XuclLhDHArPQCiMjDxjaL8fPxhw==}
     engines: {node: '>=0.12'}
@@ -2491,6 +2542,10 @@ packages:
     resolution: {integrity: sha512-mQw+2fkQbALzQ7V0MY0IqdnXNOeTtP4r0lN9z7AAawCXgqea7bDii20AYrIBrFd/Hx0M2Ocz6S111CaFkUcb0Q==}
     engines: {node: '>=0.8.x'}
 
+  expand-template@2.0.3:
+    resolution: {integrity: sha512-XYfuKMvj4O35f/pOXLObndIRvyQ+/+6AhODh+OKWj9S9498pHHn/IMszH+gt0fBCRWMNfk1ZSp5x3AifmnI2vg==}
+    engines: {node: '>=6'}
+
   expect-type@1.3.0:
     resolution: {integrity: sha512-knvyeauYhqjOYvQ66MznSMs83wmHrCycNEN6Ao+2AeYEfxUIkuiVxdEa1qlGEPK+We3n0THiDciYSsCcgW/DoA==}
     engines: {node: '>=12.0.0'}
@@ -2539,6 +2594,9 @@ packages:
     resolution: {integrity: sha512-8kPJMIGz1Yt/aPEwOsrR97ZyZaD1Iqm8PClb1nYFclUCkBi0Ma5IsYNQzvSFS9ib51lWyIw5mIT9rWzI/xjpzA==}
     engines: {node: '>=20'}
 
+  file-uri-to-path@1.0.0:
+    resolution: {integrity: sha512-0Zt+s3L7Vf1biwWZ29aARiVYLx7iMGnEUl9x33fbB/j3jR81u/O2LbqK+Bm1CDSNDKVtJ/YjwY7TUd5SkeLQLw==}
+
   filename-reserved-regex@3.0.0:
     resolution: {integrity: sha512-hn4cQfU6GOT/7cFHXBqeBg2TbrMBgdD0kcjLhvSQYYwm3s4B6cjvBfb7nBALJLAXqmU5xajSa7X2NnUud/VCdw==}
     engines: {node: ^12.20.0 || ^14.13.1 || >=16.0.0}
@@ -2584,6 +2642,9 @@ packages:
     resolution: {integrity: sha512-Rx/WycZ60HOaqLKAi6cHRKKI7zxWbJ31MhntmtwMoaTeF7XFH9hhBp8vITaMidfljRQ6eYWCKkaTK+ykVJHP2A==}
     engines: {node: '>= 0.8'}
 
+  fs-constants@1.0.0:
+    resolution: {integrity: sha512-y6OAwoSIf7FyjMIv94u+b5rdheZEjzR63GTyZJm5qh4Bi+2YgwLCcI/fPFZkL5PSixOt6ZNKm+w+Hfp/Bciwow==}
+
   fs-extra@11.3.3:
     resolution: {integrity: sha512-VWSRii4t0AFm6ixFFmLLx1t7wS1gh+ckoa84aOeapGum0h+EZd1EhEumSB+ZdDLnEPuucsVB9oB7cxJHap6Afg==}
     engines: {node: '>=14.14'}
@@ -2637,6 +2698,9 @@ packages:
   get-tsconfig@4.13.0:
     resolution: {integrity: sha512-1VKTZJCwBrvbd+Wn3AOgQP/2Av+TfTCOlE4AcRJE72W1ksZXbAx8PPBR9RzgTeSPzlPMHrbANMH3LbltH73wxQ==}
 
+  github-from-package@0.0.0:
+    resolution: {integrity: sha512-SyHy3T1v2NUXn29OsWdxmK6RwHD+vkj3v8en8AOBZ1wBQ/hCAQ5bAQTD02kW4W9tUp/3Qh6J8r9EvntiyCmOOw==}
+
   glob-parent@5.1.2:
     resolution: {integrity: sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==}
     engines: {node: '>= 6'}
@@ -3130,6 +3194,10 @@ packages:
     resolution: {integrity: sha512-VP79XUPxV2CigYP3jWwAUFSku2aKqBH7uTAapFWCBqutsbmDo96KY5o8uh6U+/YSIn5OxJnXp73beVkpqMIGhA==}
     engines: {node: '>=18'}
 
+  mimic-response@3.1.0:
+    resolution: {integrity: sha512-z0yWI+4FDrrweS8Zmt4Ej5HdJmky15+L2e6Wgn3+iK5fWzb6T3fhNFq2+MeTRb064c6Wr4N/wv0DzQTjNzHNGQ==}
+    engines: {node: '>=10'}
+
   minimatch@10.1.1:
     resolution: {integrity: sha512-enIvLvRAFZYXJzkCYG5RKmPfrFArdLv+R+lbQ53BmIMLIry74bjKzX6iHAm8WYamJkhSSEabrWN5D97XnKObjQ==}
     engines: {node: 20 || >=22}
@@ -3164,6 +3232,9 @@ packages:
   mitt@3.0.1:
     resolution: {integrity: sha512-vKivATfr97l2/QBCYAkXYDbrIWPM2IIKEl7YPhjCvKlG3kE2gm+uBo6nEXK3M5/Ffh/FLpKExzOQ3JJoJGFKBw==}
 
+  mkdirp-classic@0.5.3:
+    resolution: {integrity: sha512-gKLcREMhtuZRwRAfqP3RFW+TK4JqApVBtOIftVgjuABpAtpxhPGaDcfvbhNvD0B8iD1oUr/txX35NjcaY6Ns/A==}
+
   mkdirp@1.0.4:
     resolution: {integrity: sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==}
     engines: {node: '>=10'}
@@ -3196,10 +3267,17 @@ packages:
     engines: {node: ^18 || >=20}
     hasBin: true
 
+  napi-build-utils@2.0.0:
+    resolution: {integrity: sha512-GEbrYkbfF7MoNaoh2iGG84Mnf/WZfB0GdGEsM8wz7Expx/LlWf5U8t9nvJKXSp3qr5IsEbK04cBGhol/KwOsWA==}
+
   negotiator@1.0.0:
     resolution: {integrity: sha512-8Ofs/AUQh8MaEcrlq5xOX0CQ9ypTF5dl78mjlMNfOK08fzpgTHQRQPBxcPlEtIw0yRpws+Zo/3r+5WRby7u3Gg==}
     engines: {node: '>= 0.6'}
 
+  node-abi@3.85.0:
+    resolution: {integrity: sha512-zsFhmbkAzwhTft6nd3VxcG0cvJsT70rL+BIGHWVq5fi6MwGrHwzqKaxXE+Hl2GmnGItnDKPPkO5/LQqjVkIdFg==}
+    engines: {node: '>=10'}
+
   node-addon-api@8.5.0:
     resolution: {integrity: sha512-/bRZty2mXUIFY/xU5HLvveNHlswNJej+RnxBjOMkidWfwZzgTbPG1E3K5TOxRLOR+5hX7bSofy8yf1hZevMS8A==}
     engines: {node: ^18 || ^20 || >= 21}
@@ -3452,6 +3530,11 @@ packages:
     resolution: {integrity: sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==}
     engines: {node: ^10 || ^12 || >=14}
 
+  prebuild-install@7.1.3:
+    resolution: {integrity: sha512-8Mf2cbV7x1cXPUILADGI3wuhfqWvtiLA1iclTDbFRZkgRQS0NqsPZphna9V+HyTEadheuPmjaJMsbzKQFOzLug==}
+    engines: {node: '>=10'}
+    hasBin: true
+
   pretty-bytes@6.1.1:
     resolution: {integrity: sha512-mQUvGU6aUFQ+rNvTIAcZuWGRT9a6f6Yrg9bHs4ImKF+HZCEK+plBvnAZYSIQztknZF2qnzNtr6F8s0+IuptdlQ==}
     engines: {node: ^14.13.1 || >=16.0.0}
@@ -3509,6 +3592,9 @@ packages:
   proxy-from-env@1.1.0:
     resolution: {integrity: sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==}
 
+  pump@3.0.3:
+    resolution: {integrity: sha512-todwxLMY7/heScKmntwQG8CXVkWUOdYxIvY2s0VWAAMh/nd8SoYiRaKjlr7+iCs984f2P8zvrfWcDDYVb73NfA==}
+
   punycode.js@2.3.1:
     resolution: {integrity: sha512-uxFIHU0YlHYhDQtV4R9J6a52SLx28BCjT+4ieh7IGbgwVJWO+km431c4yRlREUAsAmt/uMjQUyQHNEPf0M39CA==}
     engines: {node: '>=6'}
@@ -3701,6 +3787,12 @@ packages:
     peerDependencies:
       signal-polyfill: ^0.2.0
 
+  simple-concat@1.0.1:
+    resolution: {integrity: sha512-cSFtAPtRhljv69IK0hTVZQ+OfE9nePi/rtJmw5UjHeVyVroEqJXP1sFztKUy1qU+xvz3u/sfYJLa947b7nAN2Q==}
+
+  simple-get@4.0.1:
+    resolution: {integrity: sha512-brv7p5WgH0jmQJr1ZDDfKDOSeWWg+OVypG99A/5vYGPqJ6pxiaHLy8nxtFjBA7oMa01ebA9gfh1uMCFqOuXxvA==}
+
   simple-git@3.30.0:
     resolution: {integrity: sha512-q6lxyDsCmEal/MEGhP1aVyQ3oxnagGlBDOVSIB4XUVLl1iZh0Pah6ebC9V4xBap/RfgP2WlI8EKs0WS0rMEJHg==}
 
@@ -3761,6 +3853,10 @@ packages:
     resolution: {integrity: sha512-yhPIQXjrlt1xv7dyPQg2P17URmXbuM5pdGkpiMB3RenprfiBlvK415Lctfe0eshk90oA7/tNq7WEiMK8RSP39A==}
     engines: {node: '>=18'}
 
+  streamsearch@1.1.0:
+    resolution: {integrity: sha512-Mcc5wHehp9aXz1ax6bZUyY5afg9u2rv5cqQI3mRrYkGC8rW2hM02jWuwjtL++LS5qinSyhj2QfLyNsuc+VsExg==}
+    engines: {node: '>=10.0.0'}
+
   string-width@4.2.3:
     resolution: {integrity: sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==}
     engines: {node: '>=8'}
@@ -3818,6 +3914,13 @@ packages:
   tailwindcss@4.1.17:
     resolution: {integrity: sha512-j9Ee2YjuQqYT9bbRTfTZht9W/ytp5H+jJpZKiYdP/bpnXARAuELt9ofP0lPnmHjbga7SNQIxdTAXCmtKVYjN+Q==}
 
+  tar-fs@2.1.4:
+    resolution: {integrity: sha512-mDAjwmZdh7LTT6pNleZ05Yt65HC3E+NiQzl672vQG38jIrehtJk/J3mNwIg+vShQPcLF/LV7CMnDW6vjj6sfYQ==}
+
+  tar-stream@2.2.0:
+    resolution: {integrity: sha512-ujeqbceABgwMZxEJnk2HDY2DlnUZ+9oEcb1KzTVfYHio0UE6dG71n60d8D2I4qNvleWrrXpmjpt7vZeF1LnMZQ==}
+    engines: {node: '>=6'}
+
   tar@6.2.1:
     resolution: {integrity: sha512-DZ4yORTwrbTj/7MZYq2w+/ZFdI6OZ/f9SFHR+71gIVUZhOQPHzVCLpvRnPgyaMpfWxxk/4ONva3GQSyNIKRv6A==}
     engines: {node: '>=10'}
@@ -3900,6 +4003,9 @@ packages:
     engines: {node: '>=18.0.0'}
     hasBin: true
 
+  tunnel-agent@0.6.0:
+    resolution: {integrity: sha512-McnNiV1l8RYeY8tBgEpuodCC1mLUdbSN+CYBL7kJsJNInOP8UjDDEwdk6Mw60vdLLrr5NHKZhMAOSrR2NZuQ+w==}
+
   type-is@2.0.1:
     resolution: {integrity: sha512-OZs6gsjF4vMp32qrCbiVSkrFmXtG/AZhY3t0iAMrMBiAZyV9oALtXO8hsrHbMXF9x6L3grlFuwW2oAz7cav+Gw==}
     engines: {node: '>= 0.6'}
@@ -6032,6 +6138,10 @@ snapshots:
 
   '@types/aws-lambda@8.10.159': {}
 
+  '@types/better-sqlite3@7.6.13':
+    dependencies:
+      '@types/node': 25.0.7
+
   '@types/body-parser@1.19.6':
     dependencies:
       '@types/connect': 3.4.38
@@ -6042,6 +6152,10 @@ snapshots:
       bun-types: 1.3.3
     optional: true
 
+  '@types/busboy@1.5.4':
+    dependencies:
+      '@types/node': 25.0.7
+
   '@types/chai@5.2.3':
     dependencies:
       '@types/deep-eql': 4.0.2
@@ -6407,10 +6521,25 @@ snapshots:
 
   before-after-hook@4.0.0: {}
 
+  better-sqlite3@12.6.0:
+    dependencies:
+      bindings: 1.5.0
+      prebuild-install: 7.1.3
+
   bignumber.js@9.3.1: {}
 
   binary-extensions@2.3.0: {}
 
+  bindings@1.5.0:
+    dependencies:
+      file-uri-to-path: 1.0.0
+
+  bl@4.1.0:
+    dependencies:
+      buffer: 5.7.1
+      inherits: 2.0.4
+      readable-stream: 3.6.2
+
   body-parser@2.2.2:
     dependencies:
       bytes: 3.1.2
@@ -6447,6 +6576,11 @@ snapshots:
 
   buffer-from@1.1.2: {}
 
+  buffer@5.7.1:
+    dependencies:
+      base64-js: 1.5.1
+      ieee754: 1.2.1
+
   buffer@6.0.3:
     dependencies:
       base64-js: 1.5.1
@@ -6457,6 +6591,10 @@ snapshots:
       '@types/node': 25.0.7
     optional: true
 
+  busboy@1.6.0:
+    dependencies:
+      streamsearch: 1.1.0
+
   bytes@3.1.2: {}
 
   cacheable@2.3.1:
@@ -6504,6 +6642,8 @@ snapshots:
     dependencies:
       readdirp: 5.0.0
 
+  chownr@1.1.4: {}
+
   chownr@2.0.0: {}
 
   chownr@3.0.0: {}
@@ -6623,6 +6763,10 @@ snapshots:
     dependencies:
       ms: 2.1.3
 
+  decompress-response@6.0.0:
+    dependencies:
+      mimic-response: 3.1.0
+
   deep-extend@0.6.0: {}
 
   delayed-stream@1.0.0: {}
@@ -6673,6 +6817,10 @@ snapshots:
 
   encodeurl@2.0.0: {}
 
+  end-of-stream@1.4.5:
+    dependencies:
+      once: 1.4.0
+
   entities@4.5.0: {}
 
   env-var@7.5.0: {}
@@ -6741,6 +6889,8 @@ snapshots:
 
   events@3.3.0: {}
 
+  expand-template@2.0.3: {}
+
   expect-type@1.3.0: {}
 
   express@5.2.1:
@@ -6818,6 +6968,8 @@ snapshots:
     transitivePeerDependencies:
       - supports-color
 
+  file-uri-to-path@1.0.0: {}
+
   filename-reserved-regex@3.0.0: {}
 
   filenamify@6.0.0:
@@ -6864,6 +7016,8 @@ snapshots:
 
   fresh@2.0.0: {}
 
+  fs-constants@1.0.0: {}
+
   fs-extra@11.3.3:
     dependencies:
       graceful-fs: 4.2.11
@@ -6936,6 +7090,8 @@ snapshots:
     dependencies:
       resolve-pkg-maps: 1.0.0
 
+  github-from-package@0.0.0: {}
+
   glob-parent@5.1.2:
     dependencies:
       is-glob: 4.0.3
@@ -7423,6 +7579,8 @@ snapshots:
 
   mimic-function@5.0.1: {}
 
+  mimic-response@3.1.0: {}
+
   minimatch@10.1.1:
     dependencies:
       '@isaacs/brace-expansion': 5.0.0
@@ -7452,6 +7610,8 @@ snapshots:
 
   mitt@3.0.1: {}
 
+  mkdirp-classic@0.5.3: {}
+
   mkdirp@1.0.4: {}
 
   mpg123-decoder@1.0.3:
@@ -7487,8 +7647,14 @@ snapshots:
 
   nanoid@5.1.6: {}
 
+  napi-build-utils@2.0.0: {}
+
   negotiator@1.0.0: {}
 
+  node-abi@3.85.0:
+    dependencies:
+      semver: 7.7.3
+
   node-addon-api@8.5.0: {}
 
   node-api-headers@1.7.0: {}
@@ -7781,6 +7947,21 @@ snapshots:
       picocolors: 1.1.1
       source-map-js: 1.2.1
 
+  prebuild-install@7.1.3:
+    dependencies:
+      detect-libc: 2.1.2
+      expand-template: 2.0.3
+      github-from-package: 0.0.0
+      minimist: 1.2.8
+      mkdirp-classic: 0.5.3
+      napi-build-utils: 2.0.0
+      node-abi: 3.85.0
+      pump: 3.0.3
+      rc: 1.2.8
+      simple-get: 4.0.1
+      tar-fs: 2.1.4
+      tunnel-agent: 0.6.0
+
   pretty-bytes@6.1.1: {}
 
   pretty-ms@8.0.0:
@@ -7844,6 +8025,11 @@ snapshots:
 
   proxy-from-env@1.1.0: {}
 
+  pump@3.0.3:
+    dependencies:
+      end-of-stream: 1.4.5
+      once: 1.4.0
+
   punycode.js@2.3.1: {}
 
   qified@0.5.3:
@@ -8135,6 +8321,14 @@ snapshots:
     dependencies:
       signal-polyfill: 0.2.2
 
+  simple-concat@1.0.1: {}
+
+  simple-get@4.0.1:
+    dependencies:
+      decompress-response: 6.0.0
+      once: 1.4.0
+      simple-concat: 1.0.1
+
   simple-git@3.30.0:
     dependencies:
       '@kwsites/file-exists': 1.1.1
@@ -8193,6 +8387,8 @@ snapshots:
 
   steno@4.0.2: {}
 
+  streamsearch@1.1.0: {}
+
   string-width@4.2.3:
     dependencies:
       emoji-regex: 8.0.0
@@ -8249,6 +8445,21 @@ snapshots:
 
   tailwindcss@4.1.17: {}
 
+  tar-fs@2.1.4:
+    dependencies:
+      chownr: 1.1.4
+      mkdirp-classic: 0.5.3
+      pump: 3.0.3
+      tar-stream: 2.2.0
+
+  tar-stream@2.2.0:
+    dependencies:
+      bl: 4.1.0
+      end-of-stream: 1.4.5
+      fs-constants: 1.0.0
+      inherits: 2.0.4
+      readable-stream: 3.6.2
+
   tar@6.2.1:
     dependencies:
       chownr: 2.0.0
@@ -8326,6 +8537,10 @@ snapshots:
     optionalDependencies:
       fsevents: 2.3.3
 
+  tunnel-agent@0.6.0:
+    dependencies:
+      safe-buffer: 5.2.1
+
   type-is@2.0.1:
     dependencies:
       content-type: 1.0.5
diff --git a/skills/clawline/SKILL.md b/skills/clawline/SKILL.md
new file mode 100644
index 000000000..63f2637da
--- /dev/null
+++ b/skills/clawline/SKILL.md
@@ -0,0 +1,195 @@
+name: clawline
+description: Teach Clawdbot how the Clawline mobile provider works: why the allowlist exists, how to pair/reset devices, what the user sees in the iOS/Android clients, how to restart the gateway/sidecar, and how to diagnose socket or rate-limit problems. Use this when users ask about clawline UX, want their device paired/unblocked, or need the allowlist/denylist adjusted on hosts such as tars.
+---
+
+# Clawline Allowlist
+
+## Overview
+
+Clawline is the local/mobile provider that the iOS + Android Clawline apps talk to over `http(s)://<gateway>:18792`.  
+The allowlist (`~/.clawdbot/clawline/allowlist.json`) is the source of truth for which device IDs are trusted, whether they are admins, and whether their pairing token has been delivered. Manual edits therefore control who can reach the socket at all.
+
+Use this skill whenever you need to:
+- pair a new phone or reset one that lost its token
+- explain what the allowlist does and how it differs from `denylist.json`
+- reissue/revoke a device token outside of the UI
+- confirm the Clawline HTTP/WS endpoints are alive after config changes
+- restart the gateway sidecar when the allowlist file is changed by hand
+
+## Key Paths & Defaults
+
+- State path: `~/.clawdbot/clawline` (configurable via `clawline.statePath`)
+- Allowlist file: `${statePath}/allowlist.json` (schema below)
+- Denylist file: `${statePath}/denylist.json` (hot-reloaded watcher)
+- Media path: `~/.clawdbot/clawline-media`
+- Default bind: `127.0.0.1:18792`. When binding to anything else you must set `clawline.network.allowInsecurePublic=true` **and** populate `clawline.network.allowedOrigins`.
+- tars restart flow: `ssh tars 'PATH="/opt/homebrew/bin:$PATH" tmux kill-session -t clawgate; cd ~/src/clawdbot && PATH="$HOME/Library/pnpm:/opt/homebrew/bin:$PATH" tmux new-session -d -s clawgate "pnpm clawdbot gateway"'`
+
+`allowlist.json` entries:
+
+```json5
+{
+  "version": 1,
+  "entries": [
+    {
+      "deviceId": "UUIDv4",
+      "claimedName": "Mike's iPhone",        // optional label shown to admins
+      "deviceInfo": {                        // sanitized copy of app handshake
+        "platform": "iOS" | "Android",
+        "model": "iPhone 15",
+        "osVersion": "17.2.1",
+        "appVersion": "2026.1.5"
+      },
+      "userId": "user_<uuid>",               // server-generated user identity
+      "isAdmin": true | false,
+      "tokenDelivered": true | false,        // false => next pairing request re-sends token
+      "createdAt": 1768346561762,            // ms epoch
+      "lastSeenAt": 1768436564355 | null
+    }
+  ]
+}
+```
+
+⚠️ The gateway loads the allowlist once at startup. Any manual file edits require a gateway restart to take effect. (Only the denylist has a file watcher.)
+
+## Workflow
+
+### 1. Health check / discovery
+
+1. Verify the process is running: `curl -sS http://<host>:18792/version` should return `{"protocolVersion":1}`.  
+2. Spot-check WS upgrades: use Node/Bun `ws` to connect (`node -e 'const ws=new (require("ws"))("ws://.../ws"); ...'`). Receiving `{"type":"error","code":"invalid_message"}` for a dummy payload confirms the socket is alive.  
+3. If either fails, restart the gateway (see commands above) and tail `~/.clawdbot/logs/gateway.log`.
+
+### 2. Inspect current allowlist state
+
+```bash
+cd ~/.clawdbot/clawline
+cat allowlist.json | jq '{entries: [.entries[] | {deviceId, userId, isAdmin, claimedName, lastSeenAt}] }'
+```
+
+Notes:
+- Admin detection is `entry.isAdmin === true`. The first paired device becomes admin automatically when the list is empty (`server.ts:1628-1650`).
+- `lastSeenAt: null` means the device has never authenticated with the issued token.
+- To list pending devices still waiting on approval, query `pendingPairs` via gateway logs (`[clawline] pending pair`). Manual allowlist edits bypass the admin approval flow entirely, so only use them when you trust the device identity.
+
+### 3. Add or update an allowlist entry manually
+
+Use Python to maintain JSON fidelity (avoids jq quoting issues):
+
+```bash
+python3 - <<'PY'
+import json, pathlib, time, uuid
+state = pathlib.Path.home() / ".clawdbot" / "clawline" / "allowlist.json"
+data = json.loads(state.read_text()) if state.exists() else {"version": 1, "entries": []}
+
+entry = {
+    "deviceId": "INSERT-DEVICE-UUID",
+    "claimedName": "INSERT LABEL",
+    "deviceInfo": {"platform": "iOS", "model": "iPhone", "osVersion": "17.2.1", "appVersion": "2026.1.5"},
+    "userId": "user_" + str(uuid.uuid4()),
+    "isAdmin": True,
+    "tokenDelivered": False,
+    "createdAt": int(time.time() * 1000),
+    "lastSeenAt": None,
+}
+
+data["entries"] = [e for e in data["entries"] if e["deviceId"] != entry["deviceId"]]
+data["entries"].append(entry)
+state.write_text(json.dumps(data, indent=2) + "\n")
+PY
+```
+
+- `tokenDelivered=false` tells Clawline to return the token on the very next `pair_request` from that device ID.  
+- Set `isAdmin=true` only for trusted devices—admins can approve other pairings via the app.  
+- For an existing user restoring access, re-use the same `userId` (grab it from the file before overwriting) so history stays linked.
+
+### 4. Reissue a token for an existing device
+
+If the device already has an entry:
+1. Set `tokenDelivered` to `false` and `lastSeenAt` to `null`.
+2. Restart the gateway. On the next pairing attempt the server will resend the JWT with the same `userId`.
+3. Optional: if the device was soft-deleted, you can also refresh `createdAt` to now for auditing clarity.
+
+### 5. Revoke or block a device
+
+**Immediate cut-off (hot reload):**
+1. Append `{ "deviceId": "<uuid>", "reason": "lost phone", "createdAt": 1768... }` to `~/.clawdbot/clawline/denylist.json`.  
+2. The server watches this file; matching sessions are force-closed with `token_revoked`.
+
+**Permanent removal:**
+1. Delete the entry from `allowlist.json`.  
+2. Restart the gateway so the removal is loaded.  
+3. (Optional) Leave the denylist entry for belt-and-suspenders if you expect the token to resurface.
+
+### 6. Restart after manual edits
+
+- **Local dev:** run `pnpm clawdbot gateway` (Ctrl+C, rerun) or `scripts/restart-mac.sh` on macOS.  
+- **tars (production-like):**
+  ```bash
+  ssh -i ~/.ssh/id_ed25519_tars -o IdentitiesOnly=yes tars \
+    'PATH="/opt/homebrew/bin:$PATH" tmux kill-session -t clawgate; \
+      cd ~/src/clawdbot && PATH="$HOME/Library/pnpm:/opt/homebrew/bin:$PATH" \
+      tmux new-session -d -s clawgate "pnpm clawdbot gateway"'
+  ```
+- Always watch `~/.clawdbot/logs/gateway.log` for `[clawline] listening on ...` to confirm it bound to the port. If you see `commands.native: Invalid input...`, fix `~/.clawdbot/clawdbot.json` and restart again.
+
+### 7. Smoke-test after restart
+
+```bash
+curl -sS http://localhost:18792/version
+
+node - <<'JS'
+const WebSocket = require('ws');
+const ws = new WebSocket('ws://localhost:18792/ws');
+ws.once('open', () => ws.send(JSON.stringify({type: 'ping_test'})));
+ws.once('message', (msg) => { console.log(msg.toString()); ws.close(); });
+ws.once('error', (err) => { console.error(err); process.exit(1); });
+JS
+```
+
+Use `tailscale serve status` or `curl https://tars.tail4105e8.ts.net/version` when testing over the tailnet (port-forwarded).
+
+### 8. Explain the system to users
+
+- **Allowlist** = who is trusted + role (admin/user) + token bookkeeping.  
+- **Denylist** = emergency kill switch (hot reload).  
+- Pairing flow: a device sends `pair_request`; admins approve via their app, which calls `pair_decision`. Manual allowlist edits bypass that flow, so reserve them for operational fixes or bootstrap scenarios.  
+- Admin creation: first device in an empty allowlist becomes admin automatically. To add another admin later, set `isAdmin=true` manually or elevate via the UI.
+
+### 9. Mobile UX walkthrough
+
+**New device (no admins yet)**  
+1. User opens the Clawline app, enters the Gateway URL or scans the QR.  
+2. App shows “Pairing…” while it pings `/version` and then tries the WebSocket.  
+3. Because no admins exist, the server auto-approves, the phone immediately sees “Paired as admin” and lands in the inbox. No additional prompts.
+
+**Subsequent device**  
+1. User opens the app, enters URL, sees “Requesting approval”.  
+2. Existing admins receive a notification banner + inbox card with the device name the user typed (“Pixel 8 Pro”) and Accept/Deny buttons. Pending requests are listed under Settings → Clawline Devices as well.  
+3. Admin taps Accept → requester sees “Approved! Fetching messages” as the JWT arrives; Deny shows “Pairing denied, ask an admin or try again later”.
+
+**Restore/Reissue**  
+1. User with a formerly paired phone reinstalls the app. After entering URL it jumps straight to “Downloading token…” because the allowlist entry already exists.  
+2. If you manually set `tokenDelivered=false`, the app briefly shows “Token reissued” before the standard inbox view.  
+3. If the device was removed, it falls back to the pending flow above (admins must re-approve).
+
+**Revoked device**  
+1. Device already connected suddenly sees “Session expired (token revoked)” when you add it to the denylist; the socket closes.  
+2. Attempts to re-pair show “Pairing denied” until you clear the denylist entry.
+
+### 10. End-to-end pairing lifecycle (reference)
+
+1. **Client boot** → mobile app generates/stores a UUID (deviceId) + device info, then opens a WS connection and sends `pair_request` containing protocolVersion/deviceId/deviceInfo/claimedName.  
+2. **Server receives request**  
+   - Rejects immediately if deviceId format invalid, denylisted, or rate-limited.  
+   - If the allowlist already contains that device with `tokenDelivered=false`, it re-sends the JWT and closes the socket.  
+   - If no admin exists yet, it auto-creates a new allowlist entry with `isAdmin=true`, writes it to disk, emits the JWT, and closes the socket.  
+   - Otherwise it stores a `pendingPairs` entry keyed by deviceId and notifies all connected admins via `pair_pending`.  
+3. **Admin approval** (mobile UI) → admin session sends `pair_decision` with `deviceId`, `approve`, and `userId` (usually prefilled).  
+4. **Server outcome**  
+   - Approve: creates/updates the allowlist entry, marks `tokenDelivered=false`, issues JWT, notifies the waiting socket with `pair_result success`, and deletes the pending request.  
+   - Deny: sends `pair_result success:false reason:"pair_denied"`, tracks the deviceId in `deniedDevices` for a cooling-off window, then drops the pending entry.  
+5. **Auth/login** → client connects again with `auth` (token + deviceId). Server verifies JWT, ensures pending pairs don’t exist for that device, registers a session, updates `lastSeenAt`, and replays missed events.  
+6. **Long-term state** → device keeps its JWT until it expires or is revoked. To force re-login, set `tokenDelivered=false` (or remove the entry) and restart. To revoke immediately, add to `denylist.json`.
+
+Remind requestors that Clawline is for “external things that talk to the agent” (phones). The allowlist has nothing to do with WhatsApp/Telegram provider allowlists even though the names overlap; those live in `clawbot.json`.
diff --git a/src/agents/google-gemini-switch.live.test.ts b/src/agents/google-gemini-switch.live.test.ts
new file mode 100644
index 000000000..790479036
--- /dev/null
+++ b/src/agents/google-gemini-switch.live.test.ts
@@ -0,0 +1,78 @@
+import { completeSimple, getModel } from "@mariozechner/pi-ai";
+import { describe, expect, it } from "vitest";
+
+const GEMINI_KEY = process.env.GEMINI_API_KEY ?? "";
+const LIVE = process.env.GEMINI_LIVE_TEST === "1" || process.env.LIVE === "1";
+
+const describeLive = LIVE && GEMINI_KEY ? describe : describe.skip;
+
+describeLive("gemini live switch", () => {
+  it("handles unsigned tool calls from Antigravity when switching to Gemini 3", async () => {
+    const now = Date.now();
+    const model = getModel("google", "gemini-3-pro-preview");
+
+    const res = await completeSimple(
+      model,
+      {
+        messages: [
+          {
+            role: "user",
+            content: "Reply with ok.",
+            timestamp: now,
+          },
+          {
+            role: "assistant",
+            content: [
+              {
+                type: "toolCall",
+                id: "call_1",
+                name: "bash",
+                arguments: { command: "ls -la" },
+                // No thoughtSignature: simulates Claude via Antigravity.
+              },
+            ],
+            api: "google-gemini-cli",
+            provider: "google-antigravity",
+            model: "claude-sonnet-4-20250514",
+            usage: {
+              input: 0,
+              output: 0,
+              cacheRead: 0,
+              cacheWrite: 0,
+              totalTokens: 0,
+              cost: {
+                input: 0,
+                output: 0,
+                cacheRead: 0,
+                cacheWrite: 0,
+                total: 0,
+              },
+            },
+            stopReason: "stop",
+            timestamp: now,
+          },
+        ],
+        tools: [
+          {
+            name: "bash",
+            description: "Run shell command",
+            parameters: {
+              type: "object",
+              properties: {
+                command: { type: "string" },
+              },
+              required: ["command"],
+            },
+          },
+        ],
+      },
+      {
+        apiKey: GEMINI_KEY,
+        reasoning: "low",
+        maxTokens: 128,
+      },
+    );
+
+    expect(res.stopReason).not.toBe("error");
+  }, 20000);
+});
diff --git a/src/agents/pi-embedded-runner.google-sanitize-thinking.test.ts b/src/agents/pi-embedded-runner.google-sanitize-thinking.test.ts
new file mode 100644
index 000000000..0f4aa90ff
--- /dev/null
+++ b/src/agents/pi-embedded-runner.google-sanitize-thinking.test.ts
@@ -0,0 +1,205 @@
+import type { AgentMessage } from "@mariozechner/pi-agent-core";
+import { SessionManager } from "@mariozechner/pi-coding-agent";
+import { describe, expect, it } from "vitest";
+import { sanitizeSessionHistory } from "./pi-embedded-runner/google.js";
+
+describe("sanitizeSessionHistory (google thinking)", () => {
+  it("downgrades thinking blocks without signatures for Google models", async () => {
+    const sessionManager = SessionManager.inMemory();
+    const input = [
+      {
+        role: "user",
+        content: "hi",
+      },
+      {
+        role: "assistant",
+        content: [{ type: "thinking", thinking: "reasoning" }],
+      },
+    ] satisfies AgentMessage[];
+
+    const out = await sanitizeSessionHistory({
+      messages: input,
+      modelApi: "google-antigravity",
+      sessionManager,
+      sessionId: "session:google",
+    });
+
+    const assistant = out.find((msg) => (msg as { role?: string }).role === "assistant") as {
+      content?: Array<{ type?: string; text?: string }>;
+    };
+    expect(assistant.content?.map((block) => block.type)).toEqual(["text"]);
+    expect(assistant.content?.[0]?.text).toBe("reasoning");
+  });
+
+  it("keeps thinking blocks with signatures for Google models", async () => {
+    const sessionManager = SessionManager.inMemory();
+    const input = [
+      {
+        role: "user",
+        content: "hi",
+      },
+      {
+        role: "assistant",
+        content: [{ type: "thinking", thinking: "reasoning", thinkingSignature: "sig" }],
+      },
+    ] satisfies AgentMessage[];
+
+    const out = await sanitizeSessionHistory({
+      messages: input,
+      modelApi: "google-antigravity",
+      sessionManager,
+      sessionId: "session:google",
+    });
+
+    const assistant = out.find((msg) => (msg as { role?: string }).role === "assistant") as {
+      content?: Array<{ type?: string; thinking?: string; thinkingSignature?: string }>;
+    };
+    expect(assistant.content?.map((block) => block.type)).toEqual(["thinking"]);
+    expect(assistant.content?.[0]?.thinking).toBe("reasoning");
+    expect(assistant.content?.[0]?.thinkingSignature).toBe("sig");
+  });
+
+  it("preserves order when downgrading mixed assistant content", async () => {
+    const sessionManager = SessionManager.inMemory();
+    const input = [
+      {
+        role: "user",
+        content: "hi",
+      },
+      {
+        role: "assistant",
+        content: [
+          { type: "text", text: "hello" },
+          { type: "thinking", thinking: "internal note" },
+          { type: "text", text: "world" },
+        ],
+      },
+    ] satisfies AgentMessage[];
+
+    const out = await sanitizeSessionHistory({
+      messages: input,
+      modelApi: "google-antigravity",
+      sessionManager,
+      sessionId: "session:google-mixed",
+    });
+
+    const assistant = out.find((msg) => (msg as { role?: string }).role === "assistant") as {
+      content?: Array<{ type?: string; text?: string }>;
+    };
+    expect(assistant.content?.map((block) => block.type)).toEqual(["text", "text", "text"]);
+    expect(assistant.content?.[1]?.text).toBe("internal note");
+  });
+
+  it("downgrades only unsigned thinking blocks when mixed with signed ones", async () => {
+    const sessionManager = SessionManager.inMemory();
+    const input = [
+      {
+        role: "user",
+        content: "hi",
+      },
+      {
+        role: "assistant",
+        content: [
+          { type: "thinking", thinking: "signed", thinkingSignature: "sig" },
+          { type: "thinking", thinking: "unsigned" },
+        ],
+      },
+    ] satisfies AgentMessage[];
+
+    const out = await sanitizeSessionHistory({
+      messages: input,
+      modelApi: "google-antigravity",
+      sessionManager,
+      sessionId: "session:google-mixed-signatures",
+    });
+
+    const assistant = out.find((msg) => (msg as { role?: string }).role === "assistant") as {
+      content?: Array<{ type?: string; thinking?: string; text?: string }>;
+    };
+    expect(assistant.content?.map((block) => block.type)).toEqual(["thinking", "text"]);
+    expect(assistant.content?.[0]?.thinking).toBe("signed");
+    expect(assistant.content?.[1]?.text).toBe("unsigned");
+  });
+
+  it("drops empty unsigned thinking blocks for Google models", async () => {
+    const sessionManager = SessionManager.inMemory();
+    const input = [
+      {
+        role: "user",
+        content: "hi",
+      },
+      {
+        role: "assistant",
+        content: [{ type: "thinking", thinking: "   " }],
+      },
+    ] satisfies AgentMessage[];
+
+    const out = await sanitizeSessionHistory({
+      messages: input,
+      modelApi: "google-antigravity",
+      sessionManager,
+      sessionId: "session:google-empty",
+    });
+
+    const assistant = out.find((msg) => (msg as { role?: string }).role === "assistant");
+    expect(assistant).toBeUndefined();
+  });
+
+  it("keeps thinking blocks for non-Google models", async () => {
+    const sessionManager = SessionManager.inMemory();
+    const input = [
+      {
+        role: "user",
+        content: "hi",
+      },
+      {
+        role: "assistant",
+        content: [{ type: "thinking", thinking: "reasoning" }],
+      },
+    ] satisfies AgentMessage[];
+
+    const out = await sanitizeSessionHistory({
+      messages: input,
+      modelApi: "openai",
+      sessionManager,
+      sessionId: "session:openai",
+    });
+
+    const assistant = out.find((msg) => (msg as { role?: string }).role === "assistant") as {
+      content?: Array<{ type?: string }>;
+    };
+    expect(assistant.content?.map((block) => block.type)).toEqual(["thinking"]);
+  });
+
+  it("sanitizes tool call ids for OpenAI-compatible APIs", async () => {
+    const sessionManager = SessionManager.inMemory();
+    const longId = `call_${"a".repeat(60)}`;
+    const input = [
+      {
+        role: "assistant",
+        content: [{ type: "toolCall", id: longId, name: "read", arguments: {} }],
+      },
+      {
+        role: "toolResult",
+        toolCallId: longId,
+        toolName: "read",
+        content: [{ type: "text", text: "ok" }],
+      },
+    ] satisfies AgentMessage[];
+
+    const out = await sanitizeSessionHistory({
+      messages: input,
+      modelApi: "openai-responses",
+      sessionManager,
+      sessionId: "session:openai",
+    });
+
+    const assistant = out[0] as Extract<AgentMessage, { role: "assistant" }>;
+    const toolCall = assistant.content?.[0] as { id?: string };
+    expect(toolCall.id).toBeDefined();
+    expect(toolCall.id?.length).toBeLessThanOrEqual(40);
+
+    const toolResult = out[1] as Extract<AgentMessage, { role: "toolResult" }>;
+    expect(toolResult.toolCallId).toBe(toolCall.id);
+  });
+});
diff --git a/src/agents/pi-embedded-runner/run/payloads.test.ts b/src/agents/pi-embedded-runner/run/payloads.test.ts
new file mode 100644
index 000000000..934620c6c
--- /dev/null
+++ b/src/agents/pi-embedded-runner/run/payloads.test.ts
@@ -0,0 +1,114 @@
+import type { AssistantMessage } from "@mariozechner/pi-ai";
+import { describe, expect, it } from "vitest";
+import { buildEmbeddedRunPayloads } from "./payloads.js";
+
+describe("buildEmbeddedRunPayloads", () => {
+  const errorJson =
+    '{"type":"error","error":{"details":null,"type":"overloaded_error","message":"Overloaded"},"request_id":"req_011CX7DwS7tSvggaNHmefwWg"}';
+  const errorJsonPretty = `{
+  "type": "error",
+  "error": {
+    "details": null,
+    "type": "overloaded_error",
+    "message": "Overloaded"
+  },
+  "request_id": "req_011CX7DwS7tSvggaNHmefwWg"
+}`;
+  const makeAssistant = (overrides: Partial<AssistantMessage>): AssistantMessage =>
+    ({
+      stopReason: "error",
+      errorMessage: errorJson,
+      content: [{ type: "text", text: errorJson }],
+      ...overrides,
+    }) as AssistantMessage;
+
+  it("suppresses raw API error JSON when the assistant errored", () => {
+    const lastAssistant = makeAssistant({});
+    const payloads = buildEmbeddedRunPayloads({
+      assistantTexts: [errorJson],
+      toolMetas: [],
+      lastAssistant,
+      sessionKey: "session:telegram",
+      inlineToolResultsAllowed: false,
+      verboseLevel: "off",
+      reasoningLevel: "off",
+    });
+
+    expect(payloads).toHaveLength(1);
+    expect(payloads[0]?.text).toBe(
+      "The AI service is temporarily overloaded. Please try again in a moment.",
+    );
+    expect(payloads[0]?.isError).toBe(true);
+    expect(payloads.some((payload) => payload.text === errorJson)).toBe(false);
+  });
+
+  it("suppresses pretty-printed error JSON that differs from the errorMessage", () => {
+    const lastAssistant = makeAssistant({ errorMessage: errorJson });
+    const payloads = buildEmbeddedRunPayloads({
+      assistantTexts: [errorJsonPretty],
+      toolMetas: [],
+      lastAssistant,
+      sessionKey: "session:telegram",
+      inlineToolResultsAllowed: true,
+      verboseLevel: "on",
+      reasoningLevel: "off",
+    });
+
+    expect(payloads).toHaveLength(1);
+    expect(payloads[0]?.text).toBe(
+      "The AI service is temporarily overloaded. Please try again in a moment.",
+    );
+    expect(payloads.some((payload) => payload.text === errorJsonPretty)).toBe(false);
+  });
+
+  it("suppresses raw error JSON from fallback assistant text", () => {
+    const lastAssistant = makeAssistant({ content: [{ type: "text", text: errorJsonPretty }] });
+    const payloads = buildEmbeddedRunPayloads({
+      assistantTexts: [],
+      toolMetas: [],
+      lastAssistant,
+      sessionKey: "session:telegram",
+      inlineToolResultsAllowed: false,
+      verboseLevel: "off",
+      reasoningLevel: "off",
+    });
+
+    expect(payloads).toHaveLength(1);
+    expect(payloads[0]?.text).toBe(
+      "The AI service is temporarily overloaded. Please try again in a moment.",
+    );
+    expect(payloads.some((payload) => payload.text?.includes("request_id"))).toBe(false);
+  });
+
+  it("suppresses raw error JSON even when errorMessage is missing", () => {
+    const lastAssistant = makeAssistant({ errorMessage: undefined });
+    const payloads = buildEmbeddedRunPayloads({
+      assistantTexts: [errorJsonPretty],
+      toolMetas: [],
+      lastAssistant,
+      sessionKey: "session:telegram",
+      inlineToolResultsAllowed: false,
+      verboseLevel: "off",
+      reasoningLevel: "off",
+    });
+
+    expect(payloads).toHaveLength(1);
+    expect(payloads[0]?.isError).toBe(true);
+    expect(payloads.some((payload) => payload.text?.includes("request_id"))).toBe(false);
+  });
+
+  it("does not suppress error-shaped JSON when the assistant did not error", () => {
+    const payloads = buildEmbeddedRunPayloads({
+      assistantTexts: [errorJsonPretty],
+      toolMetas: [],
+      lastAssistant: { stopReason: "end_turn" } as AssistantMessage,
+      sessionKey: "session:telegram",
+      inlineToolResultsAllowed: false,
+      verboseLevel: "off",
+      reasoningLevel: "off",
+    });
+
+    expect(payloads).toHaveLength(1);
+    expect(payloads[0]?.text).toBe(errorJsonPretty.trim());
+  });
+});
diff --git a/src/agents/subagent-announce.format.test.ts b/src/agents/subagent-announce.format.test.ts
new file mode 100644
index 000000000..b8adc0ca8
--- /dev/null
+++ b/src/agents/subagent-announce.format.test.ts
@@ -0,0 +1,103 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const sendSpy = vi.fn(async () => ({}));
+
+vi.mock("../gateway/call.js", () => ({
+  callGateway: vi.fn(async (req: unknown) => {
+    const typed = req as { method?: string; params?: { message?: string } };
+    if (typed.method === "send") {
+      return await sendSpy(typed);
+    }
+    if (typed.method === "agent.wait") {
+      return { status: "error", startedAt: 10, endedAt: 20, error: "boom" };
+    }
+    if (typed.method === "sessions.patch") return {};
+    if (typed.method === "sessions.delete") return {};
+    return {};
+  }),
+}));
+
+vi.mock("./tools/agent-step.js", () => ({
+  runAgentStep: vi.fn(async () => "did some stuff"),
+  readLatestAssistantReply: vi.fn(async () => "raw subagent reply"),
+}));
+
+vi.mock("./tools/sessions-announce-target.js", () => ({
+  resolveAnnounceTarget: vi.fn(async () => ({
+    provider: "telegram",
+    to: "+15550001111",
+    accountId: "default",
+  })),
+}));
+
+vi.mock("./tools/sessions-send-helpers.js", () => ({
+  isAnnounceSkip: () => false,
+}));
+
+vi.mock("../config/sessions.js", () => ({
+  loadSessionStore: vi.fn(async () => ({ entries: {} })),
+  resolveAgentIdFromSessionKey: () => "main",
+  resolveStorePath: () => "/tmp/sessions.json",
+}));
+
+vi.mock("../config/config.js", () => ({
+  loadConfig: () => ({
+    session: { mainKey: "agent:main:main" },
+  }),
+}));
+
+describe("subagent announce formatting", () => {
+  beforeEach(() => {
+    sendSpy.mockClear();
+  });
+
+  it("wraps unstructured announce into Status/Result/Notes", async () => {
+    const { runSubagentAnnounceFlow } = await import("./subagent-announce.js");
+    await runSubagentAnnounceFlow({
+      childSessionKey: "agent:main:subagent:test",
+      childRunId: "run-123",
+      requesterSessionKey: "agent:main:main",
+      requesterDisplayKey: "main",
+      task: "do thing",
+      timeoutMs: 1000,
+      cleanup: "keep",
+      waitForCompletion: true,
+      startedAt: 10,
+      endedAt: 20,
+    });
+
+    expect(sendSpy).toHaveBeenCalled();
+    const msg = sendSpy.mock.calls[0]?.[0]?.params?.message as string;
+    expect(msg).toContain("Status:");
+    expect(msg).toContain("Status: error");
+    expect(msg).toContain("Result:");
+    expect(msg).toContain("Notes:");
+    expect(msg).toContain("boom");
+  });
+
+  it("keeps runtime status even when announce reply is structured", async () => {
+    const agentStep = await import("./tools/agent-step.js");
+    vi.mocked(agentStep.runAgentStep).mockResolvedValueOnce(
+      "- **Status:** success\n\n- **Result:** did some stuff\n\n- **Notes:** all good",
+    );
+
+    const { runSubagentAnnounceFlow } = await import("./subagent-announce.js");
+    await runSubagentAnnounceFlow({
+      childSessionKey: "agent:main:subagent:test",
+      childRunId: "run-456",
+      requesterSessionKey: "agent:main:main",
+      requesterDisplayKey: "main",
+      task: "do thing",
+      timeoutMs: 1000,
+      cleanup: "keep",
+      waitForCompletion: true,
+      startedAt: 10,
+      endedAt: 20,
+    });
+
+    const msg = sendSpy.mock.calls[0]?.[0]?.params?.message as string;
+    expect(msg).toContain("Status: error");
+    expect(msg).toContain("Result:");
+    expect(msg).toContain("Notes:");
+  });
+});
diff --git a/src/agents/system-prompt-report.ts b/src/agents/system-prompt-report.ts
new file mode 100644
index 000000000..e32b1254f
--- /dev/null
+++ b/src/agents/system-prompt-report.ts
@@ -0,0 +1,149 @@
+import type { AgentTool } from "@mariozechner/pi-agent-core";
+
+import type { EmbeddedContextFile } from "./pi-embedded-helpers.js";
+import type { WorkspaceBootstrapFile } from "./workspace.js";
+import type { SessionSystemPromptReport } from "../config/sessions/types.js";
+
+function extractBetween(
+  input: string,
+  startMarker: string,
+  endMarker: string,
+): { text: string; found: boolean } {
+  const start = input.indexOf(startMarker);
+  if (start === -1) return { text: "", found: false };
+  const end = input.indexOf(endMarker, start + startMarker.length);
+  if (end === -1) return { text: input.slice(start), found: true };
+  return { text: input.slice(start, end), found: true };
+}
+
+function parseSkillBlocks(skillsPrompt: string): Array<{ name: string; blockChars: number }> {
+  const prompt = skillsPrompt.trim();
+  if (!prompt) return [];
+  const blocks = Array.from(prompt.matchAll(/<skill>[\s\S]*?<\/skill>/gi)).map(
+    (match) => match[0] ?? "",
+  );
+  return blocks
+    .map((block) => {
+      const name = block.match(/<name>\s*([^<]+?)\s*<\/name>/i)?.[1]?.trim() || "(unknown)";
+      return { name, blockChars: block.length };
+    })
+    .filter((b) => b.blockChars > 0);
+}
+
+function buildInjectedWorkspaceFiles(params: {
+  bootstrapFiles: WorkspaceBootstrapFile[];
+  injectedFiles: EmbeddedContextFile[];
+  bootstrapMaxChars: number;
+}): SessionSystemPromptReport["injectedWorkspaceFiles"] {
+  const injectedByName = new Map(params.injectedFiles.map((f) => [f.path, f.content]));
+  return params.bootstrapFiles.map((file) => {
+    const rawChars = file.missing ? 0 : (file.content ?? "").trimEnd().length;
+    const injected = injectedByName.get(file.name);
+    const injectedChars = injected ? injected.length : 0;
+    const truncated = !file.missing && rawChars > params.bootstrapMaxChars;
+    return {
+      name: file.name,
+      path: file.path,
+      missing: file.missing,
+      rawChars,
+      injectedChars,
+      truncated,
+    };
+  });
+}
+
+function buildToolsEntries(tools: AgentTool[]): SessionSystemPromptReport["tools"]["entries"] {
+  return tools.map((tool) => {
+    const name = tool.name;
+    const summary = tool.description?.trim() || tool.label?.trim() || "";
+    const summaryChars = summary.length;
+    const schemaChars = (() => {
+      if (!tool.parameters || typeof tool.parameters !== "object") return 0;
+      try {
+        return JSON.stringify(tool.parameters).length;
+      } catch {
+        return 0;
+      }
+    })();
+    const propertiesCount = (() => {
+      const schema =
+        tool.parameters && typeof tool.parameters === "object"
+          ? (tool.parameters as Record<string, unknown>)
+          : null;
+      const props = schema && typeof schema.properties === "object" ? schema.properties : null;
+      if (!props || typeof props !== "object") return null;
+      return Object.keys(props as Record<string, unknown>).length;
+    })();
+    return { name, summaryChars, schemaChars, propertiesCount };
+  });
+}
+
+function extractToolListText(systemPrompt: string): string {
+  const markerA = "Tool names are case-sensitive. Call tools exactly as listed.\n";
+  const markerB =
+    "\nTOOLS.md does not control tool availability; it is user guidance for how to use external tools.";
+  const extracted = extractBetween(systemPrompt, markerA, markerB);
+  if (!extracted.found) return "";
+  return extracted.text.replace(markerA, "").trim();
+}
+
+export function buildSystemPromptReport(params: {
+  source: SessionSystemPromptReport["source"];
+  generatedAt: number;
+  sessionId?: string;
+  sessionKey?: string;
+  provider?: string;
+  model?: string;
+  workspaceDir?: string;
+  bootstrapMaxChars: number;
+  sandbox?: SessionSystemPromptReport["sandbox"];
+  systemPrompt: string;
+  bootstrapFiles: WorkspaceBootstrapFile[];
+  injectedFiles: EmbeddedContextFile[];
+  skillsPrompt: string;
+  tools: AgentTool[];
+}): SessionSystemPromptReport {
+  const systemPrompt = params.systemPrompt.trim();
+  const projectContext = extractBetween(
+    systemPrompt,
+    "\n# Project Context\n",
+    "\n## Silent Replies\n",
+  );
+  const projectContextChars = projectContext.text.length;
+  const toolListText = extractToolListText(systemPrompt);
+  const toolListChars = toolListText.length;
+  const toolsEntries = buildToolsEntries(params.tools);
+  const toolsSchemaChars = toolsEntries.reduce((sum, t) => sum + (t.schemaChars ?? 0), 0);
+  const skillsEntries = parseSkillBlocks(params.skillsPrompt);
+
+  return {
+    source: params.source,
+    generatedAt: params.generatedAt,
+    sessionId: params.sessionId,
+    sessionKey: params.sessionKey,
+    provider: params.provider,
+    model: params.model,
+    workspaceDir: params.workspaceDir,
+    bootstrapMaxChars: params.bootstrapMaxChars,
+    sandbox: params.sandbox,
+    systemPrompt: {
+      chars: systemPrompt.length,
+      projectContextChars,
+      nonProjectContextChars: Math.max(0, systemPrompt.length - projectContextChars),
+    },
+    injectedWorkspaceFiles: buildInjectedWorkspaceFiles({
+      bootstrapFiles: params.bootstrapFiles,
+      injectedFiles: params.injectedFiles,
+      bootstrapMaxChars: params.bootstrapMaxChars,
+    }),
+    skills: {
+      promptChars: params.skillsPrompt.length,
+      entries: skillsEntries,
+    },
+    tools: {
+      listChars: toolListChars,
+      schemaChars: toolsSchemaChars,
+      entries: toolsEntries,
+    },
+  };
+}
diff --git a/src/agents/tools/web-tools.ts b/src/agents/tools/web-tools.ts
new file mode 100644
index 000000000..53370478f
--- /dev/null
+++ b/src/agents/tools/web-tools.ts
@@ -0,0 +1,483 @@
+import { Type } from "@sinclair/typebox";
+
+import type { ClawdbotConfig } from "../../config/config.js";
+import { VERSION } from "../../version.js";
+import { stringEnum } from "../schema/typebox.js";
+import type { AnyAgentTool } from "./common.js";
+import { jsonResult, readNumberParam, readStringParam } from "./common.js";
+
+const SEARCH_PROVIDERS = ["brave"] as const;
+const EXTRACT_MODES = ["markdown", "text"] as const;
+
+const DEFAULT_SEARCH_COUNT = 5;
+const MAX_SEARCH_COUNT = 10;
+const DEFAULT_FETCH_MAX_CHARS = 50_000;
+const DEFAULT_TIMEOUT_SECONDS = 30;
+const DEFAULT_CACHE_TTL_MINUTES = 15;
+const DEFAULT_CACHE_MAX_ENTRIES = 100;
+
+const BRAVE_SEARCH_ENDPOINT = "https://api.search.brave.com/res/v1/web/search";
+
+type WebSearchConfig = NonNullable<ClawdbotConfig["tools"]>["web"] extends infer Web
+  ? Web extends { search?: infer Search }
+    ? Search
+    : undefined
+  : undefined;
+
+type WebFetchConfig = NonNullable<ClawdbotConfig["tools"]>["web"] extends infer Web
+  ? Web extends { fetch?: infer Fetch }
+    ? Fetch
+    : undefined
+  : undefined;
+
+type CacheEntry<T> = {
+  value: T;
+  expiresAt: number;
+  insertedAt: number;
+};
+
+const SEARCH_CACHE = new Map<string, CacheEntry<Record<string, unknown>>>();
+const FETCH_CACHE = new Map<string, CacheEntry<Record<string, unknown>>>();
+
+const WebSearchSchema = Type.Object({
+  query: Type.String({ description: "Search query string." }),
+  count: Type.Optional(
+    Type.Number({
+      description: "Number of results to return (1-10).",
+      minimum: 1,
+      maximum: MAX_SEARCH_COUNT,
+    }),
+  ),
+});
+
+const WebFetchSchema = Type.Object({
+  url: Type.String({ description: "HTTP or HTTPS URL to fetch." }),
+  extractMode: Type.Optional(
+    stringEnum(EXTRACT_MODES, {
+      description: 'Extraction mode ("markdown" or "text").',
+      default: "markdown",
+    }),
+  ),
+  maxChars: Type.Optional(
+    Type.Number({
+      description: "Maximum characters to return (truncates when exceeded).",
+      minimum: 100,
+    }),
+  ),
+});
+
+type BraveSearchResult = {
+  title?: string;
+  url?: string;
+  description?: string;
+  age?: string;
+};
+
+type BraveSearchResponse = {
+  web?: {
+    results?: BraveSearchResult[];
+  };
+};
+
+function resolveSearchConfig(cfg?: ClawdbotConfig): WebSearchConfig {
+  const search = cfg?.tools?.web?.search;
+  if (!search || typeof search !== "object") return undefined;
+  return search as WebSearchConfig;
+}
+
+function resolveFetchConfig(cfg?: ClawdbotConfig): WebFetchConfig {
+  const fetch = cfg?.tools?.web?.fetch;
+  if (!fetch || typeof fetch !== "object") return undefined;
+  return fetch as WebFetchConfig;
+}
+
+function resolveSearchEnabled(params: { search?: WebSearchConfig; sandboxed?: boolean }): boolean {
+  if (typeof params.search?.enabled === "boolean") return params.search.enabled;
+  if (params.sandboxed) return true;
+  return true;
+}
+
+function resolveFetchEnabled(params: { fetch?: WebFetchConfig; sandboxed?: boolean }): boolean {
+  if (typeof params.fetch?.enabled === "boolean") return params.fetch.enabled;
+  if (params.sandboxed) return true;
+  return false;
+}
+
+function resolveSearchApiKey(search?: WebSearchConfig): string | undefined {
+  const fromConfig =
+    search && "apiKey" in search && typeof search.apiKey === "string" ? search.apiKey.trim() : "";
+  const fromEnv = (process.env.BRAVE_API_KEY ?? "").trim();
+  return fromConfig || fromEnv || undefined;
+}
+
+function missingSearchKeyPayload() {
+  return {
+    error: "missing_brave_api_key",
+    message:
+      "web_search needs a Brave Search API key. Run `clawdbot configure --section web` to store it, or set BRAVE_API_KEY in the Gateway environment.",
+    docs: "https://docs.clawd.bot/tools/web",
+  };
+}
+
+function resolveSearchProvider(search?: WebSearchConfig): (typeof SEARCH_PROVIDERS)[number] {
+  const raw =
+    search && "provider" in search && typeof search.provider === "string"
+      ? search.provider.trim().toLowerCase()
+      : "";
+  if (raw === "brave") return "brave";
+  return "brave";
+}
+
+function resolveTimeoutSeconds(value: unknown, fallback: number): number {
+  const parsed = typeof value === "number" && Number.isFinite(value) ? value : fallback;
+  return Math.max(1, Math.floor(parsed));
+}
+
+function resolveCacheTtlMs(value: unknown, fallbackMinutes: number): number {
+  const minutes =
+    typeof value === "number" && Number.isFinite(value) ? Math.max(0, value) : fallbackMinutes;
+  return Math.round(minutes * 60_000);
+}
+
+function resolveMaxChars(value: unknown, fallback: number): number {
+  const parsed = typeof value === "number" && Number.isFinite(value) ? value : fallback;
+  return Math.max(100, Math.floor(parsed));
+}
+
+function resolveSearchCount(value: unknown, fallback: number): number {
+  const parsed = typeof value === "number" && Number.isFinite(value) ? value : fallback;
+  const clamped = Math.max(1, Math.min(MAX_SEARCH_COUNT, Math.floor(parsed)));
+  return clamped;
+}
+
+function normalizeCacheKey(value: string): string {
+  return value.trim().toLowerCase();
+}
+
+function readCache<T>(
+  cache: Map<string, CacheEntry<T>>,
+  key: string,
+): { value: T; cached: boolean } | null {
+  const entry = cache.get(key);
+  if (!entry) return null;
+  if (Date.now() > entry.expiresAt) {
+    cache.delete(key);
+    return null;
+  }
+  return { value: entry.value, cached: true };
+}
+
+function writeCache<T>(cache: Map<string, CacheEntry<T>>, key: string, value: T, ttlMs: number) {
+  if (ttlMs <= 0) return;
+  if (cache.size >= DEFAULT_CACHE_MAX_ENTRIES) {
+    const oldest = cache.keys().next();
+    if (!oldest.done) cache.delete(oldest.value);
+  }
+  cache.set(key, {
+    value,
+    expiresAt: Date.now() + ttlMs,
+    insertedAt: Date.now(),
+  });
+}
+
+function withTimeout(signal: AbortSignal | undefined, timeoutMs: number): AbortSignal {
+  if (timeoutMs <= 0) return signal ?? new AbortController().signal;
+  const controller = new AbortController();
+  const timer = setTimeout(() => controller.abort(), timeoutMs);
+  if (signal) {
+    signal.addEventListener(
+      "abort",
+      () => {
+        clearTimeout(timer);
+        controller.abort();
+      },
+      { once: true },
+    );
+  }
+  controller.signal.addEventListener(
+    "abort",
+    () => {
+      clearTimeout(timer);
+    },
+    { once: true },
+  );
+  return controller.signal;
+}
+
+function decodeEntities(value: string): string {
+  return value
+    .replace(/&nbsp;/gi, " ")
+    .replace(/&amp;/gi, "&")
+    .replace(/&quot;/gi, '"')
+    .replace(/&#39;/gi, "'")
+    .replace(/&lt;/gi, "<")
+    .replace(/&gt;/gi, ">")
+    .replace(/&#x([0-9a-f]+);/gi, (_, hex) => String.fromCharCode(Number.parseInt(hex, 16)))
+    .replace(/&#(\d+);/gi, (_, dec) => String.fromCharCode(Number.parseInt(dec, 10)));
+}
+
+function stripTags(value: string): string {
+  return decodeEntities(value.replace(/<[^>]+>/g, ""));
+}
+
+function normalizeWhitespace(value: string): string {
+  return value
+    .replace(/\r/g, "")
+    .replace(/[ \t]+\n/g, "\n")
+    .replace(/\n{3,}/g, "\n\n")
+    .replace(/[ \t]{2,}/g, " ")
+    .trim();
+}
+
+function htmlToMarkdown(html: string): { text: string; title?: string } {
+  const titleMatch = html.match(/<title[^>]*>([\s\S]*?)<\/title>/i);
+  const title = titleMatch ? normalizeWhitespace(stripTags(titleMatch[1])) : undefined;
+  let text = html
+    .replace(/<script[\s\S]*?<\/script>/gi, "")
+    .replace(/<style[\s\S]*?<\/style>/gi, "")
+    .replace(/<noscript[\s\S]*?<\/noscript>/gi, "");
+  text = text.replace(/<a\s+[^>]*href=["']([^"']+)["'][^>]*>([\s\S]*?)<\/a>/gi, (_, href, body) => {
+    const label = normalizeWhitespace(stripTags(body));
+    if (!label) return href;
+    return `[${label}](${href})`;
+  });
+  text = text.replace(/<h([1-6])[^>]*>([\s\S]*?)<\/h\1>/gi, (_, level, body) => {
+    const prefix = "#".repeat(Math.max(1, Math.min(6, Number.parseInt(level, 10))));
+    const label = normalizeWhitespace(stripTags(body));
+    return `\n${prefix} ${label}\n`;
+  });
+  text = text.replace(/<li[^>]*>([\s\S]*?)<\/li>/gi, (_, body) => {
+    const label = normalizeWhitespace(stripTags(body));
+    return label ? `\n- ${label}` : "";
+  });
+  text = text
+    .replace(/<(br|hr)\s*\/?>/gi, "\n")
+    .replace(/<\/(p|div|section|article|header|footer|table|tr|ul|ol)>/gi, "\n");
+  text = stripTags(text);
+  text = normalizeWhitespace(text);
+  return { text, title };
+}
+
+function htmlToText(html: string): { text: string; title?: string } {
+  const { text, title } = htmlToMarkdown(html);
+  return { text, title };
+}
+
+function truncateText(value: string, maxChars: number): { text: string; truncated: boolean } {
+  if (value.length <= maxChars) return { text: value, truncated: false };
+  return { text: value.slice(0, maxChars), truncated: true };
+}
+
+function resolveSiteName(url: string | undefined): string | undefined {
+  if (!url) return undefined;
+  try {
+    return new URL(url).hostname;
+  } catch {
+    return undefined;
+  }
+}
+
+async function readResponseText(res: Response): Promise<string> {
+  try {
+    return await res.text();
+  } catch {
+    return "";
+  }
+}
+
+async function runWebSearch(params: {
+  query: string;
+  count: number;
+  apiKey: string;
+  timeoutSeconds: number;
+  cacheTtlMs: number;
+  provider: (typeof SEARCH_PROVIDERS)[number];
+}): Promise<Record<string, unknown>> {
+  const cacheKey = normalizeCacheKey(`${params.provider}:${params.query}:${params.count}`);
+  const cached = readCache(SEARCH_CACHE, cacheKey);
+  if (cached) return { ...cached.value, cached: true };
+
+  const start = Date.now();
+  if (params.provider !== "brave") {
+    throw new Error("Unsupported web search provider.");
+  }
+
+  const url = new URL(BRAVE_SEARCH_ENDPOINT);
+  url.searchParams.set("q", params.query);
+  url.searchParams.set("count", String(params.count));
+
+  const res = await fetch(url.toString(), {
+    method: "GET",
+    headers: {
+      Accept: "application/json",
+      "X-Subscription-Token": params.apiKey,
+    },
+    signal: withTimeout(undefined, params.timeoutSeconds * 1000),
+  });
+
+  if (!res.ok) {
+    const detail = await readResponseText(res);
+    throw new Error(`Brave Search API error (${res.status}): ${detail || res.statusText}`);
+  }
+
+  const data = (await res.json()) as BraveSearchResponse;
+  const results = Array.isArray(data.web?.results) ? (data.web?.results ?? []) : [];
+  const mapped = results.map((entry) => ({
+    title: entry.title ?? "",
+    url: entry.url ?? "",
+    description: entry.description ?? "",
+    published: entry.age ?? undefined,
+    siteName: resolveSiteName(entry.url ?? ""),
+  }));
+
+  const payload = {
+    query: params.query,
+    provider: params.provider,
+    count: mapped.length,
+    tookMs: Date.now() - start,
+    results: mapped,
+  };
+  writeCache(SEARCH_CACHE, cacheKey, payload, params.cacheTtlMs);
+  return payload;
+}
+
+async function runWebFetch(params: {
+  url: string;
+  extractMode: (typeof EXTRACT_MODES)[number];
+  maxChars: number;
+  timeoutSeconds: number;
+  cacheTtlMs: number;
+  userAgent: string;
+}): Promise<Record<string, unknown>> {
+  const cacheKey = normalizeCacheKey(
+    `fetch:${params.url}:${params.extractMode}:${params.maxChars}`,
+  );
+  const cached = readCache(FETCH_CACHE, cacheKey);
+  if (cached) return { ...cached.value, cached: true };
+
+  let parsedUrl: URL;
+  try {
+    parsedUrl = new URL(params.url);
+  } catch {
+    throw new Error("Invalid URL: must be http or https");
+  }
+  if (!["http:", "https:"].includes(parsedUrl.protocol)) {
+    throw new Error("Invalid URL: must be http or https");
+  }
+
+  const start = Date.now();
+  const res = await fetch(parsedUrl.toString(), {
+    method: "GET",
+    headers: {
+      Accept: "*/*",
+      "User-Agent": params.userAgent,
+    },
+    signal: withTimeout(undefined, params.timeoutSeconds * 1000),
+  });
+
+  if (!res.ok) {
+    const detail = await readResponseText(res);
+    throw new Error(`Web fetch failed (${res.status}): ${detail || res.statusText}`);
+  }
+
+  const contentType = res.headers.get("content-type") ?? "application/octet-stream";
+  const body = await readResponseText(res);
+
+  let title: string | undefined;
+  let text = body;
+  if (contentType.includes("text/html")) {
+    const parsed = params.extractMode === "text" ? htmlToText(body) : htmlToMarkdown(body);
+    text = parsed.text;
+    title = parsed.title;
+  } else if (contentType.includes("application/json")) {
+    try {
+      text = JSON.stringify(JSON.parse(body), null, 2);
+    } catch {
+      text = body;
+    }
+  }
+
+  const truncated = truncateText(text, params.maxChars);
+  const payload = {
+    url: params.url,
+    finalUrl: res.url || params.url,
+    status: res.status,
+    contentType,
+    title,
+    extractMode: params.extractMode,
+    truncated: truncated.truncated,
+    length: truncated.text.length,
+    fetchedAt: new Date().toISOString(),
+    tookMs: Date.now() - start,
+    text: truncated.text,
+  };
+  writeCache(FETCH_CACHE, cacheKey, payload, params.cacheTtlMs);
+  return payload;
+}
+
+export function createWebSearchTool(options?: {
+  config?: ClawdbotConfig;
+  sandboxed?: boolean;
+}): AnyAgentTool | null {
+  const search = resolveSearchConfig(options?.config);
+  if (!resolveSearchEnabled({ search, sandboxed: options?.sandboxed })) return null;
+  return {
+    label: "Web Search",
+    name: "web_search",
+    description:
+      "Search the web using Brave Search API. Returns titles, URLs, and snippets for fast research.",
+    parameters: WebSearchSchema,
+    execute: async (_toolCallId, args) => {
+      const apiKey = resolveSearchApiKey(search);
+      if (!apiKey) {
+        return jsonResult(missingSearchKeyPayload());
+      }
+      const params = args as Record<string, unknown>;
+      const query = readStringParam(params, "query", { required: true });
+      const count =
+        readNumberParam(params, "count", { integer: true }) ?? search?.maxResults ?? undefined;
+      const result = await runWebSearch({
+        query,
+        count: resolveSearchCount(count, DEFAULT_SEARCH_COUNT),
+        apiKey,
+        timeoutSeconds: resolveTimeoutSeconds(search?.timeoutSeconds, DEFAULT_TIMEOUT_SECONDS),
+        cacheTtlMs: resolveCacheTtlMs(search?.cacheTtlMinutes, DEFAULT_CACHE_TTL_MINUTES),
+        provider: resolveSearchProvider(search),
+      });
+      return jsonResult(result);
+    },
+  };
+}
+
+export function createWebFetchTool(options?: {
+  config?: ClawdbotConfig;
+  sandboxed?: boolean;
+}): AnyAgentTool | null {
+  const fetch = resolveFetchConfig(options?.config);
+  if (!resolveFetchEnabled({ fetch, sandboxed: options?.sandboxed })) return null;
+  const userAgent =
+    (fetch && "userAgent" in fetch && typeof fetch.userAgent === "string" && fetch.userAgent) ||
+    `clawdbot/${VERSION}`;
+  return {
+    label: "Web Fetch",
+    name: "web_fetch",
+    description:
+      "Fetch and extract readable content from a URL (HTML → markdown/text). Use for lightweight page access without browser automation.",
+    parameters: WebFetchSchema,
+    execute: async (_toolCallId, args) => {
+      const params = args as Record<string, unknown>;
+      const url = readStringParam(params, "url", { required: true });
+      const extractMode = readStringParam(params, "extractMode") === "text" ? "text" : "markdown";
+      const maxChars = readNumberParam(params, "maxChars", { integer: true });
+      const result = await runWebFetch({
+        url,
+        extractMode,
+        maxChars: resolveMaxChars(maxChars ?? fetch?.maxChars, DEFAULT_FETCH_MAX_CHARS),
+        timeoutSeconds: resolveTimeoutSeconds(fetch?.timeoutSeconds, DEFAULT_TIMEOUT_SECONDS),
+        cacheTtlMs: resolveCacheTtlMs(fetch?.cacheTtlMinutes, DEFAULT_CACHE_TTL_MINUTES),
+        userAgent,
+      });
+      return jsonResult(result);
+    },
+  };
+}
diff --git a/src/auto-reply/reply/commands-config-writes.test.ts b/src/auto-reply/reply/commands-config-writes.test.ts
new file mode 100644
index 000000000..7c55c3a01
--- /dev/null
+++ b/src/auto-reply/reply/commands-config-writes.test.ts
@@ -0,0 +1,57 @@
+import { describe, expect, it } from "vitest";
+
+import type { ClawdbotConfig } from "../../config/config.js";
+import type { MsgContext } from "../templating.js";
+import { buildCommandContext, handleCommands } from "./commands.js";
+import { parseInlineDirectives } from "./directive-handling.js";
+
+function buildParams(commandBody: string, cfg: ClawdbotConfig, ctxOverrides?: Partial<MsgContext>) {
+  const ctx = {
+    Body: commandBody,
+    CommandBody: commandBody,
+    CommandSource: "text",
+    CommandAuthorized: true,
+    Provider: "whatsapp",
+    Surface: "whatsapp",
+    ...ctxOverrides,
+  } as MsgContext;
+
+  const command = buildCommandContext({
+    ctx,
+    cfg,
+    isGroup: false,
+    triggerBodyNormalized: commandBody.trim().toLowerCase(),
+    commandAuthorized: true,
+  });
+
+  return {
+    ctx,
+    cfg,
+    command,
+    directives: parseInlineDirectives(commandBody),
+    elevated: { enabled: true, allowed: true, failures: [] },
+    sessionKey: "agent:main:main",
+    workspaceDir: "/tmp",
+    defaultGroupActivation: () => "mention",
+    resolvedVerboseLevel: "off" as const,
+    resolvedReasoningLevel: "off" as const,
+    resolveDefaultThinkingLevel: async () => undefined,
+    provider: "whatsapp",
+    model: "test-model",
+    contextTokens: 0,
+    isGroup: false,
+  };
+}
+
+describe("handleCommands /config configWrites gating", () => {
+  it("blocks /config set when channel config writes are disabled", async () => {
+    const cfg = {
+      commands: { config: true, text: true },
+      channels: { whatsapp: { allowFrom: ["*"], configWrites: false } },
+    } as ClawdbotConfig;
+    const params = buildParams('/config set messages.ackReaction=":)"', cfg);
+    const result = await handleCommands(params);
+    expect(result.shouldContinue).toBe(false);
+    expect(result.reply?.text).toContain("Config writes are disabled");
+  });
+});
diff --git a/src/auto-reply/reply/commands-context-report.ts b/src/auto-reply/reply/commands-context-report.ts
new file mode 100644
index 000000000..a10c1f4fa
--- /dev/null
+++ b/src/auto-reply/reply/commands-context-report.ts
@@ -0,0 +1,303 @@
+import {
+  buildBootstrapContextFiles,
+  resolveBootstrapMaxChars,
+} from "../../agents/pi-embedded-helpers.js";
+import { createClawdbotCodingTools } from "../../agents/pi-tools.js";
+import { resolveSandboxRuntimeStatus } from "../../agents/sandbox.js";
+import { buildWorkspaceSkillSnapshot } from "../../agents/skills.js";
+import { buildAgentSystemPrompt } from "../../agents/system-prompt.js";
+import { buildSystemPromptReport } from "../../agents/system-prompt-report.js";
+import { buildToolSummaryMap } from "../../agents/tool-summaries.js";
+import {
+  filterBootstrapFilesForSession,
+  loadWorkspaceBootstrapFiles,
+} from "../../agents/workspace.js";
+import type { SessionSystemPromptReport } from "../../config/sessions/types.js";
+import type { ReplyPayload } from "../types.js";
+import type { HandleCommandsParams } from "./commands-types.js";
+
+function estimateTokensFromChars(chars: number): number {
+  return Math.ceil(Math.max(0, chars) / 4);
+}
+
+function formatInt(n: number): string {
+  return new Intl.NumberFormat("en-US").format(n);
+}
+
+function formatCharsAndTokens(chars: number): string {
+  return `${formatInt(chars)} chars (~${formatInt(estimateTokensFromChars(chars))} tok)`;
+}
+
+function parseContextArgs(commandBodyNormalized: string): string {
+  if (commandBodyNormalized === "/context") return "";
+  if (commandBodyNormalized.startsWith("/context ")) return commandBodyNormalized.slice(8).trim();
+  return "";
+}
+
+function formatListTop(
+  entries: Array<{ name: string; value: number }>,
+  cap: number,
+): { lines: string[]; omitted: number } {
+  const sorted = [...entries].sort((a, b) => b.value - a.value);
+  const top = sorted.slice(0, cap);
+  const omitted = Math.max(0, sorted.length - top.length);
+  const lines = top.map((e) => `- ${e.name}: ${formatCharsAndTokens(e.value)}`);
+  return { lines, omitted };
+}
+
+async function resolveContextReport(
+  params: HandleCommandsParams,
+): Promise<SessionSystemPromptReport> {
+  const existing = params.sessionEntry?.systemPromptReport;
+  if (existing && existing.source === "run") return existing;
+
+  const workspaceDir = params.workspaceDir;
+  const bootstrapMaxChars = resolveBootstrapMaxChars(params.cfg);
+  const bootstrapFiles = filterBootstrapFilesForSession(
+    await loadWorkspaceBootstrapFiles(workspaceDir),
+    params.sessionKey,
+  );
+  const injectedFiles = buildBootstrapContextFiles(bootstrapFiles, {
+    maxChars: bootstrapMaxChars,
+  });
+  const skillsSnapshot = (() => {
+    try {
+      return buildWorkspaceSkillSnapshot(workspaceDir, { config: params.cfg });
+    } catch {
+      return { prompt: "", skills: [], resolvedSkills: [] };
+    }
+  })();
+  const skillsPrompt = skillsSnapshot.prompt ?? "";
+  const sandboxRuntime = resolveSandboxRuntimeStatus({
+    cfg: params.cfg,
+    sessionKey: params.ctx.SessionKey ?? params.sessionKey,
+  });
+  const tools = (() => {
+    try {
+      return createClawdbotCodingTools({
+        config: params.cfg,
+        workspaceDir,
+        sessionKey: params.sessionKey,
+        messageProvider: params.command.channel,
+        modelProvider: params.provider,
+        modelId: params.model,
+      });
+    } catch {
+      return [];
+    }
+  })();
+  const toolSummaries = buildToolSummaryMap(tools);
+  const toolNames = tools.map((t) => t.name);
+  const runtimeInfo = {
+    host: "unknown",
+    os: "unknown",
+    arch: "unknown",
+    node: process.version,
+    model: `${params.provider}/${params.model}`,
+  };
+  const sandboxInfo = sandboxRuntime.sandboxed
+    ? {
+        enabled: true,
+        workspaceDir,
+        workspaceAccess: "rw" as const,
+        elevated: {
+          allowed: params.elevated.allowed,
+          defaultLevel: params.resolvedElevatedLevel === "off" ? ("off" as const) : ("on" as const),
+        },
+      }
+    : { enabled: false };
+
+  const systemPrompt = buildAgentSystemPrompt({
+    workspaceDir,
+    defaultThinkLevel: params.resolvedThinkLevel,
+    reasoningLevel: params.resolvedReasoningLevel,
+    extraSystemPrompt: undefined,
+    ownerNumbers: undefined,
+    reasoningTagHint: false,
+    toolNames,
+    toolSummaries,
+    modelAliasLines: [],
+    userTimezone: "",
+    userTime: "",
+    contextFiles: injectedFiles,
+    skillsPrompt,
+    heartbeatPrompt: undefined,
+    runtimeInfo,
+    sandboxInfo,
+  });
+
+  return buildSystemPromptReport({
+    source: "estimate",
+    generatedAt: Date.now(),
+    sessionId: params.sessionEntry?.sessionId,
+    sessionKey: params.sessionKey,
+    provider: params.provider,
+    model: params.model,
+    workspaceDir,
+    bootstrapMaxChars,
+    sandbox: { mode: sandboxRuntime.mode, sandboxed: sandboxRuntime.sandboxed },
+    systemPrompt,
+    bootstrapFiles,
+    injectedFiles,
+    skillsPrompt,
+    tools,
+  });
+}
+
+export async function buildContextReply(params: HandleCommandsParams): Promise<ReplyPayload> {
+  const args = parseContextArgs(params.command.commandBodyNormalized);
+  const sub = args.split(/\s+/).filter(Boolean)[0]?.toLowerCase() ?? "";
+
+  if (!sub || sub === "help") {
+    return {
+      text: [
+        "🧠 /context",
+        "",
+        "What counts as context (high-level), plus a breakdown mode.",
+        "",
+        "Try:",
+        "- /context list   (short breakdown)",
+        "- /context detail (per-file + per-tool + per-skill + system prompt size)",
+        "- /context json   (same, machine-readable)",
+        "",
+        "Inline shortcut = a command token inside a normal message (e.g. “hey /status”). It runs immediately (allowlisted senders only) and is stripped before the model sees the remaining text.",
+      ].join("\n"),
+    };
+  }
+
+  const report = await resolveContextReport(params);
+  const session = {
+    totalTokens: params.sessionEntry?.totalTokens ?? null,
+    inputTokens: params.sessionEntry?.inputTokens ?? null,
+    outputTokens: params.sessionEntry?.outputTokens ?? null,
+    contextTokens: params.contextTokens ?? null,
+  } as const;
+
+  if (sub === "json") {
+    return { text: JSON.stringify({ report, session }, null, 2) };
+  }
+
+  if (sub !== "list" && sub !== "show" && sub !== "detail" && sub !== "deep") {
+    return {
+      text: [
+        "Unknown /context mode.",
+        "Use: /context, /context list, /context detail, or /context json",
+      ].join("\n"),
+    };
+  }
+
+  const fileLines = report.injectedWorkspaceFiles.map((f) => {
+    const status = f.missing ? "MISSING" : f.truncated ? "TRUNCATED" : "OK";
+    const raw = f.missing ? "0" : formatCharsAndTokens(f.rawChars);
+    const injected = f.missing ? "0" : formatCharsAndTokens(f.injectedChars);
+    return `- ${f.name}: ${status} | raw ${raw} | injected ${injected}`;
+  });
+
+  const sandboxLine = `Sandbox: mode=${report.sandbox?.mode ?? "unknown"} sandboxed=${report.sandbox?.sandboxed ?? false}`;
+  const toolSchemaLine = `Tool schemas (JSON): ${formatCharsAndTokens(report.tools.schemaChars)} (counts toward context; not shown as text)`;
+  const toolListLine = `Tool list (system prompt text): ${formatCharsAndTokens(report.tools.listChars)}`;
+  const skillNameSet = new Set(report.skills.entries.map((s) => s.name));
+  const skillNames = Array.from(skillNameSet);
+  const toolNames = report.tools.entries.map((t) => t.name);
+  const formatNameList = (names: string[], cap: number) =>
+    names.length <= cap
+      ? names.join(", ")
+      : `${names.slice(0, cap).join(", ")}, … (+${names.length - cap} more)`;
+  const skillsLine = `Skills list (system prompt text): ${formatCharsAndTokens(report.skills.promptChars)} (${skillNameSet.size} skills)`;
+  const skillsNamesLine = skillNameSet.size
+    ? `Skills: ${formatNameList(skillNames, 20)}`
+    : "Skills: (none)";
+  const toolsNamesLine = toolNames.length
+    ? `Tools: ${formatNameList(toolNames, 30)}`
+    : "Tools: (none)";
+  const systemPromptLine = `System prompt (${report.source}): ${formatCharsAndTokens(report.systemPrompt.chars)} (Project Context ${formatCharsAndTokens(report.systemPrompt.projectContextChars)})`;
+  const workspaceLabel = report.workspaceDir ?? params.workspaceDir;
+  const bootstrapMaxLabel =
+    typeof report.bootstrapMaxChars === "number"
+      ? `${formatInt(report.bootstrapMaxChars)} chars`
+      : "? chars";
+
+  const totalsLine =
+    session.totalTokens != null
+      ? `Session tokens (cached): ${formatInt(session.totalTokens)} total / ctx=${session.contextTokens ?? "?"}`
+      : `Session tokens (cached): unknown / ctx=${session.contextTokens ?? "?"}`;
+
+  if (sub === "detail" || sub === "deep") {
+    const perSkill = formatListTop(
+      report.skills.entries.map((s) => ({ name: s.name, value: s.blockChars })),
+      30,
+    );
+    const perToolSchema = formatListTop(
+      report.tools.entries.map((t) => ({ name: t.name, value: t.schemaChars })),
+      30,
+    );
+    const perToolSummary = formatListTop(
+      report.tools.entries.map((t) => ({ name: t.name, value: t.summaryChars })),
+      30,
+    );
+    const toolPropsLines = report.tools.entries
+      .filter((t) => t.propertiesCount != null)
+      .sort((a, b) => (b.propertiesCount ?? 0) - (a.propertiesCount ?? 0))
+      .slice(0, 30)
+      .map((t) => `- ${t.name}: ${t.propertiesCount} params`);
+
+    return {
+      text: [
+        "🧠 Context breakdown (detailed)",
+        `Workspace: ${workspaceLabel}`,
+        `Bootstrap max/file: ${bootstrapMaxLabel}`,
+        sandboxLine,
+        systemPromptLine,
+        "",
+        "Injected workspace files:",
+        ...fileLines,
+        "",
+        skillsLine,
+        skillsNamesLine,
+        ...(perSkill.lines.length ? ["Top skills (prompt entry size):", ...perSkill.lines] : []),
+        ...(perSkill.omitted ? [`… (+${perSkill.omitted} more skills)`] : []),
+        "",
+        toolListLine,
+        toolSchemaLine,
+        toolsNamesLine,
+        "Top tools (schema size):",
+        ...perToolSchema.lines,
+        ...(perToolSchema.omitted ? [`… (+${perToolSchema.omitted} more tools)`] : []),
+        "",
+        "Top tools (summary text size):",
+        ...perToolSummary.lines,
+        ...(perToolSummary.omitted ? [`… (+${perToolSummary.omitted} more tools)`] : []),
+        ...(toolPropsLines.length ? ["", "Tools (param count):", ...toolPropsLines] : []),
+        "",
+        totalsLine,
+        "",
+        "Inline shortcut: a command token inside normal text (e.g. “hey /status”) that runs immediately (allowlisted senders only) and is stripped before the model sees the remaining message.",
+      ]
+        .filter(Boolean)
+        .join("\n"),
+    };
+  }
+
+  return {
+    text: [
+      "🧠 Context breakdown",
+      `Workspace: ${workspaceLabel}`,
+      `Bootstrap max/file: ${bootstrapMaxLabel}`,
+      sandboxLine,
+      systemPromptLine,
+      "",
+      "Injected workspace files:",
+      ...fileLines,
+      "",
+      skillsLine,
+      skillsNamesLine,
+      toolListLine,
+      toolSchemaLine,
+      toolsNamesLine,
+      "",
+      totalsLine,
+      "",
+      "Inline shortcut: a command token inside normal text (e.g. “hey /status”) that runs immediately (allowlisted senders only) and is stripped before the model sees the remaining message.",
+    ].join("\n"),
+  };
+}
diff --git a/src/auto-reply/reply/response-prefix-template.test.ts b/src/auto-reply/reply/response-prefix-template.test.ts
new file mode 100644
index 000000000..db899f44d
--- /dev/null
+++ b/src/auto-reply/reply/response-prefix-template.test.ts
@@ -0,0 +1,181 @@
+import { describe, expect, it } from "vitest";
+
+import {
+  extractShortModelName,
+  hasTemplateVariables,
+  resolveResponsePrefixTemplate,
+} from "./response-prefix-template.js";
+
+describe("resolveResponsePrefixTemplate", () => {
+  it("returns undefined for undefined template", () => {
+    expect(resolveResponsePrefixTemplate(undefined, {})).toBeUndefined();
+  });
+
+  it("returns template as-is when no variables present", () => {
+    expect(resolveResponsePrefixTemplate("[Claude]", {})).toBe("[Claude]");
+  });
+
+  it("resolves {model} variable", () => {
+    const result = resolveResponsePrefixTemplate("[{model}]", {
+      model: "gpt-5.2",
+    });
+    expect(result).toBe("[gpt-5.2]");
+  });
+
+  it("resolves {modelFull} variable", () => {
+    const result = resolveResponsePrefixTemplate("[{modelFull}]", {
+      modelFull: "openai-codex/gpt-5.2",
+    });
+    expect(result).toBe("[openai-codex/gpt-5.2]");
+  });
+
+  it("resolves {provider} variable", () => {
+    const result = resolveResponsePrefixTemplate("[{provider}]", {
+      provider: "anthropic",
+    });
+    expect(result).toBe("[anthropic]");
+  });
+
+  it("resolves {thinkingLevel} variable", () => {
+    const result = resolveResponsePrefixTemplate("think:{thinkingLevel}", {
+      thinkingLevel: "high",
+    });
+    expect(result).toBe("think:high");
+  });
+
+  it("resolves {think} as alias for thinkingLevel", () => {
+    const result = resolveResponsePrefixTemplate("think:{think}", {
+      thinkingLevel: "low",
+    });
+    expect(result).toBe("think:low");
+  });
+
+  it("resolves {identity.name} variable", () => {
+    const result = resolveResponsePrefixTemplate("[{identity.name}]", {
+      identityName: "Clawdbot",
+    });
+    expect(result).toBe("[Clawdbot]");
+  });
+
+  it("resolves {identityName} as alias", () => {
+    const result = resolveResponsePrefixTemplate("[{identityName}]", {
+      identityName: "Clawdbot",
+    });
+    expect(result).toBe("[Clawdbot]");
+  });
+
+  it("resolves multiple variables", () => {
+    const result = resolveResponsePrefixTemplate("[{model} | think:{thinkingLevel}]", {
+      model: "claude-opus-4-5",
+      thinkingLevel: "high",
+    });
+    expect(result).toBe("[claude-opus-4-5 | think:high]");
+  });
+
+  it("leaves unresolved variables as-is", () => {
+    const result = resolveResponsePrefixTemplate("[{model}]", {});
+    expect(result).toBe("[{model}]");
+  });
+
+  it("leaves unrecognized variables as-is", () => {
+    const result = resolveResponsePrefixTemplate("[{unknownVar}]", {
+      model: "gpt-5.2",
+    });
+    expect(result).toBe("[{unknownVar}]");
+  });
+
+  it("handles case insensitivity", () => {
+    const result = resolveResponsePrefixTemplate("[{MODEL} | {ThinkingLevel}]", {
+      model: "gpt-5.2",
+      thinkingLevel: "low",
+    });
+    expect(result).toBe("[gpt-5.2 | low]");
+  });
+
+  it("handles mixed resolved and unresolved variables", () => {
+    const result = resolveResponsePrefixTemplate("[{model} | {provider}]", {
+      model: "gpt-5.2",
+      // provider not provided
+    });
+    expect(result).toBe("[gpt-5.2 | {provider}]");
+  });
+
+  it("handles complex template with all variables", () => {
+    const result = resolveResponsePrefixTemplate(
+      "[{identity.name}] {provider}/{model} (think:{thinkingLevel})",
+      {
+        identityName: "Clawdbot",
+        provider: "anthropic",
+        model: "claude-opus-4-5",
+        thinkingLevel: "high",
+      },
+    );
+    expect(result).toBe("[Clawdbot] anthropic/claude-opus-4-5 (think:high)");
+  });
+});
+
+describe("extractShortModelName", () => {
+  it("strips provider prefix", () => {
+    expect(extractShortModelName("openai/gpt-5.2")).toBe("gpt-5.2");
+    expect(extractShortModelName("anthropic/claude-opus-4-5")).toBe("claude-opus-4-5");
+    expect(extractShortModelName("openai-codex/gpt-5.2-codex")).toBe("gpt-5.2-codex");
+  });
+
+  it("strips date suffix", () => {
+    expect(extractShortModelName("claude-opus-4-5-20251101")).toBe("claude-opus-4-5");
+    expect(extractShortModelName("gpt-5.2-20250115")).toBe("gpt-5.2");
+  });
+
+  it("strips -latest suffix", () => {
+    expect(extractShortModelName("gpt-5.2-latest")).toBe("gpt-5.2");
+    expect(extractShortModelName("claude-sonnet-latest")).toBe("claude-sonnet");
+  });
+
+  it("handles model without provider", () => {
+    expect(extractShortModelName("gpt-5.2")).toBe("gpt-5.2");
+    expect(extractShortModelName("claude-opus-4-5")).toBe("claude-opus-4-5");
+  });
+
+  it("handles full path with provider and date suffix", () => {
+    expect(extractShortModelName("anthropic/claude-opus-4-5-20251101")).toBe("claude-opus-4-5");
+  });
+
+  it("preserves version numbers that look like dates but are not", () => {
+    // Date suffix must be exactly 8 digits at the end
+    expect(extractShortModelName("model-v1234567")).toBe("model-v1234567");
+    expect(extractShortModelName("model-123456789")).toBe("model-123456789");
+  });
+});
+
+describe("hasTemplateVariables", () => {
+  it("returns false for undefined", () => {
+    expect(hasTemplateVariables(undefined)).toBe(false);
+  });
+
+  it("returns false for empty string", () => {
+    expect(hasTemplateVariables("")).toBe(false);
+  });
+
+  it("returns false for static prefix", () => {
+    expect(hasTemplateVariables("[Claude]")).toBe(false);
+  });
+
+  it("returns true when template variables present", () => {
+    expect(hasTemplateVariables("[{model}]")).toBe(true);
+    expect(hasTemplateVariables("{provider}")).toBe(true);
+    expect(hasTemplateVariables("prefix {thinkingLevel} suffix")).toBe(true);
+  });
+
+  it("returns true for multiple variables", () => {
+    expect(hasTemplateVariables("[{model} | {provider}]")).toBe(true);
+  });
+
+  it("handles consecutive calls correctly (regex lastIndex reset)", () => {
+    // First call
+    expect(hasTemplateVariables("[{model}]")).toBe(true);
+    // Second call should still work
+    expect(hasTemplateVariables("[{model}]")).toBe(true);
+    // Static string should return false
+    expect(hasTemplateVariables("[Claude]")).toBe(false);
+  });
+});
diff --git a/src/auto-reply/reply/response-prefix-template.ts b/src/auto-reply/reply/response-prefix-template.ts
new file mode 100644
index 000000000..788531ca5
--- /dev/null
+++ b/src/auto-reply/reply/response-prefix-template.ts
@@ -0,0 +1,97 @@
+/**
+ * Template interpolation for response prefix.
+ *
+ * Supports variables like `{model}`, `{provider}`, `{thinkingLevel}`, etc.
+ * Variables are case-insensitive and unresolved ones remain as literal text.
+ */
+
+export type ResponsePrefixContext = {
+  /** Short model name (e.g., "gpt-5.2", "claude-opus-4-5") */
+  model?: string;
+  /** Full model ID including provider (e.g., "openai-codex/gpt-5.2") */
+  modelFull?: string;
+  /** Provider name (e.g., "openai-codex", "anthropic") */
+  provider?: string;
+  /** Current thinking level (e.g., "high", "low", "off") */
+  thinkingLevel?: string;
+  /** Agent identity name */
+  identityName?: string;
+};
+
+// Regex pattern for template variables: {variableName} or {variable.name}
+const TEMPLATE_VAR_PATTERN = /\{([a-zA-Z][a-zA-Z0-9.]*)\}/g;
+
+/**
+ * Interpolate template variables in a response prefix string.
+ *
+ * @param template - The template string with `{variable}` placeholders
+ * @param context - Context object with values for interpolation
+ * @returns The interpolated string, or undefined if template is undefined
+ *
+ * @example
+ * resolveResponsePrefixTemplate("[{model} | think:{thinkingLevel}]", {
+ *   model: "gpt-5.2",
+ *   thinkingLevel: "high"
+ * })
+ * // Returns: "[gpt-5.2 | think:high]"
+ */
+export function resolveResponsePrefixTemplate(
+  template: string | undefined,
+  context: ResponsePrefixContext,
+): string | undefined {
+  if (!template) return undefined;
+
+  return template.replace(TEMPLATE_VAR_PATTERN, (match, varName: string) => {
+    const normalizedVar = varName.toLowerCase();
+
+    switch (normalizedVar) {
+      case "model":
+        return context.model ?? match;
+      case "modelfull":
+        return context.modelFull ?? match;
+      case "provider":
+        return context.provider ?? match;
+      case "thinkinglevel":
+      case "think":
+        return context.thinkingLevel ?? match;
+      case "identity.name":
+      case "identityname":
+        return context.identityName ?? match;
+      default:
+        // Leave unrecognized variables as-is
+        return match;
+    }
+  });
+}
+
+/**
+ * Extract short model name from a full model string.
+ *
+ * Strips:
+ * - Provider prefix (e.g., "openai/" from "openai/gpt-5.2")
+ * - Date suffixes (e.g., "-20251101" from "claude-opus-4-5-20251101")
+ * - Common version suffixes (e.g., "-latest")
+ *
+ * @example
+ * extractShortModelName("openai-codex/gpt-5.2") // "gpt-5.2"
+ * extractShortModelName("claude-opus-4-5-20251101") // "claude-opus-4-5"
+ * extractShortModelName("gpt-5.2-latest") // "gpt-5.2"
+ */
+export function extractShortModelName(fullModel: string): string {
+  // Strip provider prefix
+  const slash = fullModel.lastIndexOf("/");
+  const modelPart = slash >= 0 ? fullModel.slice(slash + 1) : fullModel;
+
+  // Strip date suffixes (YYYYMMDD format)
+  return modelPart.replace(/-\d{8}$/, "").replace(/-latest$/, "");
+}
+
+/**
+ * Check if a template string contains any template variables.
+ */
+export function hasTemplateVariables(template: string | undefined): boolean {
+  if (!template) return false;
+  // Reset lastIndex since we're using a global regex
+  TEMPLATE_VAR_PATTERN.lastIndex = 0;
+  return TEMPLATE_VAR_PATTERN.test(template);
+}
diff --git a/src/browser/extension-relay.test.ts b/src/browser/extension-relay.test.ts
new file mode 100644
index 000000000..a976b31a6
--- /dev/null
+++ b/src/browser/extension-relay.test.ts
@@ -0,0 +1,194 @@
+import { createServer } from "node:http";
+import type { AddressInfo } from "node:net";
+import { afterEach, describe, expect, it } from "vitest";
+import WebSocket from "ws";
+
+import {
+  ensureChromeExtensionRelayServer,
+  stopChromeExtensionRelayServer,
+} from "./extension-relay.js";
+
+async function getFreePort(): Promise<number> {
+  while (true) {
+    const port = await new Promise<number>((resolve, reject) => {
+      const s = createServer();
+      s.once("error", reject);
+      s.listen(0, "127.0.0.1", () => {
+        const assigned = (s.address() as AddressInfo).port;
+        s.close((err) => (err ? reject(err) : resolve(assigned)));
+      });
+    });
+    if (port < 65535) return port;
+  }
+}
+
+function waitForOpen(ws: WebSocket) {
+  return new Promise<void>((resolve, reject) => {
+    ws.once("open", () => resolve());
+    ws.once("error", reject);
+  });
+}
+
+function createMessageQueue(ws: WebSocket) {
+  const queue: string[] = [];
+  let waiter: ((value: string) => void) | null = null;
+  let waiterReject: ((err: Error) => void) | null = null;
+  let waiterTimer: NodeJS.Timeout | null = null;
+
+  const flushWaiter = (value: string) => {
+    if (!waiter) return false;
+    const resolve = waiter;
+    waiter = null;
+    const reject = waiterReject;
+    waiterReject = null;
+    if (waiterTimer) clearTimeout(waiterTimer);
+    waiterTimer = null;
+    if (reject) {
+      // no-op (kept for symmetry)
+    }
+    resolve(value);
+    return true;
+  };
+
+  ws.on("message", (data) => {
+    const text =
+      typeof data === "string"
+        ? data
+        : Buffer.isBuffer(data)
+          ? data.toString("utf8")
+          : Array.isArray(data)
+            ? Buffer.concat(data).toString("utf8")
+            : Buffer.from(data).toString("utf8");
+    if (flushWaiter(text)) return;
+    queue.push(text);
+  });
+
+  ws.on("error", (err) => {
+    if (!waiterReject) return;
+    const reject = waiterReject;
+    waiterReject = null;
+    waiter = null;
+    if (waiterTimer) clearTimeout(waiterTimer);
+    waiterTimer = null;
+    reject(err instanceof Error ? err : new Error(String(err)));
+  });
+
+  const next = (timeoutMs = 5000) =>
+    new Promise<string>((resolve, reject) => {
+      const existing = queue.shift();
+      if (existing !== undefined) return resolve(existing);
+      waiter = resolve;
+      waiterReject = reject;
+      waiterTimer = setTimeout(() => {
+        waiter = null;
+        waiterReject = null;
+        waiterTimer = null;
+        reject(new Error("timeout"));
+      }, timeoutMs);
+    });
+
+  return { next };
+}
+
+describe("chrome extension relay server", () => {
+  let cdpUrl = "";
+
+  afterEach(async () => {
+    if (cdpUrl) {
+      await stopChromeExtensionRelayServer({ cdpUrl }).catch(() => {});
+      cdpUrl = "";
+    }
+  });
+
+  it("advertises CDP WS only when extension is connected", async () => {
+    const port = await getFreePort();
+    cdpUrl = `http://127.0.0.1:${port}`;
+    await ensureChromeExtensionRelayServer({ cdpUrl });
+
+    const v1 = (await fetch(`${cdpUrl}/json/version`).then((r) => r.json())) as {
+      webSocketDebuggerUrl?: string;
+    };
+    expect(v1.webSocketDebuggerUrl).toBeUndefined();
+
+    const ext = new WebSocket(`ws://127.0.0.1:${port}/extension`);
+    await waitForOpen(ext);
+
+    const v2 = (await fetch(`${cdpUrl}/json/version`).then((r) => r.json())) as {
+      webSocketDebuggerUrl?: string;
+    };
+    expect(String(v2.webSocketDebuggerUrl ?? "")).toContain(`/cdp`);
+
+    ext.close();
+  });
+
+  it("tracks attached page targets and exposes them via CDP + /json/list", async () => {
+    const port = await getFreePort();
+    cdpUrl = `http://127.0.0.1:${port}`;
+    await ensureChromeExtensionRelayServer({ cdpUrl });
+
+    const ext = new WebSocket(`ws://127.0.0.1:${port}/extension`);
+    await waitForOpen(ext);
+
+    // Simulate a tab attach coming from the extension.
+    ext.send(
+      JSON.stringify({
+        method: "forwardCDPEvent",
+        params: {
+          method: "Target.attachedToTarget",
+          params: {
+            sessionId: "cb-tab-1",
+            targetInfo: {
+              targetId: "t1",
+              type: "page",
+              title: "Example",
+              url: "https://example.com",
+            },
+            waitingForDebugger: false,
+          },
+        },
+      }),
+    );
+
+    const list = (await fetch(`${cdpUrl}/json/list`).then((r) => r.json())) as Array<{
+      id?: string;
+      url?: string;
+    }>;
+    expect(list.some((t) => t.id === "t1" && t.url === "https://example.com")).toBe(true);
+
+    const cdp = new WebSocket(`ws://127.0.0.1:${port}/cdp`);
+    await waitForOpen(cdp);
+    const q = createMessageQueue(cdp);
+
+    cdp.send(JSON.stringify({ id: 1, method: "Target.getTargets" }));
+    const res1 = JSON.parse(await q.next()) as { id: number; result?: unknown };
+    expect(res1.id).toBe(1);
+    expect(JSON.stringify(res1.result ?? {})).toContain("t1");
+
+    cdp.send(
+      JSON.stringify({
+        id: 2,
+        method: "Target.attachToTarget",
+        params: { targetId: "t1" },
+      }),
+    );
+    const received: Array<{
+      id?: number;
+      method?: string;
+      result?: unknown;
+      params?: unknown;
+    }> = [];
+    received.push(JSON.parse(await q.next()) as never);
+    received.push(JSON.parse(await q.next()) as never);
+
+    const res2 = received.find((m) => m.id === 2);
+    expect(res2?.id).toBe(2);
+    expect(JSON.stringify(res2?.result ?? {})).toContain("cb-tab-1");
+
+    const evt = received.find((m) => m.method === "Target.attachedToTarget");
+    expect(evt?.method).toBe("Target.attachedToTarget");
+    expect(JSON.stringify(evt?.params ?? {})).toContain("t1");
+
+    cdp.close();
+    ext.close();
+  }, 15_000);
+});
diff --git a/src/browser/extension-relay.ts b/src/browser/extension-relay.ts
new file mode 100644
index 000000000..acf9b2129
--- /dev/null
+++ b/src/browser/extension-relay.ts
@@ -0,0 +1,644 @@
+import { createServer } from "node:http";
+import type { AddressInfo } from "node:net";
+import type { Duplex } from "node:stream";
+
+import WebSocket, { WebSocketServer } from "ws";
+
+import { rawDataToString } from "../infra/ws.js";
+
+type CdpCommand = {
+  id: number;
+  method: string;
+  params?: unknown;
+  sessionId?: string;
+};
+
+type CdpResponse = {
+  id: number;
+  result?: unknown;
+  error?: { message: string };
+  sessionId?: string;
+};
+
+type CdpEvent = {
+  method: string;
+  params?: unknown;
+  sessionId?: string;
+};
+
+type ExtensionForwardCommandMessage = {
+  id: number;
+  method: "forwardCDPCommand";
+  params: { method: string; params?: unknown; sessionId?: string };
+};
+
+type ExtensionResponseMessage = {
+  id: number;
+  result?: unknown;
+  error?: string;
+};
+
+type ExtensionForwardEventMessage = {
+  method: "forwardCDPEvent";
+  params: { method: string; params?: unknown; sessionId?: string };
+};
+
+type ExtensionPingMessage = { method: "ping" };
+type ExtensionPongMessage = { method: "pong" };
+
+type ExtensionMessage =
+  | ExtensionResponseMessage
+  | ExtensionForwardEventMessage
+  | ExtensionPongMessage;
+
+type TargetInfo = {
+  targetId: string;
+  type?: string;
+  title?: string;
+  url?: string;
+  attached?: boolean;
+};
+
+type AttachedToTargetEvent = {
+  sessionId: string;
+  targetInfo: TargetInfo;
+  waitingForDebugger?: boolean;
+};
+
+type DetachedFromTargetEvent = {
+  sessionId: string;
+  targetId?: string;
+};
+
+type ConnectedTarget = {
+  sessionId: string;
+  targetId: string;
+  targetInfo: TargetInfo;
+};
+
+export type ChromeExtensionRelayServer = {
+  host: string;
+  port: number;
+  baseUrl: string;
+  cdpWsUrl: string;
+  extensionConnected: () => boolean;
+  stop: () => Promise<void>;
+};
+
+function isLoopbackHost(host: string) {
+  const h = host.trim().toLowerCase();
+  return (
+    h === "localhost" ||
+    h === "127.0.0.1" ||
+    h === "0.0.0.0" ||
+    h === "[::1]" ||
+    h === "::1" ||
+    h === "[::]" ||
+    h === "::"
+  );
+}
+
+function isLoopbackAddress(ip: string | undefined): boolean {
+  if (!ip) return false;
+  if (ip === "127.0.0.1") return true;
+  if (ip.startsWith("127.")) return true;
+  if (ip === "::1") return true;
+  if (ip.startsWith("::ffff:127.")) return true;
+  return false;
+}
+
+function parseBaseUrl(raw: string): {
+  host: string;
+  port: number;
+  baseUrl: string;
+} {
+  const parsed = new URL(raw.trim().replace(/\/$/, ""));
+  if (parsed.protocol !== "http:" && parsed.protocol !== "https:") {
+    throw new Error(`extension relay cdpUrl must be http(s), got ${parsed.protocol}`);
+  }
+  const host = parsed.hostname;
+  const port =
+    parsed.port?.trim() !== "" ? Number(parsed.port) : parsed.protocol === "https:" ? 443 : 80;
+  if (!Number.isFinite(port) || port <= 0 || port > 65535) {
+    throw new Error(`extension relay cdpUrl has invalid port: ${parsed.port || "(empty)"}`);
+  }
+  return { host, port, baseUrl: parsed.toString().replace(/\/$/, "") };
+}
+
+function text(res: Duplex, status: number, bodyText: string) {
+  const body = Buffer.from(bodyText);
+  res.write(
+    `HTTP/1.1 ${status} ${status === 200 ? "OK" : "ERR"}\r\n` +
+      "Content-Type: text/plain; charset=utf-8\r\n" +
+      `Content-Length: ${body.length}\r\n` +
+      "Connection: close\r\n" +
+      "\r\n",
+  );
+  res.write(body);
+  res.end();
+}
+
+function rejectUpgrade(socket: Duplex, status: number, bodyText: string) {
+  text(socket, status, bodyText);
+  try {
+    socket.destroy();
+  } catch {
+    // ignore
+  }
+}
+
+const serversByPort = new Map<number, ChromeExtensionRelayServer>();
+
+export async function ensureChromeExtensionRelayServer(opts: {
+  cdpUrl: string;
+}): Promise<ChromeExtensionRelayServer> {
+  const info = parseBaseUrl(opts.cdpUrl);
+  if (!isLoopbackHost(info.host)) {
+    throw new Error(`extension relay requires loopback cdpUrl host (got ${info.host})`);
+  }
+
+  const existing = serversByPort.get(info.port);
+  if (existing) return existing;
+
+  let extensionWs: WebSocket | null = null;
+  const cdpClients = new Set<WebSocket>();
+  const connectedTargets = new Map<string, ConnectedTarget>();
+
+  const pendingExtension = new Map<
+    number,
+    {
+      resolve: (v: unknown) => void;
+      reject: (e: Error) => void;
+      timer: NodeJS.Timeout;
+    }
+  >();
+  let nextExtensionId = 1;
+
+  const sendToExtension = async (payload: ExtensionForwardCommandMessage): Promise<unknown> => {
+    const ws = extensionWs;
+    if (!ws || ws.readyState !== WebSocket.OPEN) {
+      throw new Error("Chrome extension not connected");
+    }
+    ws.send(JSON.stringify(payload));
+    return await new Promise<unknown>((resolve, reject) => {
+      const timer = setTimeout(() => {
+        pendingExtension.delete(payload.id);
+        reject(new Error(`extension request timeout: ${payload.params.method}`));
+      }, 30_000);
+      pendingExtension.set(payload.id, { resolve, reject, timer });
+    });
+  };
+
+  const broadcastToCdpClients = (evt: CdpEvent) => {
+    const msg = JSON.stringify(evt);
+    for (const ws of cdpClients) {
+      if (ws.readyState !== WebSocket.OPEN) continue;
+      ws.send(msg);
+    }
+  };
+
+  const sendResponseToCdp = (ws: WebSocket, res: CdpResponse) => {
+    if (ws.readyState !== WebSocket.OPEN) return;
+    ws.send(JSON.stringify(res));
+  };
+
+  const ensureTargetEventsForClient = (ws: WebSocket, mode: "autoAttach" | "discover") => {
+    for (const target of connectedTargets.values()) {
+      if (mode === "autoAttach") {
+        ws.send(
+          JSON.stringify({
+            method: "Target.attachedToTarget",
+            params: {
+              sessionId: target.sessionId,
+              targetInfo: { ...target.targetInfo, attached: true },
+              waitingForDebugger: false,
+            },
+          } satisfies CdpEvent),
+        );
+      } else {
+        ws.send(
+          JSON.stringify({
+            method: "Target.targetCreated",
+            params: { targetInfo: { ...target.targetInfo, attached: true } },
+          } satisfies CdpEvent),
+        );
+      }
+    }
+  };
+
+  const routeCdpCommand = async (cmd: CdpCommand): Promise<unknown> => {
+    switch (cmd.method) {
+      case "Browser.getVersion":
+        return {
+          protocolVersion: "1.3",
+          product: "Chrome/Clawdbot-Extension-Relay",
+          revision: "0",
+          userAgent: "Clawdbot-Extension-Relay",
+          jsVersion: "V8",
+        };
+      case "Browser.setDownloadBehavior":
+        return {};
+      case "Target.setAutoAttach":
+      case "Target.setDiscoverTargets":
+        return {};
+      case "Target.getTargets":
+        return {
+          targetInfos: Array.from(connectedTargets.values()).map((t) => ({
+            ...t.targetInfo,
+            attached: true,
+          })),
+        };
+      case "Target.getTargetInfo": {
+        const params = (cmd.params ?? {}) as { targetId?: string };
+        const targetId = typeof params.targetId === "string" ? params.targetId : undefined;
+        if (targetId) {
+          for (const t of connectedTargets.values()) {
+            if (t.targetId === targetId) return { targetInfo: t.targetInfo };
+          }
+        }
+        if (cmd.sessionId && connectedTargets.has(cmd.sessionId)) {
+          const t = connectedTargets.get(cmd.sessionId);
+          if (t) return { targetInfo: t.targetInfo };
+        }
+        const first = Array.from(connectedTargets.values())[0];
+        return { targetInfo: first?.targetInfo };
+      }
+      case "Target.attachToTarget": {
+        const params = (cmd.params ?? {}) as { targetId?: string };
+        const targetId = typeof params.targetId === "string" ? params.targetId : undefined;
+        if (!targetId) throw new Error("targetId required");
+        for (const t of connectedTargets.values()) {
+          if (t.targetId === targetId) return { sessionId: t.sessionId };
+        }
+        throw new Error("target not found");
+      }
+      default: {
+        const id = nextExtensionId++;
+        return await sendToExtension({
+          id,
+          method: "forwardCDPCommand",
+          params: {
+            method: cmd.method,
+            sessionId: cmd.sessionId,
+            params: cmd.params,
+          },
+        });
+      }
+    }
+  };
+
+  const server = createServer((req, res) => {
+    const url = new URL(req.url ?? "/", info.baseUrl);
+    const path = url.pathname;
+
+    if (req.method === "HEAD" && path === "/") {
+      res.writeHead(200);
+      res.end();
+      return;
+    }
+
+    if (path === "/") {
+      res.writeHead(200, { "Content-Type": "text/plain; charset=utf-8" });
+      res.end("OK");
+      return;
+    }
+
+    if (path === "/extension/status") {
+      res.writeHead(200, { "Content-Type": "application/json" });
+      res.end(JSON.stringify({ connected: Boolean(extensionWs) }));
+      return;
+    }
+
+    const hostHeader = req.headers.host?.trim() || `${info.host}:${info.port}`;
+    const wsHost = `ws://${hostHeader}`;
+    const cdpWsUrl = `${wsHost}/cdp`;
+
+    if (
+      (path === "/json/version" || path === "/json/version/") &&
+      (req.method === "GET" || req.method === "PUT")
+    ) {
+      const payload: Record<string, unknown> = {
+        Browser: "Clawdbot/extension-relay",
+        "Protocol-Version": "1.3",
+      };
+      // Only advertise the WS URL if a real extension is connected.
+      if (extensionWs) payload.webSocketDebuggerUrl = cdpWsUrl;
+      res.writeHead(200, { "Content-Type": "application/json" });
+      res.end(JSON.stringify(payload));
+      return;
+    }
+
+    const listPaths = new Set(["/json", "/json/", "/json/list", "/json/list/"]);
+    if (listPaths.has(path) && (req.method === "GET" || req.method === "PUT")) {
+      const list = Array.from(connectedTargets.values()).map((t) => ({
+        id: t.targetId,
+        type: t.targetInfo.type ?? "page",
+        title: t.targetInfo.title ?? "",
+        description: t.targetInfo.title ?? "",
+        url: t.targetInfo.url ?? "",
+        webSocketDebuggerUrl: cdpWsUrl,
+        devtoolsFrontendUrl: `/devtools/inspector.html?ws=${cdpWsUrl.replace("ws://", "")}`,
+      }));
+      res.writeHead(200, { "Content-Type": "application/json" });
+      res.end(JSON.stringify(list));
+      return;
+    }
+
+    const activateMatch = path.match(/^\/json\/activate\/(.+)$/);
+    if (activateMatch && (req.method === "GET" || req.method === "PUT")) {
+      const targetId = decodeURIComponent(activateMatch[1] ?? "").trim();
+      if (!targetId) {
+        res.writeHead(400);
+        res.end("targetId required");
+        return;
+      }
+      void (async () => {
+        try {
+          await sendToExtension({
+            id: nextExtensionId++,
+            method: "forwardCDPCommand",
+            params: { method: "Target.activateTarget", params: { targetId } },
+          });
+        } catch {
+          // ignore
+        }
+      })();
+      res.writeHead(200);
+      res.end("OK");
+      return;
+    }
+
+    const closeMatch = path.match(/^\/json\/close\/(.+)$/);
+    if (closeMatch && (req.method === "GET" || req.method === "PUT")) {
+      const targetId = decodeURIComponent(closeMatch[1] ?? "").trim();
+      if (!targetId) {
+        res.writeHead(400);
+        res.end("targetId required");
+        return;
+      }
+      void (async () => {
+        try {
+          await sendToExtension({
+            id: nextExtensionId++,
+            method: "forwardCDPCommand",
+            params: { method: "Target.closeTarget", params: { targetId } },
+          });
+        } catch {
+          // ignore
+        }
+      })();
+      res.writeHead(200);
+      res.end("OK");
+      return;
+    }
+
+    res.writeHead(404);
+    res.end("not found");
+  });
+
+  const wssExtension = new WebSocketServer({ noServer: true });
+  const wssCdp = new WebSocketServer({ noServer: true });
+
+  server.on("upgrade", (req, socket, head) => {
+    const url = new URL(req.url ?? "/", info.baseUrl);
+    const pathname = url.pathname;
+    const remote = req.socket.remoteAddress;
+
+    if (!isLoopbackAddress(remote)) {
+      rejectUpgrade(socket, 403, "Forbidden");
+      return;
+    }
+
+    if (pathname === "/extension") {
+      if (extensionWs) {
+        rejectUpgrade(socket, 409, "Extension already connected");
+        return;
+      }
+      wssExtension.handleUpgrade(req, socket, head, (ws) => {
+        wssExtension.emit("connection", ws, req);
+      });
+      return;
+    }
+
+    if (pathname === "/cdp") {
+      if (!extensionWs) {
+        rejectUpgrade(socket, 503, "Extension not connected");
+        return;
+      }
+      wssCdp.handleUpgrade(req, socket, head, (ws) => {
+        wssCdp.emit("connection", ws, req);
+      });
+      return;
+    }
+
+    rejectUpgrade(socket, 404, "Not Found");
+  });
+
+  wssExtension.on("connection", (ws) => {
+    extensionWs = ws;
+
+    const ping = setInterval(() => {
+      if (ws.readyState !== WebSocket.OPEN) return;
+      ws.send(JSON.stringify({ method: "ping" } satisfies ExtensionPingMessage));
+    }, 5000);
+
+    ws.on("message", (data) => {
+      let parsed: ExtensionMessage | null = null;
+      try {
+        parsed = JSON.parse(rawDataToString(data)) as ExtensionMessage;
+      } catch {
+        return;
+      }
+
+      if (parsed && typeof parsed === "object" && "id" in parsed && typeof parsed.id === "number") {
+        const pending = pendingExtension.get(parsed.id);
+        if (!pending) return;
+        pendingExtension.delete(parsed.id);
+        clearTimeout(pending.timer);
+        if ("error" in parsed && typeof parsed.error === "string" && parsed.error.trim()) {
+          pending.reject(new Error(parsed.error));
+        } else {
+          pending.resolve((parsed as ExtensionResponseMessage).result);
+        }
+        return;
+      }
+
+      if (parsed && typeof parsed === "object" && "method" in parsed) {
+        if ((parsed as ExtensionPongMessage).method === "pong") return;
+        if ((parsed as ExtensionForwardEventMessage).method !== "forwardCDPEvent") return;
+        const evt = parsed as ExtensionForwardEventMessage;
+        const method = evt.params?.method;
+        const params = evt.params?.params;
+        const sessionId = evt.params?.sessionId;
+        if (!method || typeof method !== "string") return;
+
+        if (method === "Target.attachedToTarget") {
+          const attached = (params ?? {}) as AttachedToTargetEvent;
+          const targetType = attached?.targetInfo?.type ?? "page";
+          if (targetType !== "page") return;
+          if (attached?.sessionId && attached?.targetInfo?.targetId) {
+            const already = connectedTargets.has(attached.sessionId);
+            connectedTargets.set(attached.sessionId, {
+              sessionId: attached.sessionId,
+              targetId: attached.targetInfo.targetId,
+              targetInfo: attached.targetInfo,
+            });
+            if (!already) {
+              broadcastToCdpClients({ method, params, sessionId });
+            }
+            return;
+          }
+        }
+
+        if (method === "Target.detachedFromTarget") {
+          const detached = (params ?? {}) as DetachedFromTargetEvent;
+          if (detached?.sessionId) connectedTargets.delete(detached.sessionId);
+          broadcastToCdpClients({ method, params, sessionId });
+          return;
+        }
+
+        broadcastToCdpClients({ method, params, sessionId });
+      }
+    });
+
+    ws.on("close", () => {
+      clearInterval(ping);
+      extensionWs = null;
+      for (const [, pending] of pendingExtension) {
+        clearTimeout(pending.timer);
+        pending.reject(new Error("extension disconnected"));
+      }
+      pendingExtension.clear();
+      connectedTargets.clear();
+
+      for (const client of cdpClients) {
+        try {
+          client.close(1011, "extension disconnected");
+        } catch {
+          // ignore
+        }
+      }
+      cdpClients.clear();
+    });
+  });
+
+  wssCdp.on("connection", (ws) => {
+    cdpClients.add(ws);
+
+    ws.on("message", async (data) => {
+      let cmd: CdpCommand | null = null;
+      try {
+        cmd = JSON.parse(rawDataToString(data)) as CdpCommand;
+      } catch {
+        return;
+      }
+      if (!cmd || typeof cmd !== "object") return;
+      if (typeof cmd.id !== "number" || typeof cmd.method !== "string") return;
+
+      if (!extensionWs) {
+        sendResponseToCdp(ws, {
+          id: cmd.id,
+          sessionId: cmd.sessionId,
+          error: { message: "Extension not connected" },
+        });
+        return;
+      }
+
+      try {
+        const result = await routeCdpCommand(cmd);
+
+        if (cmd.method === "Target.setAutoAttach" && !cmd.sessionId) {
+          ensureTargetEventsForClient(ws, "autoAttach");
+        }
+        if (cmd.method === "Target.setDiscoverTargets") {
+          const discover = (cmd.params ?? {}) as { discover?: boolean };
+          if (discover.discover === true) {
+            ensureTargetEventsForClient(ws, "discover");
+          }
+        }
+        if (cmd.method === "Target.attachToTarget") {
+          const params = (cmd.params ?? {}) as { targetId?: string };
+          const targetId = typeof params.targetId === "string" ? params.targetId : undefined;
+          if (targetId) {
+            const target = Array.from(connectedTargets.values()).find(
+              (t) => t.targetId === targetId,
+            );
+            if (target) {
+              ws.send(
+                JSON.stringify({
+                  method: "Target.attachedToTarget",
+                  params: {
+                    sessionId: target.sessionId,
+                    targetInfo: { ...target.targetInfo, attached: true },
+                    waitingForDebugger: false,
+                  },
+                } satisfies CdpEvent),
+              );
+            }
+          }
+        }
+
+        sendResponseToCdp(ws, { id: cmd.id, sessionId: cmd.sessionId, result });
+      } catch (err) {
+        sendResponseToCdp(ws, {
+          id: cmd.id,
+          sessionId: cmd.sessionId,
+          error: { message: err instanceof Error ? err.message : String(err) },
+        });
+      }
+    });
+
+    ws.on("close", () => {
+      cdpClients.delete(ws);
+    });
+  });
+
+  await new Promise<void>((resolve, reject) => {
+    server.listen(info.port, info.host, () => resolve());
+    server.once("error", reject);
+  });
+
+  const addr = server.address() as AddressInfo | null;
+  const port = addr?.port ?? info.port;
+  const host = info.host;
+  const baseUrl = `${new URL(info.baseUrl).protocol}//${host}:${port}`;
+
+  const relay: ChromeExtensionRelayServer = {
+    host,
+    port,
+    baseUrl,
+    cdpWsUrl: `ws://${host}:${port}/cdp`,
+    extensionConnected: () => Boolean(extensionWs),
+    stop: async () => {
+      serversByPort.delete(port);
+      try {
+        extensionWs?.close(1001, "server stopping");
+      } catch {
+        // ignore
+      }
+      for (const ws of cdpClients) {
+        try {
+          ws.close(1001, "server stopping");
+        } catch {
+          // ignore
+        }
+      }
+      await new Promise<void>((resolve) => {
+        server.close(() => resolve());
+      });
+      wssExtension.close();
+      wssCdp.close();
+    },
+  };
+
+  serversByPort.set(port, relay);
+  return relay;
+}
+
+export async function stopChromeExtensionRelayServer(opts: { cdpUrl: string }): Promise<boolean> {
+  const info = parseBaseUrl(opts.cdpUrl);
+  const existing = serversByPort.get(info.port);
+  if (!existing) return false;
+  await existing.stop();
+  return true;
+}
diff --git a/src/channels/plugins/catalog.ts b/src/channels/plugins/catalog.ts
new file mode 100644
index 000000000..83edbd244
--- /dev/null
+++ b/src/channels/plugins/catalog.ts
@@ -0,0 +1,41 @@
+import type { ChannelMeta } from "./types.js";
+
+export type ChannelPluginCatalogEntry = {
+  id: string;
+  meta: ChannelMeta;
+  install: {
+    npmSpec: string;
+    localPath?: string;
+  };
+};
+
+const CATALOG: ChannelPluginCatalogEntry[] = [
+  {
+    id: "zalo",
+    meta: {
+      id: "zalo",
+      label: "Zalo",
+      selectionLabel: "Zalo (Bot API)",
+      docsPath: "/channels/zalo",
+      docsLabel: "zalo",
+      blurb: "Vietnam-focused messaging platform with Bot API.",
+      aliases: ["zl"],
+      order: 80,
+      quickstartAllowFrom: true,
+    },
+    install: {
+      npmSpec: "@clawdbot/zalo",
+      localPath: "extensions/zalo",
+    },
+  },
+];
+
+export function listChannelPluginCatalogEntries(): ChannelPluginCatalogEntry[] {
+  return [...CATALOG];
+}
+
+export function getChannelPluginCatalogEntry(id: string): ChannelPluginCatalogEntry | undefined {
+  const trimmed = id.trim();
+  if (!trimmed) return undefined;
+  return CATALOG.find((entry) => entry.id === trimmed);
+}
diff --git a/src/channels/plugins/config-writes.test.ts b/src/channels/plugins/config-writes.test.ts
new file mode 100644
index 000000000..107f42221
--- /dev/null
+++ b/src/channels/plugins/config-writes.test.ts
@@ -0,0 +1,43 @@
+import { describe, expect, it } from "vitest";
+
+import { resolveChannelConfigWrites } from "./config-writes.js";
+
+describe("resolveChannelConfigWrites", () => {
+  it("defaults to allow when unset", () => {
+    const cfg = {};
+    expect(resolveChannelConfigWrites({ cfg, channelId: "slack" })).toBe(true);
+  });
+
+  it("blocks when channel config disables writes", () => {
+    const cfg = { channels: { slack: { configWrites: false } } };
+    expect(resolveChannelConfigWrites({ cfg, channelId: "slack" })).toBe(false);
+  });
+
+  it("account override wins over channel default", () => {
+    const cfg = {
+      channels: {
+        slack: {
+          configWrites: true,
+          accounts: {
+            work: { configWrites: false },
+          },
+        },
+      },
+    };
+    expect(resolveChannelConfigWrites({ cfg, channelId: "slack", accountId: "work" })).toBe(false);
+  });
+
+  it("matches account ids case-insensitively", () => {
+    const cfg = {
+      channels: {
+        slack: {
+          configWrites: true,
+          accounts: {
+            Work: { configWrites: false },
+          },
+        },
+      },
+    };
+    expect(resolveChannelConfigWrites({ cfg, channelId: "slack", accountId: "work" })).toBe(false);
+  });
+});
diff --git a/src/channels/plugins/config-writes.ts b/src/channels/plugins/config-writes.ts
new file mode 100644
index 000000000..5c547475c
--- /dev/null
+++ b/src/channels/plugins/config-writes.ts
@@ -0,0 +1,32 @@
+import type { ClawdbotConfig } from "../../config/config.js";
+import type { ChannelId } from "./types.js";
+import { normalizeAccountId } from "../../routing/session-key.js";
+
+type ChannelConfigWithAccounts = {
+  configWrites?: boolean;
+  accounts?: Record<string, { configWrites?: boolean }>;
+};
+
+function resolveAccountConfig(accounts: ChannelConfigWithAccounts["accounts"], accountId: string) {
+  if (!accounts || typeof accounts !== "object") return undefined;
+  if (accountId in accounts) return accounts[accountId];
+  const matchKey = Object.keys(accounts).find(
+    (key) => key.toLowerCase() === accountId.toLowerCase(),
+  );
+  return matchKey ? accounts[matchKey] : undefined;
+}
+
+export function resolveChannelConfigWrites(params: {
+  cfg: ClawdbotConfig;
+  channelId?: ChannelId | null;
+  accountId?: string | null;
+}): boolean {
+  if (!params.channelId) return true;
+  const channels = params.cfg.channels as Record<string, ChannelConfigWithAccounts> | undefined;
+  const channelConfig = channels?.[params.channelId];
+  if (!channelConfig) return true;
+  const accountId = normalizeAccountId(params.accountId);
+  const accountConfig = resolveAccountConfig(channelConfig.accounts, accountId);
+  const value = accountConfig?.configWrites ?? channelConfig.configWrites;
+  return value !== false;
+}
diff --git a/src/clawline/adapter.test.ts b/src/clawline/adapter.test.ts
new file mode 100644
index 000000000..f152ab924
--- /dev/null
+++ b/src/clawline/adapter.test.ts
@@ -0,0 +1,103 @@
+import fs from "node:fs/promises";
+import os from "node:os";
+import path from "node:path";
+
+import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
+
+import type { ClawdbotConfig } from "../config/config.js";
+import { createClawlineAdapter } from "./adapter.js";
+import { resolveClawlineConfig } from "./config.js";
+
+vi.mock("../agents/pi-embedded-runner.js", () => ({
+  runEmbeddedPiAgent: vi.fn(),
+}));
+
+const { runEmbeddedPiAgent } = await import("../agents/pi-embedded-runner.js");
+
+describe("createClawlineAdapter", () => {
+  let tmpDir: string;
+
+  beforeEach(async () => {
+    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), "clawline-test-"));
+    vi.mocked(runEmbeddedPiAgent).mockReset();
+  });
+
+  afterEach(async () => {
+    await fs.rm(tmpDir, { recursive: true, force: true });
+  });
+
+  function buildConfig(): ClawdbotConfig {
+    return {
+      agents: {
+        defaults: {
+          model: { primary: "anthropic/claude-sonnet-4-5" },
+          cliBackends: {
+            anthropic: {
+              command: "claude",
+            },
+          },
+          workspace: path.join(tmpDir, "workspace"),
+          timeoutSeconds: 30,
+        },
+      },
+    } as ClawdbotConfig;
+  }
+
+  it("throws when no primary model configured", async () => {
+    await expect(
+      createClawlineAdapter({
+        config: { agents: { defaults: {} } } as unknown as ClawdbotConfig,
+        statePath: tmpDir,
+      }),
+    ).rejects.toThrow(/agents.defaults.model/i);
+  });
+
+  it("calls runEmbeddedPiAgent with derived session data", async () => {
+    vi.mocked(runEmbeddedPiAgent).mockResolvedValue({
+      payloads: [{ text: "Hello from agent" }],
+      meta: { durationMs: 10 },
+    });
+
+    const adapter = await createClawlineAdapter({
+      config: buildConfig(),
+      statePath: tmpDir,
+    });
+
+    const result = await adapter.execute({
+      prompt: "Hi there",
+      userId: "user_123",
+      sessionId: "sess_123",
+      deviceId: "device_a",
+    });
+
+    expect(runEmbeddedPiAgent).toHaveBeenCalledTimes(1);
+    const call = vi.mocked(runEmbeddedPiAgent).mock.calls[0]?.[0];
+    expect(call?.prompt).toBe("Hi there");
+    expect(call?.sessionId).toBe("sess_123");
+    expect(call?.provider).toBe("anthropic");
+    expect(call?.model).toBe("claude-sonnet-4-5");
+    expect(result).toEqual({ exitCode: 0, output: "Hello from agent" });
+  });
+
+  it("returns non-zero exit when payload text missing", async () => {
+    vi.mocked(runEmbeddedPiAgent).mockResolvedValue({
+      payloads: [],
+      meta: { durationMs: 5 },
+    });
+    const adapter = await createClawlineAdapter({
+      config: buildConfig(),
+      statePath: tmpDir,
+      clawlineConfig: resolveClawlineConfig({
+        clawline: { adapter: { responseFallback: "No reply" } },
+      } as ClawdbotConfig),
+    });
+    const result = await adapter.execute({
+      prompt: "Hi",
+      userId: "user_x",
+      sessionId: "sess_x",
+      deviceId: "device_x",
+    });
+    expect(result.exitCode).toBe(1);
+    expect(result.output).toBe("No reply");
+  });
+});
diff --git a/src/clawline/adapter.ts b/src/clawline/adapter.ts
new file mode 100644
index 000000000..0b881dde6
--- /dev/null
+++ b/src/clawline/adapter.ts
@@ -0,0 +1,106 @@
+import fs from "node:fs/promises";
+import path from "node:path";
+import { randomUUID } from "node:crypto";
+
+import type { ClawdbotConfig } from "../config/config.js";
+import {
+  resolveAgentWorkspaceDir,
+  resolveDefaultAgentId,
+} from "../agents/agent-scope.js";
+import type { EmbeddedPiRunResult } from "../agents/pi-embedded-runner.js";
+import { runEmbeddedPiAgent } from "../agents/pi-embedded-runner.js";
+import type { AdapterExecuteParams, Logger } from "./server.js";
+import { resolveClawlineConfig, type ResolvedClawlineConfig } from "./config.js";
+
+export type AdapterResult = { exitCode: number; output: string };
+
+export type ClawlineAdapter = {
+  execute: (params: AdapterExecuteParams) => Promise<AdapterResult>;
+};
+
+type AdapterCreateParams = {
+  config: ClawdbotConfig;
+  statePath: string;
+  logger?: Logger;
+  clawlineConfig?: ResolvedClawlineConfig;
+};
+
+function parseModelRef(
+  ref?: string | null,
+): { provider: string; model: string } | null {
+  if (!ref) return null;
+  const trimmed = ref.trim();
+  if (!trimmed) return null;
+  const [provider, ...rest] = trimmed.split("/");
+  if (!provider || rest.length === 0) return null;
+  return { provider, model: rest.join("/") };
+}
+
+function extractText(result: EmbeddedPiRunResult): string | null {
+  const texts =
+    result.payloads
+      ?.map((entry) => entry.text?.trim())
+      .filter((value): value is string => Boolean(value)) ?? [];
+  if (texts.length === 0) return null;
+  return texts.join("\n\n");
+}
+
+export async function createClawlineAdapter(
+  params: AdapterCreateParams,
+): Promise<ClawlineAdapter> {
+  const logger = params.logger ?? console;
+  const resolved = params.clawlineConfig ?? resolveClawlineConfig(params.config);
+  const defaultModelRef =
+    resolved.adapterOverrides.model ??
+    params.config.agents?.defaults?.model?.primary;
+  const parsedModel = parseModelRef(defaultModelRef);
+  if (!parsedModel) {
+    throw new Error(
+      "Clawline adapter requires agents.defaults.model.primary in config",
+    );
+  }
+  const providerName =
+    resolved.adapterOverrides.provider ?? parsedModel.provider;
+  const timeoutSeconds =
+    resolved.adapterOverrides.timeoutSeconds ??
+    params.config.agents?.defaults?.timeoutSeconds ??
+    300;
+  const timeoutMs = Math.max(1, timeoutSeconds) * 1000;
+  const agentId = resolveDefaultAgentId(params.config);
+  const workspaceDir = resolveAgentWorkspaceDir(params.config, agentId);
+  const sessionDir = path.join(params.statePath, "sessions");
+  await fs.mkdir(sessionDir, { recursive: true });
+  return {
+    async execute(ctx) {
+      const sessionFile = path.join(sessionDir, `${ctx.userId}.jsonl`);
+      await fs.mkdir(path.dirname(sessionFile), { recursive: true });
+      const runId = randomUUID();
+      const result = await runEmbeddedPiAgent({
+        sessionId: ctx.sessionId,
+        sessionKey: ctx.sessionId,
+        sessionFile,
+        workspaceDir,
+        config: params.config,
+        prompt: ctx.prompt,
+        provider: providerName,
+        model: parsedModel.model,
+        thinkLevel: params.config.agents?.defaults?.thinkingDefault,
+        timeoutMs,
+        runId,
+        extraSystemPrompt: resolved.adapterOverrides.systemPrompt,
+        ownerNumbers: undefined,
+      });
+      const text = extractText(result);
+      if (!text) {
+        const fallback = resolved.adapterOverrides.responseFallback ?? "";
+        if (!fallback) {
+          logger.warn?.(
+            "[clawline] adapter returned no text; consider setting clawline.adapter.responseFallback",
+          );
+        }
+        return { exitCode: 1, output: fallback };
+      }
+      return { exitCode: 0, output: text };
+    },
+  };
+}
diff --git a/src/clawline/config.test.ts b/src/clawline/config.test.ts
new file mode 100644
index 000000000..0bc5f7d3e
--- /dev/null
+++ b/src/clawline/config.test.ts
@@ -0,0 +1,48 @@
+import os from "node:os";
+import path from "node:path";
+import { describe, expect, it } from "vitest";
+
+import type { ClawdbotConfig } from "../config/config.js";
+import { resolveClawlineConfig } from "./config.js";
+
+describe("resolveClawlineConfig", () => {
+  const home = os.homedir();
+
+  it("applies defaults when config is missing", () => {
+    const cfg = resolveClawlineConfig({} as ClawdbotConfig);
+    expect(cfg.enabled).toBe(true);
+    expect(cfg.port).toBe(18792);
+    expect(cfg.statePath).toBe(path.join(home, ".clawdbot", "clawline"));
+    expect(cfg.media.storagePath).toBe(
+      path.join(home, ".clawdbot", "clawline-media"),
+    );
+    expect(cfg.network.bindAddress).toBe("127.0.0.1");
+    expect(cfg.network.allowInsecurePublic).toBe(false);
+  });
+
+  it("merges overrides from config", () => {
+    const cfg = resolveClawlineConfig({
+      clawline: {
+        enabled: false,
+        port: 1234,
+        statePath: "/tmp/clawline",
+        network: {
+          bindAddress: "0.0.0.0",
+          allowInsecurePublic: true,
+          allowedOrigins: ["https://example.com"],
+        },
+        media: {
+          storagePath: "/tmp/media",
+        },
+      },
+    } as ClawdbotConfig);
+
+    expect(cfg.enabled).toBe(false);
+    expect(cfg.port).toBe(1234);
+    expect(cfg.statePath).toBe("/tmp/clawline");
+    expect(cfg.media.storagePath).toBe("/tmp/media");
+    expect(cfg.network.bindAddress).toBe("0.0.0.0");
+    expect(cfg.network.allowInsecurePublic).toBe(true);
+    expect(cfg.network.allowedOrigins).toEqual(["https://example.com"]);
+  });
+});
diff --git a/src/clawline/config.ts b/src/clawline/config.ts
new file mode 100644
index 000000000..b97cb0318
--- /dev/null
+++ b/src/clawline/config.ts
@@ -0,0 +1,120 @@
+import os from "node:os";
+import path from "node:path";
+
+import type { ClawdbotConfig } from "../config/config.js";
+import type { ProviderConfig } from "./server.js";
+
+export type ClawlineAdapterOverrides = {
+  provider?: string;
+  model?: string;
+  timeoutSeconds?: number;
+  responseFallback?: string;
+  systemPrompt?: string;
+};
+
+export type ResolvedClawlineConfig = ProviderConfig & {
+  enabled: boolean;
+  adapterOverrides: ClawlineAdapterOverrides;
+};
+
+type ProviderConfigBase = Omit<ProviderConfig, "adapter">;
+
+export type ClawlineConfigInput = {
+  enabled?: boolean;
+  adapter?: ClawlineAdapterOverrides;
+} & Partial<ProviderConfigBase>;
+
+const defaultStatePath = path.join(os.homedir(), ".clawdbot", "clawline");
+const defaultMediaPath = path.join(os.homedir(), ".clawdbot", "clawline-media");
+
+const DEFAULTS: ResolvedClawlineConfig = {
+  enabled: true,
+  port: 18792,
+  statePath: defaultStatePath,
+  network: {
+    bindAddress: "127.0.0.1",
+    allowInsecurePublic: false,
+    allowedOrigins: [],
+  },
+  adapter: null,
+  adapterOverrides: {},
+  auth: {
+    jwtSigningKey: null,
+    tokenTtlSeconds: 31_536_000,
+    maxAttemptsPerMinute: 5,
+    reissueGraceSeconds: 600,
+  },
+  pairing: {
+    maxPendingRequests: 100,
+    maxRequestsPerMinute: 5,
+    pendingTtlSeconds: 300,
+  },
+  media: {
+    storagePath: defaultMediaPath,
+    maxInlineBytes: 262_144,
+    maxUploadBytes: 104_857_600,
+    unreferencedUploadTtlSeconds: 3600,
+  },
+  sessions: {
+    maxMessageBytes: 65_536,
+    maxReplayMessages: 500,
+    maxPromptMessages: 200,
+    maxMessagesPerSecond: 5,
+    maxTypingPerSecond: 2,
+    typingAutoExpireSeconds: 10,
+    maxQueuedMessages: 20,
+    maxWriteQueueDepth: 1000,
+    adapterExecuteTimeoutSeconds: 300,
+    streamInactivitySeconds: 300,
+  },
+  streams: {
+    chunkPersistIntervalMs: 100,
+    chunkBufferBytes: 1_048_576,
+  },
+};
+
+function deepMerge<T extends Record<string, any>>(
+  target: T,
+  source: Partial<T>,
+): T {
+  const targetRecord = target as Record<string, any>;
+  const sourceRecord = source as Record<string, any>;
+  for (const rawKey of Object.keys(sourceRecord)) {
+    const key = rawKey as keyof T & string;
+    const value = sourceRecord[key];
+    if (
+      value &&
+      typeof value === "object" &&
+      !Array.isArray(value) &&
+      typeof targetRecord[key] === "object" &&
+      targetRecord[key] !== null &&
+      !Array.isArray(targetRecord[key])
+    ) {
+      targetRecord[key] = deepMerge(
+        { ...(targetRecord[key] as Record<string, any>) },
+        value,
+      );
+    } else if (value !== undefined) {
+      targetRecord[key] = value;
+    }
+  }
+  return target;
+}
+
+export function resolveClawlineConfig(
+  cfg: ClawdbotConfig,
+): ResolvedClawlineConfig {
+  const input = (cfg.clawline ?? {}) as ClawlineConfigInput;
+  const merged = deepMerge(
+    structuredClone(DEFAULTS) as ResolvedClawlineConfig,
+    input as Partial<ResolvedClawlineConfig>,
+  );
+  merged.statePath = merged.statePath || defaultStatePath;
+  merged.media.storagePath = merged.media.storagePath || defaultMediaPath;
+  const adapterOverrides: ClawlineAdapterOverrides = input.adapter
+    ? { ...input.adapter }
+    : {};
+  merged.adapterOverrides = adapterOverrides;
+  merged.enabled = input.enabled ?? true;
+  return merged;
+}
diff --git a/src/clawline/server.ts b/src/clawline/server.ts
new file mode 100644
index 000000000..0ce3b796f
--- /dev/null
+++ b/src/clawline/server.ts
@@ -0,0 +1,1907 @@
+import http from "node:http";
+import net from "node:net";
+import os from "node:os";
+import path from "node:path";
+import fs from "node:fs/promises";
+import { watchFile, unwatchFile, createWriteStream } from "node:fs";
+import { createHash, randomBytes, randomUUID, timingSafeEqual } from "node:crypto";
+
+import WebSocket, { WebSocketServer } from "ws";
+import jwt from "jsonwebtoken";
+import Busboy from "busboy";
+import BetterSqlite3 from "better-sqlite3";
+import type { Database as SqliteDatabase } from "better-sqlite3";
+import { rawDataToString } from "../infra/ws.js";
+import { recordClawlineSessionActivity } from "./session-store.js";
+import {
+  buildClawlineSessionKey,
+  clawlineSessionFileName,
+} from "./session-key.js";
+
+export const PROTOCOL_VERSION = 1;
+
+export type AdapterExecuteParams = {
+  prompt: string;
+  userId: string;
+  sessionId: string;
+  deviceId: string;
+};
+
+export interface Adapter {
+  capabilities?: { streaming?: boolean };
+  execute: (
+    params: AdapterExecuteParams
+  ) => Promise<{ exitCode: number; output: string } | { exitCode?: number; output?: string } | string>;
+}
+
+export interface ProviderConfig {
+  port: number;
+  statePath: string;
+  network: {
+    bindAddress: string;
+    allowInsecurePublic: boolean;
+    allowedOrigins?: string[];
+  };
+  adapter?: string | null;
+  auth: {
+    jwtSigningKey?: string | null;
+    tokenTtlSeconds: number | null;
+    maxAttemptsPerMinute: number;
+    reissueGraceSeconds: number;
+  };
+  pairing: {
+    maxPendingRequests: number;
+    maxRequestsPerMinute: number;
+    pendingTtlSeconds: number;
+  };
+  media: {
+    storagePath: string;
+    maxInlineBytes: number;
+    maxUploadBytes: number;
+    unreferencedUploadTtlSeconds: number;
+  };
+  sessions: {
+    maxMessageBytes: number;
+    maxReplayMessages: number;
+    maxPromptMessages: number;
+    maxMessagesPerSecond: number;
+    maxTypingPerSecond: number;
+    typingAutoExpireSeconds: number;
+    maxQueuedMessages: number;
+    maxWriteQueueDepth: number;
+    adapterExecuteTimeoutSeconds: number;
+    streamInactivitySeconds: number;
+  };
+  streams: {
+    chunkPersistIntervalMs: number;
+    chunkBufferBytes: number;
+  };
+}
+
+export interface ProviderOptions {
+  config?: Partial<ProviderConfig>;
+  adapter: Adapter;
+  logger?: Logger;
+  sessionStorePath: string;
+}
+
+export interface ProviderServer {
+  start(): Promise<void>;
+  stop(): Promise<void>;
+  getPort(): number;
+}
+
+export type Logger = {
+  info: (...args: any[]) => void;
+  warn: (...args: any[]) => void;
+  error: (...args: any[]) => void;
+};
+
+type AllowlistEntry = {
+  deviceId: string;
+  claimedName?: string;
+  deviceInfo: DeviceInfo;
+  userId: string;
+  isAdmin: boolean;
+  tokenDelivered: boolean;
+  createdAt: number;
+  lastSeenAt: number | null;
+};
+
+type AllowlistFile = { version: 1; entries: AllowlistEntry[] };
+
+type DeviceInfo = {
+  platform: string;
+  model: string;
+  osVersion?: string;
+  appVersion?: string;
+};
+
+// eslint-disable-next-line no-control-regex
+const CONTROL_CHARS_REGEX = /[\u0000-\u001F\u007F]/g;
+const UUID_V4_REGEX = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/;
+const SERVER_EVENT_ID_REGEX = /^s_[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;
+const ASSET_ID_REGEX = /^a_[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;
+const USER_ID_PREFIX = "user_";
+const INLINE_IMAGE_MIME_TYPES = new Set(["image/png", "image/jpeg", "image/gif", "image/webp", "image/heic"]);
+const MAX_ATTACHMENTS_COUNT = 4;
+const MAX_TOTAL_PAYLOAD_BYTES = 320 * 1024;
+
+type NormalizedAttachment =
+  | { type: "image"; mimeType: string; data: string }
+  | { type: "asset"; assetId: string };
+
+class ClientMessageError extends Error {
+  constructor(public code: string, message: string) {
+    super(message);
+  }
+}
+
+class HttpError extends Error {
+  constructor(public status: number, public code: string, message: string) {
+    super(message);
+  }
+}
+
+class SlidingWindowRateLimiter {
+  private readonly history = new Map<string, number[]>();
+  private cleanupCounter = 0;
+
+  constructor(private readonly limit: number, private readonly windowMs: number) {}
+
+  attempt(key: string): boolean {
+    if (this.limit <= 0) {
+      return true;
+    }
+    const now = Date.now();
+    if (++this.cleanupCounter % 1000 === 0) {
+      this.cleanup(now);
+    }
+    const timestamps = this.history.get(key) ?? [];
+    while (timestamps.length > 0 && now - timestamps[0] >= this.windowMs) {
+      timestamps.shift();
+    }
+    if (timestamps.length >= this.limit) {
+      this.history.set(key, timestamps);
+      return false;
+    }
+    timestamps.push(now);
+    this.history.set(key, timestamps);
+    return true;
+  }
+
+  private cleanup(now: number) {
+    for (const [key, timestamps] of this.history) {
+      if (timestamps.length === 0) {
+        this.history.delete(key);
+        continue;
+      }
+      const last = timestamps[timestamps.length - 1];
+      if (now - last >= this.windowMs) {
+        this.history.delete(key);
+      }
+    }
+  }
+}
+
+function truncateUtf8(value: string, maxBytes: number): string {
+  if (Buffer.byteLength(value, "utf8") <= maxBytes) {
+    return value;
+  }
+  let bytes = 0;
+  let result = "";
+  for (const char of value) {
+    const charBytes = Buffer.byteLength(char, "utf8");
+    if (bytes + charBytes > maxBytes) {
+      break;
+    }
+    result += char;
+    bytes += charBytes;
+  }
+  return result;
+}
+
+function sanitizeLabel(label?: string): string | undefined {
+  if (typeof label !== "string") {
+    return undefined;
+  }
+  const stripped = label.replace(CONTROL_CHARS_REGEX, "").trim();
+  if (!stripped) {
+    return undefined;
+  }
+  return truncateUtf8(stripped, 64);
+}
+
+function sanitizeDeviceInfo(info: DeviceInfo): DeviceInfo {
+  const sanitizeField = (value: string | undefined) => {
+    if (typeof value !== "string") {
+      return undefined;
+    }
+    const stripped = value.replace(CONTROL_CHARS_REGEX, "").trim();
+    if (!stripped) {
+      return undefined;
+    }
+    return truncateUtf8(stripped, 64);
+  };
+  return {
+    platform: sanitizeField(info.platform) ?? "",
+    model: sanitizeField(info.model) ?? "",
+    osVersion: sanitizeField(info.osVersion),
+    appVersion: sanitizeField(info.appVersion)
+  };
+}
+
+function normalizeAttachmentsInput(
+  raw: unknown,
+  mediaConfig: ProviderConfig["media"]
+): { attachments: NormalizedAttachment[]; inlineBytes: number; assetIds: string[] } {
+  if (raw === undefined) {
+    return { attachments: [], inlineBytes: 0, assetIds: [] };
+  }
+  if (!Array.isArray(raw)) {
+    throw new ClientMessageError("invalid_message", "attachments must be an array");
+  }
+  if (raw.length > MAX_ATTACHMENTS_COUNT) {
+    throw new ClientMessageError("payload_too_large", "Too many attachments");
+  }
+  let inlineBytes = 0;
+  const attachments: NormalizedAttachment[] = [];
+  const assetIds: string[] = [];
+  for (const entry of raw) {
+    if (!entry || typeof entry !== "object") {
+      throw new ClientMessageError("invalid_message", "Invalid attachment");
+    }
+    const typed = entry as any;
+    if (typed.type === "image") {
+      if (typeof typed.mimeType !== "string" || typeof typed.data !== "string") {
+        throw new ClientMessageError("invalid_message", "Invalid inline attachment");
+      }
+      const mime = typed.mimeType.toLowerCase();
+      if (!INLINE_IMAGE_MIME_TYPES.has(mime)) {
+        throw new ClientMessageError("invalid_message", "Unsupported image type");
+      }
+      let decoded: Buffer;
+      try {
+        decoded = Buffer.from(typed.data, "base64");
+      } catch {
+        throw new ClientMessageError("invalid_message", "Invalid base64 data");
+      }
+      if (decoded.length === 0) {
+        throw new ClientMessageError("invalid_message", "Empty attachment data");
+      }
+      if (decoded.length > mediaConfig.maxInlineBytes) {
+        throw new ClientMessageError("payload_too_large", "Inline attachment too large");
+      }
+      inlineBytes += decoded.length;
+      attachments.push({ type: "image", mimeType: mime, data: typed.data });
+    } else if (typed.type === "asset") {
+      if (typeof typed.assetId !== "string" || !ASSET_ID_REGEX.test(typed.assetId)) {
+        throw new ClientMessageError("invalid_message", "Invalid assetId");
+      }
+      attachments.push({ type: "asset", assetId: typed.assetId });
+      assetIds.push(typed.assetId);
+    } else {
+      throw new ClientMessageError("invalid_message", "Unknown attachment type");
+    }
+  }
+  if (inlineBytes > mediaConfig.maxInlineBytes) {
+    throw new ClientMessageError("payload_too_large", "Inline attachments exceed limit");
+  }
+  return { attachments, inlineBytes, assetIds };
+}
+
+function timingSafeStringEqual(a: string, b: string): boolean {
+  const bufA = Buffer.from(a);
+  const bufB = Buffer.from(b);
+  if (bufA.length !== bufB.length) {
+    return false;
+  }
+  return timingSafeEqual(bufA, bufB);
+}
+
+function validateDeviceInfo(value: any): value is DeviceInfo {
+  if (!value || typeof value !== "object") {
+    return false;
+  }
+  const requiredString = (input: unknown) =>
+    typeof input === "string" && input.length > 0 && Buffer.byteLength(input, "utf8") <= 64;
+  if (!requiredString(value.platform) || !requiredString(value.model)) {
+    return false;
+  }
+  if (value.osVersion !== undefined && (!requiredString(value.osVersion) && value.osVersion !== "")) {
+    return false;
+  }
+  if (value.appVersion !== undefined && (!requiredString(value.appVersion) && value.appVersion !== "")) {
+    return false;
+  }
+  return true;
+}
+
+type PendingPairRequest = {
+  deviceId: string;
+  socket: WebSocket;
+  claimedName?: string;
+  deviceInfo: DeviceInfo;
+  createdAt: number;
+};
+
+type Session = {
+  socket: WebSocket;
+  deviceId: string;
+  userId: string;
+  isAdmin: boolean;
+  sessionId: string;
+  sessionKey: string;
+  claimedName?: string;
+  deviceInfo?: DeviceInfo;
+};
+
+type ConnectionState = {
+  authenticated: boolean;
+  deviceId?: string;
+  userId?: string;
+  isAdmin?: boolean;
+  sessionId?: string;
+};
+
+type ServerMessage = {
+  type: "message";
+  id: string;
+  role: "user" | "assistant";
+  content: string;
+  timestamp: number;
+  streaming: boolean;
+  attachments?: unknown[];
+  deviceId?: string;
+};
+
+enum MessageStreamingState {
+  Finalized = 0,
+  Active = 1,
+  Failed = 2
+}
+
+const DEFAULT_CONFIG: ProviderConfig = {
+  port: 18792,
+  statePath: path.join(os.homedir(), ".clawdbot", "clawline"),
+  network: {
+    bindAddress: "127.0.0.1",
+    allowInsecurePublic: false,
+    allowedOrigins: []
+  },
+  adapter: null,
+  auth: {
+    jwtSigningKey: null,
+    tokenTtlSeconds: 31_536_000,
+    maxAttemptsPerMinute: 5,
+    reissueGraceSeconds: 600
+  },
+  pairing: {
+    maxPendingRequests: 100,
+    maxRequestsPerMinute: 5,
+    pendingTtlSeconds: 300
+  },
+  media: {
+    storagePath: path.join(os.homedir(), ".clawdbot", "clawline-media"),
+    maxInlineBytes: 262_144,
+    maxUploadBytes: 104_857_600,
+    unreferencedUploadTtlSeconds: 3600
+  },
+  sessions: {
+    maxMessageBytes: 65_536,
+    maxReplayMessages: 500,
+    maxPromptMessages: 200,
+    maxMessagesPerSecond: 5,
+    maxTypingPerSecond: 2,
+    typingAutoExpireSeconds: 10,
+    maxQueuedMessages: 20,
+    maxWriteQueueDepth: 1000,
+    adapterExecuteTimeoutSeconds: 300,
+    streamInactivitySeconds: 300
+  },
+  streams: {
+    chunkPersistIntervalMs: 100,
+    chunkBufferBytes: 1_048_576
+  }
+};
+
+const ALLOWLIST_FILENAME = "allowlist.json";
+const DENYLIST_FILENAME = "denylist.json";
+const JWT_KEY_FILENAME = "jwt.key";
+const DB_FILENAME = "clawline.sqlite";
+const SESSION_REPLACED_CODE = 1000;
+
+function mergeConfig(partial?: Partial<ProviderConfig>): ProviderConfig {
+  const merged = JSON.parse(JSON.stringify(DEFAULT_CONFIG)) as ProviderConfig;
+  if (!partial) {
+    return merged;
+  }
+  return deepMerge(merged, partial);
+}
+
+function deepMerge<T>(target: T, source: Partial<T>): T {
+  for (const [key, value] of Object.entries(source) as [keyof T, any][]) {
+    if (value && typeof value === "object" && !Array.isArray(value)) {
+      (target as any)[key] = deepMerge((target as any)[key] ?? {}, value);
+    } else if (value !== undefined) {
+      (target as any)[key] = value;
+    }
+  }
+  return target;
+}
+
+function isLocalhost(address: string): boolean {
+  return ["127.0.0.1", "::1", "localhost"].includes(address);
+}
+
+function validateUserId(value: unknown): value is string {
+  if (typeof value !== "string" || !value.startsWith(USER_ID_PREFIX)) {
+    return false;
+  }
+  return UUID_V4_REGEX.test(value.slice(USER_ID_PREFIX.length));
+}
+
+async function ensureDir(dir: string) {
+  await fs.mkdir(dir, { recursive: true });
+}
+
+async function loadJsonFile<T>(filePath: string, fallback: T): Promise<T> {
+  try {
+    const data = await fs.readFile(filePath, "utf8");
+    return JSON.parse(data) as T;
+  } catch (err: any) {
+    if (err && (err.code === "ENOENT" || err.code === "ENOTDIR")) {
+      await fs.writeFile(filePath, JSON.stringify(fallback, null, 2));
+      return fallback;
+    }
+    throw err;
+  }
+}
+
+async function loadAllowlist(filePath: string): Promise<AllowlistFile> {
+  return loadJsonFile<AllowlistFile>(filePath, { version: 1, entries: [] });
+}
+
+async function loadDenylist(filePath: string): Promise<{ deviceId: string }[]> {
+  return loadJsonFile(filePath, [] as { deviceId: string }[]);
+}
+
+async function ensureJwtKey(filePath: string, provided?: string | null): Promise<string> {
+  const validateKey = (value: string) => {
+    const trimmed = value.trim();
+    if (Buffer.byteLength(trimmed, "utf8") < 64) {
+      throw new Error("JWT signing key must be at least 32 bytes (64 hex characters)");
+    }
+    return trimmed;
+  };
+  if (provided) {
+    return validateKey(provided);
+  }
+  try {
+    const data = await fs.readFile(filePath, "utf8");
+    return validateKey(data);
+  } catch (err: any) {
+    if (err && err.code !== "ENOENT") {
+      throw err;
+    }
+    const key = randomBytes(32).toString("hex");
+    await fs.writeFile(filePath, key, { mode: 0o600 });
+    return key;
+  }
+}
+
+const userSequenceStmt = (db: SqliteDatabase) =>
+  db.prepare(
+    `INSERT INTO user_sequences (userId, nextSequence)
+     VALUES (?, 1)
+     ON CONFLICT(userId)
+     DO UPDATE SET nextSequence = user_sequences.nextSequence + 1
+     RETURNING nextSequence as sequence`
+  );
+
+function sha256(input: string): string {
+  return createHash("sha256").update(input).digest("hex");
+}
+
+function hashAttachments(attachments: NormalizedAttachment[]): string {
+  const quote = (value: string) => JSON.stringify(value);
+  if (attachments.length === 0) {
+    return sha256("[]");
+  }
+  const parts = attachments.map((attachment) =>
+    attachment.type === "image"
+      ? `{"type":"image","mimeType":${quote(attachment.mimeType)},"data":${quote(attachment.data)}}`
+      : `{"type":"asset","assetId":${quote(attachment.assetId)}}`
+  );
+  return sha256(`[${parts.join(",")}]`);
+}
+
+type AdapterExecutionResult = { exitCode?: number; output?: string } | string;
+
+function normalizeAdapterResult(result: AdapterExecutionResult): { exitCode: number; output: string } {
+  if (typeof result === "string") {
+    return { exitCode: 0, output: result };
+  }
+  return {
+    exitCode: result?.exitCode ?? 0,
+    output: result?.output ?? ""
+  };
+}
+
+function nowMs(): number {
+  return Date.now();
+}
+
+function generateServerMessageId(): string {
+  return `s_${randomUUID()}`;
+}
+
+function generateUserId(): string {
+  return `user_${randomUUID()}`;
+}
+
+function buildPromptFromEvents(
+  events: ServerMessage[],
+  maxPromptMessages: number,
+  appendedUserContent: string
+): string {
+  const trimmed = events
+    .filter((event) => event.role === "user" || event.role === "assistant")
+    .slice(-maxPromptMessages + 1);
+  const lines = trimmed.map((event) => `${event.role === "user" ? "User" : "Assistant"}: ${event.content}`);
+  lines.push(`User: ${appendedUserContent}`);
+  return lines.join("\n");
+}
+
+function parseServerMessage(json: string): ServerMessage {
+  return JSON.parse(json) as ServerMessage;
+}
+
+export async function createProviderServer(options: ProviderOptions): Promise<ProviderServer> {
+  const config = mergeConfig(options.config);
+  const logger: Logger = options.logger ?? console;
+  const sessionStorePath = options.sessionStorePath;
+  
+  if (!config.network.allowInsecurePublic && !isLocalhost(config.network.bindAddress)) {
+    throw new Error("allowInsecurePublic must be true to bind non-localhost");
+  }
+  if (
+    config.network.allowInsecurePublic &&
+    !isLocalhost(config.network.bindAddress) &&
+    (!config.network.allowedOrigins || config.network.allowedOrigins.length === 0)
+  ) {
+    throw new Error("allowedOrigins must be configured when binding to a public interface");
+  }
+
+  await ensureDir(config.statePath);
+  await ensureDir(config.media.storagePath);
+  const assetsDir = path.join(config.media.storagePath, "assets");
+  const sessionTranscriptsDir = path.join(config.statePath, "sessions");
+  const tmpDir = path.join(config.media.storagePath, "tmp");
+  await ensureDir(assetsDir);
+  await ensureDir(tmpDir);
+  await ensureDir(sessionTranscriptsDir);
+  await cleanupTmpDirectory();
+
+  const allowlistPath = path.join(config.statePath, ALLOWLIST_FILENAME);
+  const denylistPath = path.join(config.statePath, DENYLIST_FILENAME);
+  const jwtKeyPath = path.join(config.statePath, JWT_KEY_FILENAME);
+  const dbPath = path.join(config.statePath, DB_FILENAME);
+
+  let allowlist = await loadAllowlist(allowlistPath);
+  let denylist = await loadDenylist(denylistPath);
+  const jwtKey = await ensureJwtKey(jwtKeyPath, config.auth.jwtSigningKey);
+
+  const db = new BetterSqlite3(dbPath, { fileMustExist: false });
+  db.exec("PRAGMA journal_mode = WAL");
+  db.exec("PRAGMA foreign_keys = ON");
+  db.exec(`
+    CREATE TABLE IF NOT EXISTS user_sequences (
+      userId TEXT PRIMARY KEY,
+      nextSequence INTEGER NOT NULL
+    );
+    CREATE TABLE IF NOT EXISTS events (
+      id TEXT PRIMARY KEY,
+      userId TEXT NOT NULL,
+      sequence INTEGER NOT NULL,
+      originatingDeviceId TEXT,
+      payloadJson TEXT NOT NULL,
+      payloadBytes INTEGER NOT NULL,
+      timestamp INTEGER NOT NULL
+    );
+    CREATE UNIQUE INDEX IF NOT EXISTS idx_events_userId_sequence ON events(userId, sequence);
+    CREATE INDEX IF NOT EXISTS idx_events_userId ON events(userId);
+    CREATE TABLE IF NOT EXISTS messages (
+      deviceId TEXT NOT NULL,
+      userId TEXT NOT NULL,
+      clientId TEXT NOT NULL,
+      serverEventId TEXT NOT NULL,
+      serverSequence INTEGER NOT NULL,
+      content TEXT NOT NULL,
+      contentHash TEXT NOT NULL,
+      attachmentsHash TEXT NOT NULL,
+      timestamp INTEGER NOT NULL,
+      streaming INTEGER NOT NULL,
+      ackSent INTEGER NOT NULL DEFAULT 0,
+      PRIMARY KEY (deviceId, clientId)
+    );
+    CREATE INDEX IF NOT EXISTS idx_messages_userId ON messages(userId);
+    CREATE INDEX IF NOT EXISTS idx_messages_serverEventId ON messages(serverEventId);
+    CREATE TABLE IF NOT EXISTS assets (
+      assetId TEXT PRIMARY KEY,
+      userId TEXT NOT NULL,
+      mimeType TEXT NOT NULL,
+      size INTEGER NOT NULL,
+      createdAt INTEGER NOT NULL,
+      uploaderDeviceId TEXT NOT NULL
+    );
+    CREATE INDEX IF NOT EXISTS idx_assets_userId ON assets(userId);
+    CREATE INDEX IF NOT EXISTS idx_assets_createdAt ON assets(createdAt);
+    CREATE TABLE IF NOT EXISTS message_assets (
+      deviceId TEXT NOT NULL,
+      clientId TEXT NOT NULL,
+      assetId TEXT NOT NULL,
+      PRIMARY KEY (deviceId, clientId, assetId),
+      FOREIGN KEY (deviceId, clientId) REFERENCES messages(deviceId, clientId) ON DELETE CASCADE,
+      FOREIGN KEY (assetId) REFERENCES assets(assetId) ON DELETE RESTRICT
+    );
+    CREATE INDEX IF NOT EXISTS idx_message_assets_assetId ON message_assets(assetId);
+  `);
+
+  const sequenceStatement = userSequenceStmt(db);
+  const insertEventStmt = db.prepare(
+    `INSERT INTO events (id, userId, sequence, originatingDeviceId, payloadJson, payloadBytes, timestamp)
+     VALUES (?, ?, ?, ?, ?, ?, ?)`
+  );
+  const updateMessageAckStmt = db.prepare(`UPDATE messages SET ackSent = 1 WHERE deviceId = ? AND clientId = ?`);
+  const insertMessageStmt = db.prepare(
+    `INSERT INTO messages (deviceId, userId, clientId, serverEventId, serverSequence, content, contentHash, attachmentsHash, timestamp, streaming, ackSent)
+     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ${MessageStreamingState.Active}, 0)`
+  );
+  const selectMessageStmt = db.prepare(
+    `SELECT deviceId, userId, clientId, serverEventId, serverSequence, content, contentHash, attachmentsHash, timestamp, streaming, ackSent
+     FROM messages WHERE deviceId = ? AND clientId = ?`
+  );
+  const updateMessageStreamingStmt = db.prepare(`UPDATE messages SET streaming = ? WHERE deviceId = ? AND clientId = ?`);
+  const insertMessageAssetStmt = db.prepare(
+    `INSERT INTO message_assets (deviceId, clientId, assetId) VALUES (?, ?, ?)`
+  );
+  const insertAssetStmt = db.prepare(
+    `INSERT INTO assets (assetId, userId, mimeType, size, createdAt, uploaderDeviceId) VALUES (?, ?, ?, ?, ?, ?)`
+  );
+  const selectAssetStmt = db.prepare(
+    `SELECT assetId, userId, mimeType, size, createdAt FROM assets WHERE assetId = ?`
+  );
+  const selectExpiredAssetsStmt = db.prepare(
+    `SELECT assetId FROM assets
+     WHERE createdAt <= ?
+       AND NOT EXISTS (
+         SELECT 1 FROM message_assets WHERE message_assets.assetId = assets.assetId
+       )`
+  );
+  const deleteAssetStmt = db.prepare(
+    `DELETE FROM assets
+     WHERE assetId = ?
+       AND NOT EXISTS (
+         SELECT 1 FROM message_assets WHERE message_assets.assetId = assets.assetId
+       )`
+  );
+  await cleanupOrphanedAssetFiles();
+  const insertUserMessageTx = db.transaction(
+    (
+      session: Session,
+      messageId: string,
+      content: string,
+      timestamp: number,
+      attachments: NormalizedAttachment[],
+      attachmentsHash: string,
+      assetIds: string[]
+    ) => {
+      for (const assetId of assetIds) {
+        const asset = selectAssetStmt.get(assetId) as { assetId: string; userId: string } | undefined;
+        if (!asset || asset.userId !== session.userId) {
+          throw new ClientMessageError("asset_not_found", "Asset not found");
+        }
+      }
+      const serverMessageId = generateServerMessageId();
+      const event: ServerMessage = {
+        type: "message",
+        id: serverMessageId,
+        role: "user",
+        content,
+        timestamp,
+        streaming: false,
+        deviceId: session.deviceId,
+        attachments: attachments.length > 0 ? attachments : undefined
+      };
+      const payloadJson = JSON.stringify(event);
+      const payloadBytes = Buffer.byteLength(payloadJson, "utf8");
+      const sequenceRow = sequenceStatement.get(session.userId) as { sequence: number };
+      insertEventStmt.run(
+        serverMessageId,
+        session.userId,
+        sequenceRow.sequence,
+        session.deviceId,
+        payloadJson,
+        payloadBytes,
+        timestamp
+      );
+      insertMessageStmt.run(
+        session.deviceId,
+        session.userId,
+        messageId,
+        serverMessageId,
+        sequenceRow.sequence,
+        content,
+        sha256(content),
+        attachmentsHash,
+        timestamp
+      );
+      for (const assetId of assetIds) {
+        insertMessageAssetStmt.run(session.deviceId, messageId, assetId);
+      }
+      return { event, sequence: sequenceRow.sequence };
+    }
+  );
+
+  type EventRow = { id: string; payloadJson: string };
+  const selectEventsAfterStmt = db.prepare(
+    `SELECT id, payloadJson FROM events WHERE userId = ? AND sequence > ? ORDER BY sequence ASC`
+  );
+  const selectEventsTailStmt = db.prepare(
+    `SELECT id, payloadJson FROM events WHERE userId = ? ORDER BY sequence DESC LIMIT ?`
+  );
+  const selectAnchorStmt = db.prepare(
+    `SELECT sequence FROM events WHERE id = ? AND userId = ?`
+  );
+  const insertEventTx = db.transaction((event: ServerMessage, userId: string, originatingDeviceId?: string) => {
+    const payloadJson = JSON.stringify(event);
+    const payloadBytes = Buffer.byteLength(payloadJson, "utf8");
+    const sequenceRow = sequenceStatement.get(userId) as { sequence: number };
+    insertEventStmt.run(event.id, userId, sequenceRow.sequence, originatingDeviceId ?? null, payloadJson, payloadBytes, event.timestamp);
+    return sequenceRow.sequence;
+  });
+
+  const httpServer = http.createServer(async (req, res) => {
+    try {
+      if (!req.url) {
+        res.writeHead(404).end();
+        return;
+      }
+      const parsedUrl = new URL(req.url, "http://localhost");
+      if (req.method === "GET" && parsedUrl.pathname === "/version") {
+        res.setHeader("Content-Type", "application/json");
+        res.writeHead(200);
+        res.end(JSON.stringify({ protocolVersion: PROTOCOL_VERSION }));
+        return;
+      }
+      if (req.method === "POST" && parsedUrl.pathname === "/upload") {
+        await handleUpload(req, res);
+        return;
+      }
+      if (req.method === "GET" && parsedUrl.pathname.startsWith("/download/")) {
+        const assetId = parsedUrl.pathname.slice("/download/".length);
+        await handleDownload(req, res, assetId);
+        return;
+      }
+      res.writeHead(404).end();
+    } catch (err) {
+      logger.error("http_request_failed", err);
+      if (!res.headersSent) {
+        sendHttpError(res, 500, "server_error", "Internal error");
+      } else {
+        res.end();
+      }
+    }
+  });
+
+  const sockets = new Set<net.Socket>();
+  httpServer.on("connection", (socket) => {
+    sockets.add(socket);
+    socket.on("close", () => sockets.delete(socket));
+  });
+
+  const wss = new WebSocketServer({ noServer: true });
+
+  httpServer.on("upgrade", (request, socket, head) => {
+    if (request.url !== "/ws") {
+      socket.destroy();
+      return;
+    }
+    if (config.network.allowedOrigins && config.network.allowedOrigins.length > 0) {
+      const origin = request.headers.origin ?? "null";
+      if (!config.network.allowedOrigins.includes(origin)) {
+        socket.write("HTTP/1.1 403 Forbidden\r\n\r\n");
+        socket.destroy();
+        return;
+      }
+    }
+    wss.handleUpgrade(request, socket, head, (ws) => {
+      wss.emit("connection", ws, request);
+    });
+  });
+
+  const connectionState = new WeakMap<WebSocket, ConnectionState>();
+  const pendingPairs = new Map<string, PendingPairRequest>();
+  const deniedDevices = new Map<string, number>();
+  const deniedDeviceTtlMs = Math.max(1, config.pairing.pendingTtlSeconds) * 1000;
+  const sessionsByDevice = new Map<string, Session>();
+  const userSessions = new Map<string, Set<Session>>();
+  const perUserQueue = new Map<string, Promise<unknown>>();
+  const pairRateLimiter = new SlidingWindowRateLimiter(config.pairing.maxRequestsPerMinute, 60_000);
+  const authRateLimiter = new SlidingWindowRateLimiter(config.auth.maxAttemptsPerMinute, 60_000);
+  const messageRateLimiter = new SlidingWindowRateLimiter(config.sessions.maxMessagesPerSecond, 1_000);
+  let writeQueue: Promise<void> = Promise.resolve();
+  const pendingCleanupInterval = setInterval(() => expirePendingPairs(), 1_000);
+  if (typeof pendingCleanupInterval.unref === "function") {
+    pendingCleanupInterval.unref();
+  }
+  const maintenanceIntervalMs = Math.min(60_000, Math.max(1_000, config.media.unreferencedUploadTtlSeconds * 250));
+  const assetCleanupInterval =
+    config.media.unreferencedUploadTtlSeconds > 0
+      ? setInterval(() => {
+          cleanupUnreferencedAssets().catch((err) => logger.warn("asset_cleanup_failed", err));
+        }, maintenanceIntervalMs)
+      : null;
+  if (assetCleanupInterval && typeof assetCleanupInterval.unref === "function") {
+    assetCleanupInterval.unref();
+  }
+  const denylistWatcher = () => {
+    void refreshDenylist();
+  };
+  watchFile(denylistPath, { interval: 5_000 }, denylistWatcher);
+
+  function runPerUserTask<T>(userId: string, task: () => Promise<T>): Promise<T> {
+    const previous = perUserQueue.get(userId) ?? Promise.resolve();
+    const next = previous.then(task, task).finally(() => {
+      if (perUserQueue.get(userId) === next) {
+        perUserQueue.delete(userId);
+      }
+    });
+    perUserQueue.set(userId, next);
+    return next;
+  }
+
+  function enqueueWriteTask<T>(task: () => T | Promise<T>): Promise<T> {
+    const run = () => Promise.resolve().then(task);
+    const result = writeQueue.then(run, run);
+    writeQueue = result.then(
+      () => undefined,
+      () => undefined
+    );
+    return result;
+  }
+
+  async function persistAllowlist() {
+    await fs.writeFile(allowlistPath, JSON.stringify(allowlist, null, 2));
+  }
+
+  async function refreshDenylist() {
+    try {
+      const next = await loadDenylist(denylistPath);
+      const newlyRevoked = next.filter(
+        (entry) => !denylist.some((existing) => existing.deviceId === entry.deviceId)
+      );
+      denylist = next;
+      for (const revoked of newlyRevoked) {
+        const session = sessionsByDevice.get(revoked.deviceId);
+        if (session) {
+          sendJson(session.socket, { type: "error", code: "token_revoked", message: "Device revoked" })
+            .catch(() => {})
+            .finally(() => session.socket.close(1008));
+        }
+      }
+    } catch (err) {
+      logger.warn("denylist_reload_failed", err);
+    }
+  }
+
+  function findAllowlistEntry(deviceId: string) {
+    return allowlist.entries.find((entry) => entry.deviceId === deviceId);
+  }
+
+  async function upsertAllowlistEntry(entry: AllowlistEntry) {
+    const idx = allowlist.entries.findIndex((existing) => existing.deviceId === entry.deviceId);
+    if (idx >= 0) {
+      allowlist.entries[idx] = entry;
+    } else {
+      allowlist.entries.push(entry);
+    }
+    await persistAllowlist();
+  }
+
+  function isDenylisted(deviceId: string) {
+    return denylist.some((entry) => entry.deviceId === deviceId);
+  }
+
+  function issueToken(entry: AllowlistEntry): string {
+    const payload: jwt.JwtPayload = {
+      sub: entry.userId,
+      deviceId: entry.deviceId,
+      isAdmin: entry.isAdmin,
+      iat: Math.floor(Date.now() / 1000)
+    };
+    if (config.auth.tokenTtlSeconds) {
+      payload.exp = payload.iat! + config.auth.tokenTtlSeconds;
+    }
+    const token = jwt.sign(payload, jwtKey, { algorithm: "HS256" });
+    return token;
+  }
+
+  async function setTokenDelivered(deviceId: string, delivered: boolean) {
+    const entry = findAllowlistEntry(deviceId);
+    if (!entry) return;
+    entry.tokenDelivered = delivered;
+    await persistAllowlist();
+  }
+
+  async function updateLastSeen(deviceId: string, timestamp: number) {
+    const entry = findAllowlistEntry(deviceId);
+    if (!entry) return;
+    entry.lastSeenAt = timestamp;
+    await persistAllowlist();
+  }
+
+  function sendJson(ws: WebSocket, payload: unknown): Promise<void> {
+    return new Promise((resolve, reject) => {
+      if (ws.readyState !== WebSocket.OPEN) {
+        reject(new Error("socket not open"));
+        return;
+      }
+      ws.send(JSON.stringify(payload), (err) => {
+        if (err) {
+          reject(err);
+        } else {
+          resolve();
+        }
+      });
+    });
+  }
+
+  function markAckSent(deviceId: string, clientId: string) {
+    updateMessageAckStmt.run(deviceId, clientId);
+  }
+
+  function sendHttpError(res: http.ServerResponse, status: number, code: string, message: string) {
+    res.setHeader("Content-Type", "application/json");
+    res.writeHead(status);
+    res.end(JSON.stringify({ type: "error", code, message }));
+  }
+
+  function authenticateHttpRequest(req: http.IncomingMessage) {
+    const header = req.headers.authorization;
+    if (!header || !header.startsWith("Bearer ")) {
+      throw new HttpError(401, "auth_failed", "Missing authorization");
+    }
+    const token = header.slice(7).trim();
+    if (!token) {
+      throw new HttpError(401, "auth_failed", "Missing token");
+    }
+    let decoded: jwt.JwtPayload;
+    try {
+      decoded = jwt.verify(token, jwtKey, { algorithms: ["HS256"] }) as jwt.JwtPayload;
+    } catch {
+      throw new HttpError(401, "auth_failed", "Invalid token");
+    }
+    const deviceId = decoded.deviceId;
+    if (typeof deviceId !== "string" || !validateDeviceId(deviceId)) {
+      throw new HttpError(401, "auth_failed", "Invalid token device");
+    }
+    if (isDenylisted(deviceId)) {
+      throw new HttpError(403, "token_revoked", "Device revoked");
+    }
+    const entry = findAllowlistEntry(deviceId);
+    if (!entry) {
+      throw new HttpError(401, "auth_failed", "Unknown device");
+    }
+    if (typeof decoded.sub !== "string" || !timingSafeStringEqual(decoded.sub, entry.userId)) {
+      throw new HttpError(401, "auth_failed", "Invalid token subject");
+    }
+    if (typeof decoded.exp === "number" && decoded.exp * 1000 < Date.now()) {
+      throw new HttpError(401, "auth_failed", "Token expired");
+    }
+    return { deviceId, userId: entry.userId };
+  }
+
+  async function safeUnlink(filePath: string) {
+    try {
+      await fs.unlink(filePath);
+    } catch (err: any) {
+      if (!err || err.code === "ENOENT") {
+        return;
+      }
+      logger.warn("file_unlink_failed", err);
+    }
+  }
+
+  async function cleanupTmpDirectory() {
+    try {
+      const entries = await fs.readdir(tmpDir);
+      await Promise.all(entries.map((entry) => safeUnlink(path.join(tmpDir, entry))));
+    } catch (err) {
+      logger.warn("tmp_cleanup_failed", err);
+    }
+  }
+
+  async function cleanupOrphanedAssetFiles() {
+    const startedAt = nowMs();
+    try {
+      const entries = await fs.readdir(assetsDir);
+      const now = nowMs();
+      const batchSize = 10_000;
+      for (let i = 0; i < entries.length; i += batchSize) {
+        const batch = entries.slice(i, i + batchSize);
+        for (const entry of batch) {
+          if (!ASSET_ID_REGEX.test(entry)) continue;
+          const asset = selectAssetStmt.get(entry);
+          if (asset) continue;
+          const filePath = path.join(assetsDir, entry);
+          if (config.media.unreferencedUploadTtlSeconds > 0) {
+            try {
+              const stats = await fs.stat(filePath);
+              const ageMs = now - stats.mtimeMs;
+              if (ageMs < config.media.unreferencedUploadTtlSeconds * 1000) {
+                continue;
+              }
+            } catch {
+              continue;
+            }
+          }
+          await safeUnlink(filePath);
+        }
+      }
+    } catch (err) {
+      logger.warn("asset_orphan_scan_failed", err);
+    } finally {
+      const elapsedMs = nowMs() - startedAt;
+      if (elapsedMs > 30_000) {
+        logger.warn("asset_orphan_scan_slow", { elapsedMs });
+      }
+    }
+  }
+
+  async function cleanupUnreferencedAssets() {
+    if (config.media.unreferencedUploadTtlSeconds <= 0) {
+      return;
+    }
+    const cutoff = nowMs() - config.media.unreferencedUploadTtlSeconds * 1000;
+    const deletedAssetIds = (await enqueueWriteTask(() => {
+      const rows = selectExpiredAssetsStmt.all(cutoff) as { assetId: string }[];
+      const deleted: string[] = [];
+      for (const row of rows) {
+        const result = deleteAssetStmt.run(row.assetId);
+        if (result.changes > 0) {
+          deleted.push(row.assetId);
+        }
+      }
+      return deleted;
+    })) as string[];
+    for (const assetId of deletedAssetIds) {
+      const assetPath = path.join(assetsDir, assetId);
+      await safeUnlink(assetPath);
+    }
+  }
+
+  async function handleUpload(req: http.IncomingMessage, res: http.ServerResponse) {
+    let tmpPath: string | undefined;
+    try {
+      const auth = authenticateHttpRequest(req);
+      const assetId = `a_${randomUUID()}`;
+      tmpPath = path.join(tmpDir, `${assetId}.tmp`);
+      let detectedMime = "application/octet-stream";
+      let size = 0;
+      await new Promise<void>((resolve, reject) => {
+        const busboy = Busboy({
+          headers: req.headers,
+          limits: { files: 1, fileSize: config.media.maxUploadBytes }
+        });
+        let handled = false;
+        busboy.on("file", (fieldname, file, info) => {
+          if (handled || fieldname !== "file") {
+            handled = true;
+            file.resume();
+            reject(new ClientMessageError("invalid_message", "Invalid upload field"));
+            return;
+          }
+          handled = true;
+          detectedMime = info.mimeType || "application/octet-stream";
+          const writeStream = createWriteStream(tmpPath!);
+          let aborted = false;
+          file.on("data", (chunk) => {
+            size += chunk.length;
+            if (!aborted && size > config.media.maxUploadBytes) {
+              aborted = true;
+              file.unpipe(writeStream);
+              writeStream.destroy();
+              file.resume();
+              reject(new ClientMessageError("payload_too_large", "Upload too large"));
+            }
+          });
+          file.on("limit", () => reject(new ClientMessageError("payload_too_large", "Upload too large")));
+          file.on("error", reject);
+          writeStream.on("error", reject);
+          file.pipe(writeStream);
+          file.on("end", () => writeStream.end());
+        });
+        busboy.on("finish", () => {
+          if (!handled) {
+            reject(new ClientMessageError("invalid_message", "Missing file field"));
+            return;
+          }
+          resolve();
+        });
+        busboy.on("error", reject);
+        req.pipe(busboy);
+      });
+      if (size === 0) {
+        throw new ClientMessageError("invalid_message", "Empty upload");
+      }
+      const finalPath = path.join(assetsDir, assetId);
+      await fs.rename(tmpPath, finalPath);
+      await enqueueWriteTask(() => insertAssetStmt.run(assetId, auth.userId, detectedMime, size, nowMs(), auth.deviceId));
+      res.setHeader("Content-Type", "application/json");
+      res.writeHead(200);
+      res.end(JSON.stringify({ assetId, mimeType: detectedMime, size }));
+    } catch (err) {
+      if (tmpPath) {
+        await safeUnlink(tmpPath);
+      }
+      if (err instanceof HttpError) {
+        sendHttpError(res, err.status, err.code, err.message);
+        return;
+      }
+      if (err instanceof ClientMessageError) {
+        const status = err.code === "payload_too_large" ? 413 : 400;
+        sendHttpError(res, status, err.code, err.message);
+        return;
+      }
+      logger.error("upload_failed", err);
+      sendHttpError(res, 503, "upload_failed_retryable", "Upload failed");
+    }
+  }
+
+  async function handleDownload(req: http.IncomingMessage, res: http.ServerResponse, assetId: string) {
+    try {
+      const auth = authenticateHttpRequest(req);
+      if (!ASSET_ID_REGEX.test(assetId)) {
+        sendHttpError(res, 400, "invalid_message", "Invalid assetId");
+        return;
+      }
+      const asset = selectAssetStmt.get(assetId) as
+        | { assetId: string; userId: string; mimeType: string; size: number }
+        | undefined;
+      if (!asset) {
+        sendHttpError(res, 404, "asset_not_found", "Asset not found");
+        return;
+      }
+      if (asset.userId !== auth.userId) {
+        sendHttpError(res, 404, "asset_not_found", "Asset not found");
+        return;
+      }
+      const filePath = path.join(assetsDir, assetId);
+      let fileHandle: fs.FileHandle;
+      try {
+        fileHandle = await fs.open(filePath, "r");
+      } catch (err: any) {
+        if (err && err.code === "ENOENT") {
+          await enqueueWriteTask(() => deleteAssetStmt.run(assetId));
+          sendHttpError(res, 404, "asset_not_found", "Asset not found");
+          return;
+        }
+        throw err;
+      }
+      res.writeHead(200, {
+        "Content-Type": asset.mimeType || "application/octet-stream",
+        "Content-Length": asset.size
+      });
+      const stream = fileHandle.createReadStream();
+      stream.on("error", (err) => {
+        logger.error("download_stream_failed", err);
+        if (!res.headersSent) {
+          sendHttpError(res, 500, "server_error", "Download failed");
+        } else {
+          res.end();
+        }
+      });
+      stream.on("close", () => {
+        fileHandle
+          .close()
+          .catch(() => {});
+      });
+      stream.pipe(res);
+    } catch (err) {
+      if (err instanceof HttpError) {
+        sendHttpError(res, err.status, err.code, err.message);
+        return;
+      }
+      logger.error("download_failed", err);
+      sendHttpError(res, 500, "server_error", "Download failed");
+    }
+  }
+
+  function selectEventsAfter(userId: string, lastMessageId: string | null) {
+    if (!lastMessageId) {
+      const rows = selectEventsTailStmt.all(userId, config.sessions.maxReplayMessages) as EventRow[];
+      return rows.map((row) => parseServerMessage(row.payloadJson)).reverse();
+    }
+    const anchor = selectAnchorStmt.get(lastMessageId, userId) as
+      | { sequence: number }
+      | undefined;
+    if (!anchor) {
+      const tail = selectEventsTailStmt.all(userId, config.sessions.maxReplayMessages) as EventRow[];
+      return tail.map((row) => parseServerMessage(row.payloadJson)).reverse();
+    }
+    const rows = selectEventsAfterStmt.all(userId, anchor.sequence) as EventRow[];
+    return rows.map((row) => parseServerMessage(row.payloadJson));
+  }
+
+  async function sendReplay(session: Session, lastMessageId: string | null) {
+    const events = selectEventsAfter(session.userId, lastMessageId);
+    const payload = {
+      type: "auth_result",
+      success: true,
+      userId: session.userId,
+      sessionId: session.sessionId,
+      replayCount: events.length,
+      replayTruncated: false,
+      historyReset: lastMessageId ? false : true
+    };
+    await sendJson(session.socket, payload);
+    for (const event of events) {
+      await sendJson(session.socket, event);
+    }
+  }
+
+  function broadcastToUser(userId: string, payload: ServerMessage) {
+    const sessions = userSessions.get(userId);
+    if (!sessions) return;
+    for (const session of sessions) {
+      if (session.socket.readyState !== WebSocket.OPEN) continue;
+      session.socket.send(JSON.stringify(payload), (err) => {
+        if (err) {
+          session.socket.close();
+        }
+      });
+    }
+  }
+
+  async function appendEvent(event: ServerMessage, userId: string, originatingDeviceId?: string) {
+    return enqueueWriteTask(() => insertEventTx(event, userId, originatingDeviceId));
+  }
+
+  async function persistUserMessage(
+    session: Session,
+    messageId: string,
+    content: string,
+    attachments: NormalizedAttachment[],
+    attachmentsHash: string,
+    assetIds: string[]
+  ): Promise<{ event: ServerMessage; sequence: number }> {
+    const timestamp = nowMs();
+    try {
+      return await enqueueWriteTask(() =>
+        insertUserMessageTx(session, messageId, content, timestamp, attachments, attachmentsHash, assetIds)
+      );
+    } catch (err: any) {
+      if (err && typeof err.message === "string" && err.message.includes("FOREIGN KEY")) {
+        throw new ClientMessageError("asset_not_found", "Asset not found");
+      }
+      throw err;
+    }
+  }
+
+  async function persistAssistantMessage(
+    session: Session,
+    content: string
+  ): Promise<ServerMessage> {
+    const timestamp = nowMs();
+    const event: ServerMessage = {
+      type: "message",
+      id: generateServerMessageId(),
+      role: "assistant",
+      content,
+      timestamp,
+      streaming: false
+    };
+    await appendEvent(event, session.userId);
+    return event;
+  }
+
+  function getConversationEvents(userId: string) {
+    const rows = db
+      .prepare(`SELECT payloadJson FROM events WHERE userId = ? ORDER BY sequence ASC LIMIT ?`)
+      .all(userId, config.sessions.maxPromptMessages - 1) as Array<{ payloadJson: string }>;
+    return rows.map((row) => parseServerMessage(row.payloadJson));
+  }
+
+  function removeSession(session: Session) {
+    sessionsByDevice.delete(session.deviceId);
+    const sessions = userSessions.get(session.userId);
+    if (sessions) {
+      sessions.delete(session);
+      if (sessions.size === 0) {
+        userSessions.delete(session.userId);
+      }
+    }
+  }
+
+  function registerSession(session: Session) {
+    const existing = sessionsByDevice.get(session.deviceId);
+    if (existing && existing.socket !== session.socket) {
+      sendJson(existing.socket, { type: "error", code: "session_replaced", message: "Session replaced" })
+        .catch(() => {})
+        .finally(() => existing.socket.close(SESSION_REPLACED_CODE));
+      removeSession(existing);
+    }
+    sessionsByDevice.set(session.deviceId, session);
+    const set = userSessions.get(session.userId) ?? new Set();
+    set.add(session);
+    userSessions.set(session.userId, set);
+    void syncSessionStore(session);
+  }
+
+  async function syncSessionStore(session: Session) {
+    await recordClawlineSessionActivity({
+      storePath: sessionStorePath,
+      sessionKey: session.sessionKey,
+      sessionId: session.sessionId,
+      sessionFile: path.join(
+        sessionTranscriptsDir,
+        `${clawlineSessionFileName(session.sessionKey)}.jsonl`,
+      ),
+      displayName: session.claimedName ?? session.deviceInfo?.model ?? null,
+      logger,
+    });
+  }
+
+  async function processClientMessage(session: Session, payload: any) {
+    try {
+      if (payload.type !== "message") {
+        throw new ClientMessageError("invalid_message", "Unsupported type");
+      }
+      if (typeof payload.id !== "string" || !payload.id.startsWith("c_")) {
+        throw new ClientMessageError("invalid_message", "Invalid id");
+      }
+      if (typeof payload.content !== "string" || payload.content.length === 0) {
+        throw new ClientMessageError("invalid_message", "Missing content");
+      }
+      const contentBytes = Buffer.byteLength(payload.content, "utf8");
+      if (contentBytes > config.sessions.maxMessageBytes) {
+        throw new ClientMessageError("payload_too_large", "Message too large");
+      }
+      const attachmentsInfo = normalizeAttachmentsInput(payload.attachments, config.media);
+      if (contentBytes + attachmentsInfo.inlineBytes > MAX_TOTAL_PAYLOAD_BYTES) {
+        throw new ClientMessageError("payload_too_large", "Message too large");
+      }
+      const attachmentsHash = hashAttachments(attachmentsInfo.attachments);
+
+      await runPerUserTask(session.userId, async () => {
+        const existing = selectMessageStmt.get(session.deviceId, payload.id) as
+          | {
+              deviceId: string;
+              contentHash: string;
+              attachmentsHash: string;
+              streaming: number;
+              ackSent: number;
+            }
+          | undefined;
+        const incomingHash = sha256(payload.content);
+        if (existing) {
+          if (existing.contentHash !== incomingHash || existing.attachmentsHash !== attachmentsHash) {
+            throw new ClientMessageError("invalid_message", "Duplicate mismatch");
+          }
+          if (existing.streaming === MessageStreamingState.Failed) {
+            throw new ClientMessageError("invalid_message", "Message failed");
+          }
+          if (existing.ackSent === 0) {
+            session.socket.send(JSON.stringify({ type: "ack", id: payload.id }), (err) => {
+              if (!err) {
+                markAckSent(session.deviceId, payload.id);
+              }
+            });
+          } else {
+            session.socket.send(JSON.stringify({ type: "ack", id: payload.id }), () => {});
+          }
+          return;
+        }
+
+        if (!messageRateLimiter.attempt(session.deviceId)) {
+          throw new ClientMessageError("rate_limited", "Too many messages");
+        }
+
+        const { event } = await persistUserMessage(
+          session,
+          payload.id,
+          payload.content,
+          attachmentsInfo.attachments,
+          attachmentsHash,
+          attachmentsInfo.assetIds
+        );
+        await new Promise<void>((resolve) => {
+          session.socket.send(JSON.stringify({ type: "ack", id: payload.id }), (err) => {
+            if (!err) {
+              markAckSent(session.deviceId, payload.id);
+            }
+            resolve();
+          });
+        });
+        broadcastToUser(session.userId, event);
+
+        const priorEvents = getConversationEvents(session.userId);
+        const prompt = buildPromptFromEvents(priorEvents, config.sessions.maxPromptMessages, payload.content);
+        try {
+          const adapterResult = await Promise.race<AdapterExecutionResult>([
+            options.adapter.execute({
+              prompt,
+              userId: session.userId,
+              sessionId: session.sessionId,
+              deviceId: session.deviceId
+            }),
+            new Promise((_, reject) =>
+              setTimeout(() => reject(new Error("adapter_timeout")), config.sessions.adapterExecuteTimeoutSeconds * 1000)
+            )
+          ]);
+          const normalizedResult = normalizeAdapterResult(adapterResult);
+          if ((normalizedResult.exitCode ?? 0) !== 0) {
+            updateMessageStreamingStmt.run(MessageStreamingState.Failed, session.deviceId, payload.id);
+            await sendJson(session.socket, {
+              type: "error",
+              code: "server_error",
+              message: "Adapter error",
+              messageId: payload.id
+            });
+            return;
+          }
+          const assistantEvent = await persistAssistantMessage(session, normalizedResult.output ?? "");
+          broadcastToUser(session.userId, assistantEvent);
+          updateMessageStreamingStmt.run(MessageStreamingState.Finalized, session.deviceId, payload.id);
+        } catch {
+          updateMessageStreamingStmt.run(MessageStreamingState.Failed, session.deviceId, payload.id);
+          await sendJson(session.socket, {
+            type: "error",
+            code: "server_error",
+            message: "Adapter failure",
+            messageId: payload.id
+          });
+        }
+      });
+    } catch (err) {
+      if (err instanceof ClientMessageError) {
+        await sendJson(session.socket, { type: "error", code: err.code, message: err.message });
+        return;
+      }
+      throw err;
+    }
+  }
+
+  async function notifyAdminsOfPending() {
+    for (const session of sessionsByDevice.values()) {
+      if (!session.isAdmin) continue;
+      for (const pending of pendingPairs.values()) {
+        await sendJson(session.socket, {
+          type: "pair_approval_request",
+          deviceId: pending.deviceId,
+          claimedName: pending.claimedName,
+          deviceInfo: pending.deviceInfo
+        }).catch(() => {});
+      }
+    }
+  }
+
+  function expirePendingPairs() {
+    if (config.pairing.pendingTtlSeconds <= 0) {
+      return;
+    }
+    const now = nowMs();
+    for (const [deviceId, pending] of pendingPairs) {
+      if (now - pending.createdAt >= config.pairing.pendingTtlSeconds * 1000) {
+        pendingPairs.delete(deviceId);
+        void sendJson(pending.socket, { type: "pair_result", success: false, reason: "pair_timeout" }).finally(() => {
+          pending.socket.close(1000);
+        });
+      }
+    }
+  }
+
+  function handleSocketClose(socket: WebSocket) {
+    const state = connectionState.get(socket);
+    if (!state) return;
+    if (state.deviceId && state.userId && state.sessionId) {
+      const session = sessionsByDevice.get(state.deviceId);
+      if (session && session.socket === socket) {
+        removeSession(session);
+      }
+    }
+
+    connectionState.delete(socket);
+  }
+
+  function hasAdmin(): boolean {
+    return allowlist.entries.some((entry) => entry.isAdmin);
+  }
+
+  function validateDeviceId(value: unknown): value is string {
+    return typeof value === "string" && UUID_V4_REGEX.test(value);
+  }
+
+  wss.on("connection", (ws) => {
+    connectionState.set(ws, { authenticated: false });
+
+    ws.on("message", async (raw) => {
+      let payload: any;
+      try {
+        payload = JSON.parse(rawDataToString(raw));
+      } catch {
+        await sendJson(ws, { type: "error", code: "invalid_message", message: "Malformed JSON" });
+        ws.close();
+        return;
+      }
+      if (!payload || typeof payload.type !== "string") {
+        await sendJson(ws, { type: "error", code: "invalid_message", message: "Missing type" });
+        return;
+      }
+      switch (payload.type) {
+        case "pair_request":
+          await handlePairRequest(ws, payload);
+          break;
+        case "pair_decision":
+          await handlePairDecision(ws, payload);
+          break;
+        case "auth":
+          await handleAuth(ws, payload);
+          break;
+        case "message":
+          await handleAuthedMessage(ws, payload);
+          break;
+        default:
+          await sendJson(ws, { type: "error", code: "invalid_message", message: "Unknown type" });
+      }
+    });
+
+    ws.on("close", () => handleSocketClose(ws));
+    ws.on("error", () => handleSocketClose(ws));
+  });
+
+  async function handlePairRequest(ws: WebSocket, payload: any) {
+    if (payload.protocolVersion !== PROTOCOL_VERSION) {
+      await sendJson(ws, { type: "error", code: "invalid_message", message: "Unsupported protocol" });
+      ws.close();
+      return;
+    }
+    if (!validateDeviceId(payload.deviceId)) {
+      await sendJson(ws, { type: "error", code: "invalid_message", message: "Invalid deviceId" });
+      return;
+    }
+    sweepDeniedDevices();
+    if (deniedDevices.has(payload.deviceId)) {
+      deniedDevices.delete(payload.deviceId);
+      await sendJson(ws, { type: "pair_result", success: false, reason: "pair_denied" });
+      ws.close();
+      return;
+    }
+    if (!pairRateLimiter.attempt(payload.deviceId)) {
+      await sendJson(ws, { type: "error", code: "rate_limited", message: "Pairing rate limited" });
+      ws.close(1008);
+      return;
+    }
+    if (isDenylisted(payload.deviceId)) {
+      await sendJson(ws, { type: "pair_result", success: false, reason: "pair_rejected" });
+      ws.close();
+      return;
+    }
+    if (!validateDeviceInfo(payload.deviceInfo)) {
+      await sendJson(ws, { type: "error", code: "invalid_message", message: "Invalid device info" });
+      return;
+    }
+    const sanitizedInfo = sanitizeDeviceInfo(payload.deviceInfo);
+    if (!sanitizedInfo.platform || !sanitizedInfo.model) {
+      await sendJson(ws, { type: "error", code: "invalid_message", message: "Invalid device info" });
+      return;
+    }
+    const sanitizedClaimedName = sanitizeLabel(payload.claimedName);
+
+    const entry = findAllowlistEntry(payload.deviceId);
+    if (entry && !entry.tokenDelivered) {
+      const token = issueToken(entry);
+      const delivered = await sendJson(ws, { type: "pair_result", success: true, token, userId: entry.userId })
+        .then(() => true)
+        .catch(() => false);
+      if (delivered) {
+        await setTokenDelivered(payload.deviceId, true);
+      }
+      ws.close();
+      return;
+    }
+    if (entry && entry.tokenDelivered && entry.lastSeenAt === null) {
+      const now = nowMs();
+      const graceMs = config.auth.reissueGraceSeconds * 1000;
+      if (now - entry.createdAt <= graceMs) {
+        const token = issueToken(entry);
+        const delivered = await sendJson(ws, { type: "pair_result", success: true, token, userId: entry.userId })
+          .then(() => true)
+          .catch(() => false);
+        if (delivered) {
+          await updateLastSeen(entry.deviceId, now);
+        }
+        ws.close();
+        return;
+      }
+    }
+    if (!hasAdmin()) {
+      const userId = generateUserId();
+      const newEntry: AllowlistEntry = {
+        deviceId: payload.deviceId,
+        claimedName: sanitizedClaimedName,
+        deviceInfo: sanitizedInfo,
+        userId,
+        isAdmin: true,
+        tokenDelivered: false,
+        createdAt: nowMs(),
+        lastSeenAt: null
+      };
+      allowlist.entries.push(newEntry);
+      await persistAllowlist();
+      const token = issueToken(newEntry);
+      const delivered = await sendJson(ws, { type: "pair_result", success: true, token, userId })
+        .then(() => true)
+        .catch(() => false);
+      if (delivered) {
+        await setTokenDelivered(payload.deviceId, true);
+      }
+      ws.close();
+      return;
+    }
+
+    if (entry && entry.tokenDelivered) {
+      await sendJson(ws, { type: "error", code: "invalid_message", message: "Device already paired" });
+      ws.close();
+      return;
+    }
+
+    const pending = pendingPairs.get(payload.deviceId);
+    if (pending) {
+      pending.socket = ws;
+      await notifyAdminsOfPending();
+      return;
+    }
+
+    if (pendingPairs.size >= config.pairing.maxPendingRequests) {
+      await sendJson(ws, { type: "error", code: "rate_limited", message: "Too many pending requests" });
+      ws.close(1008);
+      return;
+    }
+
+    pendingPairs.set(payload.deviceId, {
+      deviceId: payload.deviceId,
+      socket: ws,
+      claimedName: sanitizedClaimedName,
+      deviceInfo: sanitizedInfo,
+      createdAt: nowMs()
+    });
+    await notifyAdminsOfPending();
+  }
+
+  function sweepDeniedDevices() {
+    const now = nowMs();
+    for (const [deviceId, timestamp] of deniedDevices) {
+      if (now - timestamp >= deniedDeviceTtlMs) {
+        deniedDevices.delete(deviceId);
+      }
+    }
+  }
+
+  async function handlePairDecision(ws: WebSocket, payload: any) {
+    const state = connectionState.get(ws);
+    if (!state || !state.authenticated || !state.deviceId || !state.userId) {
+      await sendJson(ws, { type: "error", code: "invalid_message", message: "Not authenticated" });
+      return;
+    }
+    const session = sessionsByDevice.get(state.deviceId);
+    if (!session || !session.isAdmin) {
+      await sendJson(ws, { type: "error", code: "invalid_message", message: "Not admin" });
+      return;
+    }
+    const pending = pendingPairs.get(payload.deviceId);
+    if (!pending) {
+      await sendJson(ws, { type: "error", code: "invalid_message", message: "Unknown device" });
+      return;
+    }
+    if (payload.approve !== true) {
+      const delivered = await sendJson(pending.socket, { type: "pair_result", success: false, reason: "pair_denied" })
+        .then(() => true)
+        .catch(() => false);
+      if (!delivered) {
+        deniedDevices.set(payload.deviceId, nowMs());
+      }
+      pendingPairs.delete(payload.deviceId);
+      return;
+    }
+    if (!validateUserId(payload.userId)) {
+      await sendJson(ws, { type: "error", code: "invalid_message", message: "Invalid userId" });
+      return;
+    }
+    const userId = payload.userId;
+    const newEntry: AllowlistEntry = {
+      deviceId: pending.deviceId,
+      claimedName: pending.claimedName,
+      deviceInfo: pending.deviceInfo,
+      userId,
+      isAdmin: false,
+      tokenDelivered: false,
+      createdAt: nowMs(),
+      lastSeenAt: null
+    };
+    await upsertAllowlistEntry(newEntry);
+    const token = issueToken(newEntry);
+    const delivered = await sendJson(pending.socket, { type: "pair_result", success: true, token, userId })
+      .then(() => true)
+      .catch(() => false);
+    if (delivered) {
+      await setTokenDelivered(pending.deviceId, true);
+    }
+    pendingPairs.delete(pending.deviceId);
+  }
+
+  async function handleAuth(ws: WebSocket, payload: any) {
+    if (payload.protocolVersion !== PROTOCOL_VERSION) {
+      await sendJson(ws, { type: "error", code: "invalid_message", message: "Unsupported protocol" });
+      ws.close();
+      return;
+    }
+    if (typeof payload.token !== "string" || !validateDeviceId(payload.deviceId)) {
+      await sendJson(ws, { type: "auth_result", success: false, reason: "auth_failed" });
+      ws.close();
+      return;
+    }
+    if (pendingPairs.has(payload.deviceId)) {
+      await sendJson(ws, { type: "auth_result", success: false, reason: "device_not_approved" });
+      ws.close();
+      return;
+    }
+    if (!authRateLimiter.attempt(payload.deviceId)) {
+      await sendJson(ws, { type: "auth_result", success: false, reason: "rate_limited" });
+      ws.close(1008);
+      return;
+    }
+    let decoded: jwt.JwtPayload;
+    try {
+      decoded = jwt.verify(payload.token, jwtKey, { algorithms: ["HS256"] }) as jwt.JwtPayload;
+    } catch {
+      await sendJson(ws, { type: "auth_result", success: false, reason: "auth_failed" });
+      ws.close();
+      return;
+    }
+    if (typeof decoded.deviceId !== "string" || !timingSafeStringEqual(decoded.deviceId, payload.deviceId)) {
+      await sendJson(ws, { type: "auth_result", success: false, reason: "auth_failed" });
+      ws.close();
+      return;
+    }
+    const entry = findAllowlistEntry(payload.deviceId);
+    if (!entry) {
+      await sendJson(ws, { type: "auth_result", success: false, reason: "auth_failed" });
+      ws.close();
+      return;
+    }
+    if (typeof decoded.sub !== "string" || !timingSafeStringEqual(decoded.sub, entry.userId)) {
+      await sendJson(ws, { type: "auth_result", success: false, reason: "auth_failed" });
+      ws.close();
+      return;
+    }
+    const sessionKey = buildClawlineSessionKey(entry.userId, entry.deviceId);
+    const session: Session = {
+      socket: ws,
+      deviceId: entry.deviceId,
+      userId: entry.userId,
+      isAdmin: entry.isAdmin,
+      sessionId: `session_${randomUUID()}`,
+      sessionKey,
+      claimedName: entry.claimedName,
+      deviceInfo: entry.deviceInfo,
+    };
+    registerSession(session);
+    connectionState.set(ws, {
+      authenticated: true,
+      deviceId: session.deviceId,
+      userId: session.userId,
+      isAdmin: session.isAdmin,
+      sessionId: session.sessionId
+    });
+    try {
+      await updateLastSeen(session.deviceId, nowMs());
+      const lastMessageId =
+        typeof payload.lastMessageId === "string" ? payload.lastMessageId : null;
+      if (typeof payload.lastMessageId === "string" && !SERVER_EVENT_ID_REGEX.test(payload.lastMessageId)) {
+        await sendJson(ws, { type: "error", code: "invalid_message", message: "Invalid lastMessageId" });
+        ws.close();
+        return;
+      }
+      await sendReplay(session, lastMessageId);
+      if (session.isAdmin) {
+        await notifyAdminsOfPending();
+      }
+    } catch {
+      removeSession(session);
+      connectionState.delete(ws);
+      await sendJson(ws, { type: "error", code: "server_error", message: "Replay failed" }).catch(() => {});
+      ws.close(1011);
+      return;
+    }
+  }
+
+  async function handleAuthedMessage(ws: WebSocket, payload: any) {
+    const state = connectionState.get(ws);
+    if (!state || !state.authenticated || !state.deviceId || !state.userId) {
+      await sendJson(ws, { type: "error", code: "auth_failed", message: "Not authenticated" });
+      ws.close();
+      return;
+    }
+    const session = sessionsByDevice.get(state.deviceId);
+    if (!session) {
+      await sendJson(ws, { type: "error", code: "auth_failed", message: "Session missing" });
+      return;
+    }
+    await processClientMessage(session, payload);
+  }
+
+  let started = false;
+
+  const readBoundPort = () => {
+    const addr = httpServer.address();
+    if (!addr || typeof addr === "string") {
+      return config.port;
+    }
+    return addr.port;
+  };
+
+  return {
+    async start() {
+      if (started) return;
+      await new Promise<void>((resolve) => {
+        httpServer.listen(config.port, config.network.bindAddress, () => resolve());
+      });
+      started = true;
+      const port = readBoundPort();
+      logger.info(`Provider listening on ${config.network.bindAddress}:${port}`);
+    },
+    async stop() {
+      if (!started) return;
+      unwatchFile(denylistPath, denylistWatcher);
+      clearInterval(pendingCleanupInterval);
+      if (assetCleanupInterval) {
+        clearInterval(assetCleanupInterval);
+      }
+      // Force-close any active clients so shutdown doesn't hang.
+      for (const client of wss.clients) {
+        try {
+          client.terminate();
+        } catch {
+          // ignore
+        }
+      }
+      for (const socket of sockets) {
+        try {
+          socket.destroy();
+        } catch {
+          // ignore
+        }
+      }
+      httpServer.closeIdleConnections?.();
+      httpServer.closeAllConnections?.();
+      const closeWithTimeout = (fn: (cb: () => void) => void, label: string) =>
+        new Promise<void>((resolve, reject) => {
+          const timer = setTimeout(() => reject(new Error(`${label} close timeout`)), 5000);
+          fn(() => {
+            clearTimeout(timer);
+            resolve();
+          });
+        });
+      await closeWithTimeout((cb) => wss.close(cb), "wss");
+      await closeWithTimeout((cb) => httpServer.close(cb), "httpServer");
+      db.close();
+      started = false;
+    },
+    getPort() {
+      return readBoundPort();
+    }
+  };
+}
diff --git a/src/clawline/service.ts b/src/clawline/service.ts
new file mode 100644
index 000000000..ed874dda3
--- /dev/null
+++ b/src/clawline/service.ts
@@ -0,0 +1,47 @@
+import type { ClawdbotConfig } from "../config/config.js";
+import { resolveStorePath } from "../config/sessions.js";
+import { createClawlineAdapter } from "./adapter.js";
+import { resolveClawlineConfig } from "./config.js";
+import {
+  createProviderServer,
+  type Logger,
+  type ProviderServer,
+} from "./server.js";
+
+export type ClawlineServiceHandle = {
+  stop: () => Promise<void>;
+};
+
+export async function startClawlineService(params: {
+  config: ClawdbotConfig;
+  logger?: Logger;
+}): Promise<ClawlineServiceHandle | null> {
+  const logger = params.logger ?? console;
+  const resolved = resolveClawlineConfig(params.config);
+  if (!resolved.enabled) {
+    logger.info?.("[clawline] service disabled in config");
+    return null;
+  }
+  const adapter = await createClawlineAdapter({
+    config: params.config,
+    statePath: resolved.statePath,
+    logger,
+    clawlineConfig: resolved,
+  });
+  const sessionStorePath = resolveStorePath(params.config.session?.store);
+  const server: ProviderServer = await createProviderServer({
+    config: resolved,
+    adapter,
+    logger,
+    sessionStorePath,
+  });
+  await server.start();
+  logger.info?.(
+    `[clawline] listening on ${resolved.network.bindAddress}:${server.getPort()}`,
+  );
+  return {
+    stop: async () => {
+      await server.stop();
+    },
+  };
+}
diff --git a/src/clawline/session-key.ts b/src/clawline/session-key.ts
new file mode 100644
index 000000000..e01703572
--- /dev/null
+++ b/src/clawline/session-key.ts
@@ -0,0 +1,15 @@
+const KEY_PART_REGEX = /[^a-z0-9_-]+/g;
+
+function normalizeKeyPart(value: string): string {
+  const trimmed = (value ?? "").trim().toLowerCase();
+  const slug = trimmed.replace(KEY_PART_REGEX, "-").replace(/^-+/, "").replace(/-+$/, "");
+  return slug || "unknown";
+}
+
+export function buildClawlineSessionKey(userId: string, deviceId: string): string {
+  return `clawline:${normalizeKeyPart(userId)}:${normalizeKeyPart(deviceId)}`;
+}
+
+export function clawlineSessionFileName(sessionKey: string): string {
+  return sessionKey.replace(/[^a-z0-9_-]/gi, "-");
+}
diff --git a/src/clawline/session-store.test.ts b/src/clawline/session-store.test.ts
new file mode 100644
index 000000000..f1633ec48
--- /dev/null
+++ b/src/clawline/session-store.test.ts
@@ -0,0 +1,49 @@
+import fs from "node:fs/promises";
+import os from "node:os";
+import path from "node:path";
+
+import { describe, expect, it } from "vitest";
+
+import { loadSessionStore } from "../config/sessions.js";
+import { recordClawlineSessionActivity } from "./session-store.js";
+
+describe("recordClawlineSessionActivity", () => {
+  it("creates and updates session entries with clawline metadata", async () => {
+    const dir = await fs.mkdtemp(path.join(os.tmpdir(), "clawline-session-store-"));
+    const storePath = path.join(dir, "sessions.json");
+    const sessionKey = "clawline:user:device";
+
+    await recordClawlineSessionActivity({
+      storePath,
+      sessionKey,
+      sessionId: "session_1",
+      sessionFile: "/tmp/clawline-session.jsonl",
+      displayName: "Alice",
+    });
+
+    const initialStore = loadSessionStore(storePath);
+    const entry = initialStore[sessionKey];
+    expect(entry).toBeDefined();
+    expect(entry.channel).toBe("clawline");
+    expect(entry.chatType).toBe("direct");
+    expect(entry.displayName).toBe("Alice");
+    expect(entry.label).toBe("Alice");
+    expect(entry.sessionFile).toBe("/tmp/clawline-session.jsonl");
+    expect(entry.sessionId).toBe("session_1");
+    expect(entry.lastChannel).toBe("clawline");
+    const firstUpdatedAt = entry.updatedAt;
+
+    await recordClawlineSessionActivity({
+      storePath,
+      sessionKey,
+      sessionId: "session_1",
+      displayName: "Alice Cooper",
+    });
+
+    const updatedStore = loadSessionStore(storePath);
+    const updatedEntry = updatedStore[sessionKey];
+    expect(updatedEntry.displayName).toBe("Alice Cooper");
+    expect(updatedEntry.label).toBe("Alice Cooper");
+    expect(updatedEntry.updatedAt).toBeGreaterThanOrEqual(firstUpdatedAt);
+  });
+});
diff --git a/src/clawline/session-store.ts b/src/clawline/session-store.ts
new file mode 100644
index 000000000..ffe10c007
--- /dev/null
+++ b/src/clawline/session-store.ts
@@ -0,0 +1,39 @@
+import type { SessionChannelId, SessionEntry } from "../config/sessions.js";
+import {
+  loadSessionStore,
+  mergeSessionEntry,
+  saveSessionStore,
+} from "../config/sessions.js";
+
+export const CLAWLINE_SESSION_CHANNEL = "clawline" as SessionChannelId;
+
+type LoggerLike = { warn?: (...args: unknown[]) => void };
+
+export async function recordClawlineSessionActivity(params: {
+  storePath: string;
+  sessionKey: string;
+  sessionId: string;
+  sessionFile?: string;
+  displayName?: string | null;
+  logger?: LoggerLike;
+}): Promise<void> {
+  const { storePath, sessionKey, sessionId, sessionFile, displayName } = params;
+  const label = displayName?.trim() ? displayName.trim() : undefined;
+  try {
+    const store = loadSessionStore(storePath);
+    const existing = store[sessionKey];
+    const patch: Partial<SessionEntry> = {
+      sessionId,
+      channel: CLAWLINE_SESSION_CHANNEL,
+      chatType: "direct",
+      displayName: label,
+      label,
+      sessionFile,
+      lastChannel: CLAWLINE_SESSION_CHANNEL,
+    };
+    store[sessionKey] = mergeSessionEntry(existing, patch);
+    await saveSessionStore(storePath, store);
+  } catch (err) {
+    params.logger?.warn?.("[clawline] failed to update session store", err);
+  }
+}
diff --git a/src/cli/browser-cli-extension.test.ts b/src/cli/browser-cli-extension.test.ts
new file mode 100644
index 000000000..a844aae7b
--- /dev/null
+++ b/src/cli/browser-cli-extension.test.ts
@@ -0,0 +1,19 @@
+import fs from "node:fs";
+import os from "node:os";
+import path from "node:path";
+
+import { describe, expect, it } from "vitest";
+
+describe("browser extension install", () => {
+  it("installs into the state dir (never node_modules)", async () => {
+    const tmp = fs.mkdtempSync(path.join(os.tmpdir(), "clawdbot-ext-"));
+    const { installChromeExtension } = await import("./browser-cli-extension.js");
+
+    const sourceDir = path.resolve(process.cwd(), "assets/chrome-extension");
+    const result = await installChromeExtension({ stateDir: tmp, sourceDir });
+
+    expect(result.path).toBe(path.join(tmp, "browser", "chrome-extension"));
+    expect(fs.existsSync(path.join(result.path, "manifest.json"))).toBe(true);
+    expect(result.path.includes("node_modules")).toBe(false);
+  });
+});
diff --git a/src/cli/browser-cli-extension.ts b/src/cli/browser-cli-extension.ts
new file mode 100644
index 000000000..bb89e46eb
--- /dev/null
+++ b/src/cli/browser-cli-extension.ts
@@ -0,0 +1,116 @@
+import fs from "node:fs";
+import path from "node:path";
+import { fileURLToPath } from "node:url";
+
+import type { Command } from "commander";
+
+import { STATE_DIR_CLAWDBOT } from "../config/paths.js";
+import { danger, info } from "../globals.js";
+import { defaultRuntime } from "../runtime.js";
+import { movePathToTrash } from "../browser/trash.js";
+import { formatDocsLink } from "../terminal/links.js";
+import { theme } from "../terminal/theme.js";
+
+function bundledExtensionRootDir() {
+  const here = path.dirname(fileURLToPath(import.meta.url));
+  return path.resolve(here, "../../assets/chrome-extension");
+}
+
+function installedExtensionRootDir() {
+  return path.join(STATE_DIR_CLAWDBOT, "browser", "chrome-extension");
+}
+
+function hasManifest(dir: string) {
+  return fs.existsSync(path.join(dir, "manifest.json"));
+}
+
+export async function installChromeExtension(opts?: {
+  stateDir?: string;
+  sourceDir?: string;
+}): Promise<{ path: string }> {
+  const src = opts?.sourceDir ?? bundledExtensionRootDir();
+  if (!hasManifest(src)) {
+    throw new Error("Bundled Chrome extension is missing. Reinstall Clawdbot and try again.");
+  }
+
+  const stateDir = opts?.stateDir ?? STATE_DIR_CLAWDBOT;
+  const dest = path.join(stateDir, "browser", "chrome-extension");
+  fs.mkdirSync(path.dirname(dest), { recursive: true });
+
+  if (fs.existsSync(dest)) {
+    await movePathToTrash(dest).catch(() => {
+      const backup = `${dest}.old-${Date.now()}`;
+      fs.renameSync(dest, backup);
+    });
+  }
+
+  await fs.promises.cp(src, dest, { recursive: true });
+  if (!hasManifest(dest)) {
+    throw new Error("Chrome extension install failed (manifest.json missing). Try again.");
+  }
+
+  return { path: dest };
+}
+
+export function registerBrowserExtensionCommands(
+  browser: Command,
+  parentOpts: (cmd: Command) => { json?: boolean },
+) {
+  const ext = browser.command("extension").description("Chrome extension helpers");
+
+  ext
+    .command("install")
+    .description("Install the Chrome extension to a stable local path")
+    .action(async (_opts, cmd) => {
+      const parent = parentOpts(cmd);
+      let installed: { path: string };
+      try {
+        installed = await installChromeExtension();
+      } catch (err) {
+        defaultRuntime.error(danger(String(err)));
+        defaultRuntime.exit(1);
+      }
+
+      if (parent?.json) {
+        defaultRuntime.log(JSON.stringify({ ok: true, path: installed.path }, null, 2));
+        return;
+      }
+      defaultRuntime.log(installed.path);
+      defaultRuntime.error(
+        info(
+          [
+            "Next:",
+            `- Chrome → chrome://extensions → enable “Developer mode”`,
+            `- “Load unpacked” → select: ${installed.path}`,
+            `- Pin “Clawdbot Browser Relay”, then click it on the tab (badge shows ON)`,
+            "",
+            `${theme.muted("Docs:")} ${formatDocsLink("/tools/chrome-extension", "docs.clawd.bot/tools/chrome-extension")}`,
+          ].join("\n"),
+        ),
+      );
+    });
+
+  ext
+    .command("path")
+    .description("Print the path to the installed Chrome extension (load unpacked)")
+    .action((_opts, cmd) => {
+      const parent = parentOpts(cmd);
+      const dir = installedExtensionRootDir();
+      if (!hasManifest(dir)) {
+        defaultRuntime.error(
+          danger(
+            [
+              'Chrome extension is not installed. Run: "clawdbot browser extension install"',
+              `Docs: ${formatDocsLink("/tools/chrome-extension", "docs.clawd.bot/tools/chrome-extension")}`,
+            ].join("\n"),
+          ),
+        );
+        defaultRuntime.exit(1);
+      }
+      if (parent?.json) {
+        defaultRuntime.log(JSON.stringify({ path: dir }, null, 2));
+        return;
+      }
+      defaultRuntime.log(dir);
+    });
+}
diff --git a/src/cli/browser-cli-serve.ts b/src/cli/browser-cli-serve.ts
new file mode 100644
index 000000000..179424ed1
--- /dev/null
+++ b/src/cli/browser-cli-serve.ts
@@ -0,0 +1,121 @@
+import type { Command } from "commander";
+
+import { loadConfig } from "../config/config.js";
+import { danger, info } from "../globals.js";
+import { defaultRuntime } from "../runtime.js";
+import { resolveBrowserConfig, resolveProfile } from "../browser/config.js";
+import { startBrowserBridgeServer, stopBrowserBridgeServer } from "../browser/bridge-server.js";
+import { ensureChromeExtensionRelayServer } from "../browser/extension-relay.js";
+
+function isLoopbackBindHost(host: string) {
+  const h = host.trim().toLowerCase();
+  return h === "localhost" || h === "127.0.0.1" || h === "::1" || h === "[::1]";
+}
+
+function parsePort(raw: unknown): number | null {
+  const v = typeof raw === "string" ? raw.trim() : "";
+  if (!v) return null;
+  const n = Number.parseInt(v, 10);
+  if (!Number.isFinite(n) || n < 0 || n > 65535) return null;
+  return n;
+}
+
+export function registerBrowserServeCommands(
+  browser: Command,
+  _parentOpts: (cmd: Command) => unknown,
+) {
+  browser
+    .command("serve")
+    .description("Run a standalone browser control server (for remote gateways)")
+    .option("--bind <host>", "Bind host (default: 127.0.0.1)")
+    .option("--port <port>", "Bind port (default: from browser.controlUrl)")
+    .option(
+      "--token <token>",
+      "Require Authorization: Bearer <token> (required when binding non-loopback)",
+    )
+    .action(async (opts: { bind?: string; port?: string; token?: string }) => {
+      const cfg = loadConfig();
+      const resolved = resolveBrowserConfig(cfg.browser);
+      if (!resolved.enabled) {
+        defaultRuntime.error(
+          danger("Browser control is disabled. Set browser.enabled=true and try again."),
+        );
+        defaultRuntime.exit(1);
+      }
+
+      const host = (opts.bind ?? "127.0.0.1").trim();
+      const port = parsePort(opts.port) ?? resolved.controlPort;
+
+      const envToken = process.env.CLAWDBOT_BROWSER_CONTROL_TOKEN?.trim();
+      const authToken = (opts.token ?? envToken ?? resolved.controlToken)?.trim();
+      if (!isLoopbackBindHost(host) && !authToken) {
+        defaultRuntime.error(
+          danger(
+            `Refusing to bind browser control on ${host} without --token (or CLAWDBOT_BROWSER_CONTROL_TOKEN, or browser.controlToken).`,
+          ),
+        );
+        defaultRuntime.exit(1);
+      }
+
+      const bridge = await startBrowserBridgeServer({
+        resolved,
+        host,
+        port,
+        ...(authToken ? { authToken } : {}),
+      });
+
+      // If any profile uses the Chrome extension relay, start the local relay server eagerly
+      // so the extension can connect before the first browser action.
+      for (const name of Object.keys(resolved.profiles)) {
+        const profile = resolveProfile(resolved, name);
+        if (!profile || profile.driver !== "extension") continue;
+        await ensureChromeExtensionRelayServer({ cdpUrl: profile.cdpUrl }).catch((err) => {
+          defaultRuntime.error(
+            danger(`Chrome extension relay init failed for profile "${name}": ${String(err)}`),
+          );
+        });
+      }
+
+      defaultRuntime.log(
+        info(
+          [
+            `🦞 Browser control listening on ${bridge.baseUrl}/`,
+            authToken ? "Auth: Bearer token required." : "Auth: off (loopback only).",
+            "",
+            "Paste on the Gateway (clawdbot.json):",
+            JSON.stringify(
+              {
+                browser: {
+                  enabled: true,
+                  controlUrl: bridge.baseUrl,
+                  ...(authToken ? { controlToken: authToken } : {}),
+                },
+              },
+              null,
+              2,
+            ),
+            ...(authToken
+              ? [
+                  "",
+                  "Or use env on the Gateway (instead of controlToken in config):",
+                  `export CLAWDBOT_BROWSER_CONTROL_TOKEN=${JSON.stringify(authToken)}`,
+                ]
+              : []),
+          ].join("\n"),
+        ),
+      );
+
+      let shuttingDown = false;
+      const shutdown = async (signal: string) => {
+        if (shuttingDown) return;
+        shuttingDown = true;
+        defaultRuntime.log(info(`Shutting down (${signal})...`));
+        await stopBrowserBridgeServer(bridge.server).catch(() => {});
+        process.exit(0);
+      };
+      process.once("SIGINT", () => void shutdown("SIGINT"));
+      process.once("SIGTERM", () => void shutdown("SIGTERM"));
+
+      await new Promise(() => {});
+    });
+}
diff --git a/src/cli/security-cli.ts b/src/cli/security-cli.ts
new file mode 100644
index 000000000..8c5596e10
--- /dev/null
+++ b/src/cli/security-cli.ts
@@ -0,0 +1,127 @@
+import chalk from "chalk";
+import type { Command } from "commander";
+
+import { loadConfig } from "../config/config.js";
+import { defaultRuntime } from "../runtime.js";
+import { runSecurityAudit } from "../security/audit.js";
+import { fixSecurityFootguns } from "../security/fix.js";
+import { isRich, theme } from "../terminal/theme.js";
+
+type SecurityAuditOptions = {
+  json?: boolean;
+  deep?: boolean;
+  fix?: boolean;
+};
+
+function formatSummary(summary: { critical: number; warn: number; info: number }): string {
+  const rich = isRich();
+  const c = summary.critical;
+  const w = summary.warn;
+  const i = summary.info;
+  const parts: string[] = [];
+  parts.push(rich ? theme.error(`${c} critical`) : `${c} critical`);
+  parts.push(rich ? theme.warn(`${w} warn`) : `${w} warn`);
+  parts.push(rich ? theme.muted(`${i} info`) : `${i} info`);
+  return parts.join(" · ");
+}
+
+export function registerSecurityCli(program: Command) {
+  const security = program.command("security").description("Security tools (audit)");
+
+  security
+    .command("audit")
+    .description("Audit config + local state for common security foot-guns")
+    .option("--deep", "Attempt live Gateway probe (best-effort)", false)
+    .option("--fix", "Apply safe fixes (tighten defaults + chmod state/config)", false)
+    .option("--json", "Print JSON", false)
+    .action(async (opts: SecurityAuditOptions) => {
+      const fixResult = opts.fix ? await fixSecurityFootguns().catch((_err) => null) : null;
+
+      const cfg = loadConfig();
+      const report = await runSecurityAudit({
+        config: cfg,
+        deep: Boolean(opts.deep),
+        includeFilesystem: true,
+        includeChannelSecurity: true,
+      });
+
+      if (opts.json) {
+        defaultRuntime.log(
+          JSON.stringify(fixResult ? { fix: fixResult, report } : report, null, 2),
+        );
+        return;
+      }
+
+      const rich = isRich();
+      const heading = (text: string) => (rich ? theme.heading(text) : text);
+      const muted = (text: string) => (rich ? theme.muted(text) : text);
+
+      const lines: string[] = [];
+      lines.push(heading("Clawdbot security audit"));
+      lines.push(muted(`Summary: ${formatSummary(report.summary)}`));
+      lines.push(muted(`Run deeper: clawdbot security audit --deep`));
+
+      if (opts.fix) {
+        lines.push(muted(`Fix: clawdbot security audit --fix`));
+        if (!fixResult) {
+          lines.push(muted("Fixes: failed to apply (unexpected error)"));
+        } else if (
+          fixResult.errors.length === 0 &&
+          fixResult.changes.length === 0 &&
+          fixResult.actions.every((a) => a.ok === false)
+        ) {
+          lines.push(muted("Fixes: no changes applied"));
+        } else {
+          lines.push("");
+          lines.push(heading("FIX"));
+          for (const change of fixResult.changes) {
+            lines.push(muted(`  ${change}`));
+          }
+          for (const action of fixResult.actions) {
+            const mode = action.mode.toString(8).padStart(3, "0");
+            if (action.ok) lines.push(muted(`  chmod ${mode} ${action.path}`));
+            else if (action.skipped)
+              lines.push(muted(`  skip chmod ${mode} ${action.path} (${action.skipped})`));
+            else if (action.error)
+              lines.push(muted(`  chmod ${mode} ${action.path} failed: ${action.error}`));
+          }
+          if (fixResult.errors.length > 0) {
+            for (const err of fixResult.errors) lines.push(muted(`  error: ${err}`));
+          }
+        }
+      }
+
+      const bySeverity = (sev: "critical" | "warn" | "info") =>
+        report.findings.filter((f) => f.severity === sev);
+
+      const render = (sev: "critical" | "warn" | "info") => {
+        const list = bySeverity(sev);
+        if (list.length === 0) return;
+        const label =
+          sev === "critical"
+            ? rich
+              ? theme.error("CRITICAL")
+              : "CRITICAL"
+            : sev === "warn"
+              ? rich
+                ? theme.warn("WARN")
+                : "WARN"
+              : rich
+                ? theme.muted("INFO")
+                : "INFO";
+        lines.push("");
+        lines.push(heading(label));
+        for (const f of list) {
+          lines.push(`${chalk.gray(f.checkId)} ${f.title}`);
+          lines.push(`  ${f.detail}`);
+          if (f.remediation?.trim()) lines.push(`  ${muted(`Fix: ${f.remediation.trim()}`)}`);
+        }
+      };
+
+      render("critical");
+      render("warn");
+      render("info");
+
+      defaultRuntime.log(lines.join("\n"));
+    });
+}
diff --git a/src/commands/doctor-legacy-config.test.ts b/src/commands/doctor-legacy-config.test.ts
new file mode 100644
index 000000000..8cb19b5d5
--- /dev/null
+++ b/src/commands/doctor-legacy-config.test.ts
@@ -0,0 +1,124 @@
+import fs from "node:fs";
+import os from "node:os";
+import path from "node:path";
+import { afterEach, beforeEach, describe, expect, it } from "vitest";
+
+import { normalizeLegacyConfigValues } from "./doctor-legacy-config.js";
+
+describe("normalizeLegacyConfigValues", () => {
+  let previousOauthDir: string | undefined;
+  let tempOauthDir: string | undefined;
+
+  const writeCreds = (dir: string) => {
+    fs.mkdirSync(dir, { recursive: true });
+    fs.writeFileSync(path.join(dir, "creds.json"), JSON.stringify({ me: {} }));
+  };
+
+  beforeEach(() => {
+    previousOauthDir = process.env.CLAWDBOT_OAUTH_DIR;
+    tempOauthDir = fs.mkdtempSync(path.join(os.tmpdir(), "clawdbot-oauth-"));
+    process.env.CLAWDBOT_OAUTH_DIR = tempOauthDir;
+  });
+
+  afterEach(() => {
+    if (previousOauthDir === undefined) {
+      delete process.env.CLAWDBOT_OAUTH_DIR;
+    } else {
+      process.env.CLAWDBOT_OAUTH_DIR = previousOauthDir;
+    }
+    if (tempOauthDir) {
+      fs.rmSync(tempOauthDir, { recursive: true, force: true });
+      tempOauthDir = undefined;
+    }
+  });
+
+  it("does not add whatsapp config when missing and no auth exists", () => {
+    const res = normalizeLegacyConfigValues({
+      messages: { ackReaction: "👀" },
+    });
+
+    expect(res.config.channels?.whatsapp).toBeUndefined();
+    expect(res.changes).toEqual([]);
+  });
+
+  it("copies legacy ack reaction when whatsapp config exists", () => {
+    const res = normalizeLegacyConfigValues({
+      messages: { ackReaction: "👀", ackReactionScope: "group-mentions" },
+      channels: { whatsapp: {} },
+    });
+
+    expect(res.config.channels?.whatsapp?.ackReaction).toEqual({
+      emoji: "👀",
+      direct: false,
+      group: "mentions",
+    });
+    expect(res.changes).toEqual([
+      "Copied messages.ackReaction → channels.whatsapp.ackReaction (scope: group-mentions).",
+    ]);
+  });
+
+  it("copies legacy ack reaction when whatsapp auth exists", () => {
+    const credsDir = path.join(tempOauthDir ?? "", "whatsapp", "default");
+    writeCreds(credsDir);
+
+    const res = normalizeLegacyConfigValues({
+      messages: { ackReaction: "👀", ackReactionScope: "group-mentions" },
+    });
+
+    expect(res.config.channels?.whatsapp?.ackReaction).toEqual({
+      emoji: "👀",
+      direct: false,
+      group: "mentions",
+    });
+  });
+
+  it("copies legacy ack reaction when legacy auth exists", () => {
+    const credsPath = path.join(tempOauthDir ?? "", "creds.json");
+    fs.writeFileSync(credsPath, JSON.stringify({ me: {} }));
+
+    const res = normalizeLegacyConfigValues({
+      messages: { ackReaction: "👀", ackReactionScope: "group-mentions" },
+    });
+
+    expect(res.config.channels?.whatsapp?.ackReaction).toEqual({
+      emoji: "👀",
+      direct: false,
+      group: "mentions",
+    });
+  });
+
+  it("copies legacy ack reaction when non-default auth exists", () => {
+    const credsDir = path.join(tempOauthDir ?? "", "whatsapp", "work");
+    writeCreds(credsDir);
+
+    const res = normalizeLegacyConfigValues({
+      messages: { ackReaction: "👀", ackReactionScope: "group-mentions" },
+    });
+
+    expect(res.config.channels?.whatsapp?.ackReaction).toEqual({
+      emoji: "👀",
+      direct: false,
+      group: "mentions",
+    });
+  });
+
+  it("copies legacy ack reaction when authDir override exists", () => {
+    const customDir = fs.mkdtempSync(path.join(os.tmpdir(), "clawdbot-wa-auth-"));
+    try {
+      writeCreds(customDir);
+
+      const res = normalizeLegacyConfigValues({
+        messages: { ackReaction: "👀", ackReactionScope: "group-mentions" },
+        channels: { whatsapp: { accounts: { work: { authDir: customDir } } } },
+      });
+
+      expect(res.config.channels?.whatsapp?.ackReaction).toEqual({
+        emoji: "👀",
+        direct: false,
+        group: "mentions",
+      });
+    } finally {
+      fs.rmSync(customDir, { recursive: true, force: true });
+    }
+  });
+});
diff --git a/src/commands/onboarding/__tests__/test-utils.ts b/src/commands/onboarding/__tests__/test-utils.ts
new file mode 100644
index 000000000..aea7f9cda
--- /dev/null
+++ b/src/commands/onboarding/__tests__/test-utils.ts
@@ -0,0 +1,25 @@
+import { vi } from "vitest";
+
+import type { RuntimeEnv } from "../../../runtime.js";
+import type { WizardPrompter } from "../../../wizard/prompts.js";
+
+export const makeRuntime = (overrides: Partial<RuntimeEnv> = {}): RuntimeEnv => ({
+  log: vi.fn(),
+  error: vi.fn(),
+  exit: vi.fn((code: number) => {
+    throw new Error(`exit:${code}`);
+  }) as RuntimeEnv["exit"],
+  ...overrides,
+});
+
+export const makePrompter = (overrides: Partial<WizardPrompter> = {}): WizardPrompter => ({
+  intro: vi.fn(async () => {}),
+  outro: vi.fn(async () => {}),
+  note: vi.fn(async () => {}),
+  select: vi.fn(async () => "npm") as WizardPrompter["select"],
+  multiselect: vi.fn(async () => []) as WizardPrompter["multiselect"],
+  text: vi.fn(async () => "") as WizardPrompter["text"],
+  confirm: vi.fn(async () => false),
+  progress: vi.fn(() => ({ update: vi.fn(), stop: vi.fn() })),
+  ...overrides,
+});
diff --git a/src/commands/onboarding/plugin-install.test.ts b/src/commands/onboarding/plugin-install.test.ts
new file mode 100644
index 000000000..f31012f42
--- /dev/null
+++ b/src/commands/onboarding/plugin-install.test.ts
@@ -0,0 +1,126 @@
+import path from "node:path";
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+vi.mock("node:fs", () => ({
+  default: {
+    existsSync: vi.fn(),
+  },
+}));
+
+const installPluginFromNpmSpec = vi.fn();
+vi.mock("../../plugins/install.js", () => ({
+  installPluginFromNpmSpec: (...args: unknown[]) => installPluginFromNpmSpec(...args),
+}));
+
+vi.mock("../../plugins/loader.js", () => ({
+  loadClawdbotPlugins: vi.fn(),
+}));
+
+import fs from "node:fs";
+import type { ChannelPluginCatalogEntry } from "../../channels/plugins/catalog.js";
+import type { ClawdbotConfig } from "../../config/config.js";
+import type { WizardPrompter } from "../../wizard/prompts.js";
+import { makePrompter, makeRuntime } from "./__tests__/test-utils.js";
+import { ensureOnboardingPluginInstalled } from "./plugin-install.js";
+
+const baseEntry: ChannelPluginCatalogEntry = {
+  id: "zalo",
+  meta: {
+    id: "zalo",
+    label: "Zalo",
+    selectionLabel: "Zalo (Bot API)",
+    docsPath: "/channels/zalo",
+    docsLabel: "zalo",
+    blurb: "Test",
+  },
+  install: {
+    npmSpec: "@clawdbot/zalo",
+    localPath: "extensions/zalo",
+  },
+};
+
+beforeEach(() => {
+  vi.clearAllMocks();
+});
+
+describe("ensureOnboardingPluginInstalled", () => {
+  it("installs from npm and enables the plugin", async () => {
+    const runtime = makeRuntime();
+    const prompter = makePrompter({
+      select: vi.fn(async () => "npm") as WizardPrompter["select"],
+    });
+    const cfg: ClawdbotConfig = { plugins: { allow: ["other"] } };
+    vi.mocked(fs.existsSync).mockReturnValue(false);
+    installPluginFromNpmSpec.mockResolvedValue({
+      ok: true,
+      pluginId: "zalo",
+      targetDir: "/tmp/zalo",
+      extensions: [],
+    });
+
+    const result = await ensureOnboardingPluginInstalled({
+      cfg,
+      entry: baseEntry,
+      prompter,
+      runtime,
+    });
+
+    expect(result.installed).toBe(true);
+    expect(result.cfg.plugins?.entries?.zalo?.enabled).toBe(true);
+    expect(result.cfg.plugins?.allow).toContain("zalo");
+    expect(installPluginFromNpmSpec).toHaveBeenCalledWith(
+      expect.objectContaining({ spec: "@clawdbot/zalo" }),
+    );
+  });
+
+  it("uses local path when selected", async () => {
+    const runtime = makeRuntime();
+    const prompter = makePrompter({
+      select: vi.fn(async () => "local") as WizardPrompter["select"],
+    });
+    const cfg: ClawdbotConfig = {};
+    vi.mocked(fs.existsSync).mockReturnValue(true);
+
+    const result = await ensureOnboardingPluginInstalled({
+      cfg,
+      entry: baseEntry,
+      prompter,
+      runtime,
+    });
+
+    const expectedPath = path.resolve(process.cwd(), "extensions/zalo");
+    expect(result.installed).toBe(true);
+    expect(result.cfg.plugins?.load?.paths).toContain(expectedPath);
+    expect(result.cfg.plugins?.entries?.zalo?.enabled).toBe(true);
+  });
+
+  it("falls back to local path after npm install failure", async () => {
+    const runtime = makeRuntime();
+    const note = vi.fn(async () => {});
+    const confirm = vi.fn(async () => true);
+    const prompter = makePrompter({
+      select: vi.fn(async () => "npm") as WizardPrompter["select"],
+      note,
+      confirm,
+    });
+    const cfg: ClawdbotConfig = {};
+    vi.mocked(fs.existsSync).mockReturnValue(true);
+    installPluginFromNpmSpec.mockResolvedValue({
+      ok: false,
+      error: "nope",
+    });
+
+    const result = await ensureOnboardingPluginInstalled({
+      cfg,
+      entry: baseEntry,
+      prompter,
+      runtime,
+    });
+
+    const expectedPath = path.resolve(process.cwd(), "extensions/zalo");
+    expect(result.installed).toBe(true);
+    expect(result.cfg.plugins?.load?.paths).toContain(expectedPath);
+    expect(note).toHaveBeenCalled();
+    expect(runtime.error).not.toHaveBeenCalled();
+  });
+});
diff --git a/src/commands/onboarding/plugin-install.ts b/src/commands/onboarding/plugin-install.ts
new file mode 100644
index 000000000..041f0b10e
--- /dev/null
+++ b/src/commands/onboarding/plugin-install.ts
@@ -0,0 +1,186 @@
+import fs from "node:fs";
+import path from "node:path";
+import { resolveAgentWorkspaceDir, resolveDefaultAgentId } from "../../agents/agent-scope.js";
+import type { ChannelPluginCatalogEntry } from "../../channels/plugins/catalog.js";
+import type { ClawdbotConfig } from "../../config/config.js";
+import { createSubsystemLogger } from "../../logging.js";
+import { loadClawdbotPlugins } from "../../plugins/loader.js";
+import { installPluginFromNpmSpec } from "../../plugins/install.js";
+import type { RuntimeEnv } from "../../runtime.js";
+import type { WizardPrompter } from "../../wizard/prompts.js";
+
+type InstallChoice = "npm" | "local" | "skip";
+
+type InstallResult = {
+  cfg: ClawdbotConfig;
+  installed: boolean;
+};
+
+function resolveLocalPath(entry: ChannelPluginCatalogEntry, workspaceDir?: string): string | null {
+  const raw = entry.install.localPath?.trim();
+  if (!raw) return null;
+  const candidates = new Set<string>();
+  candidates.add(path.resolve(process.cwd(), raw));
+  if (workspaceDir && workspaceDir !== process.cwd()) {
+    candidates.add(path.resolve(workspaceDir, raw));
+  }
+  for (const candidate of candidates) {
+    if (fs.existsSync(candidate)) return candidate;
+  }
+  return null;
+}
+
+function ensurePluginEnabled(cfg: ClawdbotConfig, pluginId: string): ClawdbotConfig {
+  const entries = {
+    ...cfg.plugins?.entries,
+    [pluginId]: {
+      ...(cfg.plugins?.entries?.[pluginId] as Record<string, unknown> | undefined),
+      enabled: true,
+    },
+  };
+  const next: ClawdbotConfig = {
+    ...cfg,
+    plugins: {
+      ...cfg.plugins,
+      ...(cfg.plugins?.enabled === false ? { enabled: true } : {}),
+      entries,
+    },
+  };
+  return ensurePluginAllowlist(next, pluginId);
+}
+
+function ensurePluginAllowlist(cfg: ClawdbotConfig, pluginId: string): ClawdbotConfig {
+  const allow = cfg.plugins?.allow;
+  if (!allow || allow.includes(pluginId)) return cfg;
+  return {
+    ...cfg,
+    plugins: {
+      ...cfg.plugins,
+      allow: [...allow, pluginId],
+    },
+  };
+}
+
+function addPluginLoadPath(cfg: ClawdbotConfig, pluginPath: string): ClawdbotConfig {
+  const existing = cfg.plugins?.load?.paths ?? [];
+  const merged = Array.from(new Set([...existing, pluginPath]));
+  return {
+    ...cfg,
+    plugins: {
+      ...cfg.plugins,
+      load: {
+        ...cfg.plugins?.load,
+        paths: merged,
+      },
+    },
+  };
+}
+
+async function promptInstallChoice(params: {
+  entry: ChannelPluginCatalogEntry;
+  localPath?: string | null;
+  prompter: WizardPrompter;
+}): Promise<InstallChoice> {
+  const { entry, localPath, prompter } = params;
+  const localOptions: Array<{ value: InstallChoice; label: string; hint?: string }> = localPath
+    ? [
+        {
+          value: "local",
+          label: "Use local plugin path",
+          hint: localPath,
+        },
+      ]
+    : [];
+  const options: Array<{ value: InstallChoice; label: string; hint?: string }> = [
+    { value: "npm", label: `Download from npm (${entry.install.npmSpec})` },
+    ...localOptions,
+    { value: "skip", label: "Skip for now" },
+  ];
+  const initialValue: InstallChoice = localPath ? "local" : "npm";
+  return await prompter.select<InstallChoice>({
+    message: `Install ${entry.meta.label} plugin?`,
+    options,
+    initialValue,
+  });
+}
+
+export async function ensureOnboardingPluginInstalled(params: {
+  cfg: ClawdbotConfig;
+  entry: ChannelPluginCatalogEntry;
+  prompter: WizardPrompter;
+  runtime: RuntimeEnv;
+  workspaceDir?: string;
+}): Promise<InstallResult> {
+  const { entry, prompter, runtime, workspaceDir } = params;
+  let next = params.cfg;
+  const localPath = resolveLocalPath(entry, workspaceDir);
+  const choice = await promptInstallChoice({
+    entry,
+    localPath,
+    prompter,
+  });
+
+  if (choice === "skip") {
+    return { cfg: next, installed: false };
+  }
+
+  if (choice === "local" && localPath) {
+    next = addPluginLoadPath(next, localPath);
+    next = ensurePluginEnabled(next, entry.id);
+    return { cfg: next, installed: true };
+  }
+
+  const result = await installPluginFromNpmSpec({
+    spec: entry.install.npmSpec,
+    logger: {
+      info: (msg) => runtime.log?.(msg),
+      warn: (msg) => runtime.log?.(msg),
+    },
+  });
+
+  if (result.ok) {
+    next = ensurePluginEnabled(next, result.pluginId);
+    return { cfg: next, installed: true };
+  }
+
+  await prompter.note(
+    `Failed to install ${entry.install.npmSpec}: ${result.error}`,
+    "Plugin install",
+  );
+
+  if (localPath) {
+    const fallback = await prompter.confirm({
+      message: `Use local plugin path instead? (${localPath})`,
+      initialValue: true,
+    });
+    if (fallback) {
+      next = addPluginLoadPath(next, localPath);
+      next = ensurePluginEnabled(next, entry.id);
+      return { cfg: next, installed: true };
+    }
+  }
+
+  runtime.error?.(`Plugin install failed: ${result.error}`);
+  return { cfg: next, installed: false };
+}
+
+export function reloadOnboardingPluginRegistry(params: {
+  cfg: ClawdbotConfig;
+  runtime: RuntimeEnv;
+  workspaceDir?: string;
+}): void {
+  const workspaceDir =
+    params.workspaceDir ?? resolveAgentWorkspaceDir(params.cfg, resolveDefaultAgentId(params.cfg));
+  const log = createSubsystemLogger("plugins");
+  loadClawdbotPlugins({
+    config: params.cfg,
+    workspaceDir,
+    cache: false,
+    logger: {
+      info: (msg) => log.info(msg),
+      warn: (msg) => log.warn(msg),
+      error: (msg) => log.error(msg),
+      debug: (msg) => log.debug(msg),
+    },
+  });
+}
diff --git a/src/config/config.sandbox-docker.test.ts b/src/config/config.sandbox-docker.test.ts
new file mode 100644
index 000000000..2bc0ff43e
--- /dev/null
+++ b/src/config/config.sandbox-docker.test.ts
@@ -0,0 +1,57 @@
+import { describe, expect, it, vi } from "vitest";
+
+describe("sandbox docker config", () => {
+  it("accepts binds array in sandbox.docker config", async () => {
+    vi.resetModules();
+    const { validateConfigObject } = await import("./config.js");
+    const res = validateConfigObject({
+      agents: {
+        defaults: {
+          sandbox: {
+            docker: {
+              binds: ["/var/run/docker.sock:/var/run/docker.sock", "/home/user/source:/source:rw"],
+            },
+          },
+        },
+        list: [
+          {
+            id: "main",
+            sandbox: {
+              docker: {
+                image: "custom-sandbox:latest",
+                binds: ["/home/user/projects:/projects:ro"],
+              },
+            },
+          },
+        ],
+      },
+    });
+    expect(res.ok).toBe(true);
+    if (res.ok) {
+      expect(res.config.agents?.defaults?.sandbox?.docker?.binds).toEqual([
+        "/var/run/docker.sock:/var/run/docker.sock",
+        "/home/user/source:/source:rw",
+      ]);
+      expect(res.config.agents?.list?.[0]?.sandbox?.docker?.binds).toEqual([
+        "/home/user/projects:/projects:ro",
+      ]);
+    }
+  });
+
+  it("rejects non-string values in binds array", async () => {
+    vi.resetModules();
+    const { validateConfigObject } = await import("./config.js");
+    const res = validateConfigObject({
+      agents: {
+        defaults: {
+          sandbox: {
+            docker: {
+              binds: [123, "/valid/path:/path"],
+            },
+          },
+        },
+      },
+    });
+    expect(res.ok).toBe(false);
+  });
+});
diff --git a/src/config/merge-patch.ts b/src/config/merge-patch.ts
new file mode 100644
index 000000000..6b66d15ed
--- /dev/null
+++ b/src/config/merge-patch.ts
@@ -0,0 +1,28 @@
+type PlainObject = Record<string, unknown>;
+
+function isPlainObject(value: unknown): value is PlainObject {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+
+export function applyMergePatch(base: unknown, patch: unknown): unknown {
+  if (!isPlainObject(patch)) {
+    return patch;
+  }
+
+  const result: PlainObject = isPlainObject(base) ? { ...base } : {};
+
+  for (const [key, value] of Object.entries(patch)) {
+    if (value === null) {
+      delete result[key];
+      continue;
+    }
+    if (isPlainObject(value)) {
+      const baseValue = result[key];
+      result[key] = applyMergePatch(isPlainObject(baseValue) ? baseValue : {}, value);
+      continue;
+    }
+    result[key] = value;
+  }
+
+  return result;
+}
diff --git a/src/config/types.clawdbot.ts b/src/config/types.clawdbot.ts
index 88b9e3984..7324d58db 100644
--- a/src/config/types.clawdbot.ts
+++ b/src/config/types.clawdbot.ts
@@ -11,6 +11,7 @@ import type {
   GatewayConfig,
   TalkConfig,
 } from "./types.gateway.js";
+import type { ClawlineConfig } from "./types.clawline.js";
 import type { HooksConfig } from "./types.hooks.js";
 import type {
   AudioConfig,
@@ -74,6 +75,7 @@ export type ClawdbotConfig = {
   canvasHost?: CanvasHostConfig;
   talk?: TalkConfig;
   gateway?: GatewayConfig;
+  clawline?: ClawlineConfig;
 };
 
 export type ConfigValidationIssue = {
diff --git a/src/config/types.clawline.ts b/src/config/types.clawline.ts
new file mode 100644
index 000000000..f7d840c84
--- /dev/null
+++ b/src/config/types.clawline.ts
@@ -0,0 +1,52 @@
+export type ClawlineAdapterConfig = {
+  provider?: string;
+  model?: string;
+  timeoutSeconds?: number;
+  responseFallback?: string;
+  systemPrompt?: string;
+};
+
+export type ClawlineConfig = {
+  enabled?: boolean;
+  port?: number;
+  statePath?: string;
+  network?: {
+    bindAddress?: string;
+    allowInsecurePublic?: boolean;
+    allowedOrigins?: string[];
+  };
+  adapter?: ClawlineAdapterConfig;
+  auth?: {
+    jwtSigningKey?: string | null;
+    tokenTtlSeconds?: number | null;
+    maxAttemptsPerMinute?: number;
+    reissueGraceSeconds?: number;
+  };
+  pairing?: {
+    maxPendingRequests?: number;
+    maxRequestsPerMinute?: number;
+    pendingTtlSeconds?: number;
+  };
+  media?: {
+    storagePath?: string;
+    maxInlineBytes?: number;
+    maxUploadBytes?: number;
+    unreferencedUploadTtlSeconds?: number;
+  };
+  sessions?: {
+    maxMessageBytes?: number;
+    maxReplayMessages?: number;
+    maxPromptMessages?: number;
+    maxMessagesPerSecond?: number;
+    maxTypingPerSecond?: number;
+    typingAutoExpireSeconds?: number;
+    maxQueuedMessages?: number;
+    maxWriteQueueDepth?: number;
+    adapterExecuteTimeoutSeconds?: number;
+    streamInactivitySeconds?: number;
+  };
+  streams?: {
+    chunkPersistIntervalMs?: number;
+    chunkBufferBytes?: number;
+  };
+};
diff --git a/src/config/types.ts b/src/config/types.ts
index 368618262..4937d3cfb 100644
--- a/src/config/types.ts
+++ b/src/config/types.ts
@@ -7,6 +7,7 @@ export * from "./types.base.js";
 export * from "./types.browser.js";
 export * from "./types.channels.js";
 export * from "./types.clawdbot.js";
+export * from "./types.clawline.js";
 export * from "./types.cron.js";
 export * from "./types.discord.js";
 export * from "./types.gateway.js";
diff --git a/src/config/zod-schema.ts b/src/config/zod-schema.ts
index 359ceae51..f5edfe7ff 100644
--- a/src/config/zod-schema.ts
+++ b/src/config/zod-schema.ts
@@ -6,6 +6,77 @@ import { HookMappingSchema, HooksGmailSchema } from "./zod-schema.hooks.js";
 import { ChannelsSchema } from "./zod-schema.providers.js";
 import { CommandsSchema, MessagesSchema, SessionSchema } from "./zod-schema.session.js";
 
+const ClawlineConfigSchema = z
+  .object({
+    enabled: z.boolean().optional(),
+    port: z.number().int().positive().optional(),
+    statePath: z.string().optional(),
+    network: z
+      .object({
+        bindAddress: z.string().optional(),
+        allowInsecurePublic: z.boolean().optional(),
+        allowedOrigins: z.array(z.string()).optional(),
+      })
+      .optional(),
+    adapter: z
+      .object({
+        provider: z.string().optional(),
+        model: z.string().optional(),
+        timeoutSeconds: z.number().int().positive().optional(),
+        responseFallback: z.string().optional(),
+        systemPrompt: z.string().optional(),
+      })
+      .optional(),
+    auth: z
+      .object({
+        jwtSigningKey: z.string().nullable().optional(),
+        tokenTtlSeconds: z.number().int().nullable().optional(),
+        maxAttemptsPerMinute: z.number().int().nonnegative().optional(),
+        reissueGraceSeconds: z.number().int().nonnegative().optional(),
+      })
+      .optional(),
+    pairing: z
+      .object({
+        maxPendingRequests: z.number().int().nonnegative().optional(),
+        maxRequestsPerMinute: z.number().int().nonnegative().optional(),
+        pendingTtlSeconds: z.number().int().nonnegative().optional(),
+      })
+      .optional(),
+    media: z
+      .object({
+        storagePath: z.string().optional(),
+        maxInlineBytes: z.number().int().nonnegative().optional(),
+        maxUploadBytes: z.number().int().nonnegative().optional(),
+        unreferencedUploadTtlSeconds: z
+          .number()
+          .int()
+          .nonnegative()
+          .optional(),
+      })
+      .optional(),
+    sessions: z
+      .object({
+        maxMessageBytes: z.number().int().positive().optional(),
+        maxReplayMessages: z.number().int().nonnegative().optional(),
+        maxPromptMessages: z.number().int().nonnegative().optional(),
+        maxMessagesPerSecond: z.number().int().nonnegative().optional(),
+        maxTypingPerSecond: z.number().int().nonnegative().optional(),
+        typingAutoExpireSeconds: z.number().int().nonnegative().optional(),
+        maxQueuedMessages: z.number().int().nonnegative().optional(),
+        maxWriteQueueDepth: z.number().int().nonnegative().optional(),
+        adapterExecuteTimeoutSeconds: z.number().int().positive().optional(),
+        streamInactivitySeconds: z.number().int().nonnegative().optional(),
+      })
+      .optional(),
+    streams: z
+      .object({
+        chunkPersistIntervalMs: z.number().int().nonnegative().optional(),
+        chunkBufferBytes: z.number().int().nonnegative().optional(),
+      })
+      .optional(),
+  })
+  .optional();
+
 export const ClawdbotSchema = z
   .object({
     env: z
@@ -161,6 +232,7 @@ export const ClawdbotSchema = z
           .optional(),
       })
       .optional(),
+    clawline: ClawlineConfigSchema,
     channels: ChannelsSchema,
     bridge: z
       .object({
diff --git a/src/gateway/config-reload.ts b/src/gateway/config-reload.ts
index d3aab0976..adcb4a9e6 100644
--- a/src/gateway/config-reload.ts
+++ b/src/gateway/config-reload.ts
@@ -78,6 +78,7 @@ const BASE_RELOAD_RULES_TAIL: ReloadRule[] = [
   { prefix: "skills", kind: "none" },
   { prefix: "plugins", kind: "restart" },
   { prefix: "ui", kind: "none" },
+  { prefix: "clawline", kind: "restart" },
   { prefix: "gateway", kind: "restart" },
   { prefix: "bridge", kind: "restart" },
   { prefix: "discovery", kind: "restart" },
diff --git a/src/gateway/server-close.ts b/src/gateway/server-close.ts
index 43d511005..f4e943c3b 100644
--- a/src/gateway/server-close.ts
+++ b/src/gateway/server-close.ts
@@ -5,6 +5,7 @@ import { type ChannelId, listChannelPlugins } from "../channels/plugins/index.js
 import { stopGmailWatcher } from "../hooks/gmail-watcher.js";
 import type { NodeBridgeServer } from "../infra/bridge/server.js";
 import type { PluginServicesHandle } from "../plugins/services.js";
+import type { ClawlineServiceHandle } from "../clawline/service.js";
 
 export function createGatewayCloseHandler(params: {
   bonjourStop: (() => Promise<void>) | null;
@@ -14,6 +15,7 @@ export function createGatewayCloseHandler(params: {
   bridge: NodeBridgeServer | null;
   stopChannel: (name: ChannelId, accountId?: string) => Promise<void>;
   pluginServices: PluginServicesHandle | null;
+  clawlineService: ClawlineServiceHandle | null;
   cron: { stop: () => void };
   heartbeatRunner: { stop: () => void };
   nodePresenceTimers: Map<string, ReturnType<typeof setInterval>>;
@@ -74,6 +76,9 @@ export function createGatewayCloseHandler(params: {
     if (params.pluginServices) {
       await params.pluginServices.stop().catch(() => {});
     }
+    if (params.clawlineService) {
+      await params.clawlineService.stop().catch(() => {});
+    }
     await stopGmailWatcher();
     params.cron.stop();
     params.heartbeatRunner.stop();
diff --git a/src/gateway/server-startup.ts b/src/gateway/server-startup.ts
index 9a41cd537..b08c032a3 100644
--- a/src/gateway/server-startup.ts
+++ b/src/gateway/server-startup.ts
@@ -7,6 +7,7 @@ import {
 } from "../agents/model-selection.js";
 import type { CliDeps } from "../cli/deps.js";
 import type { loadConfig } from "../config/config.js";
+import { startClawlineService, type ClawlineServiceHandle } from "../clawline/service.js";
 import { startGmailWatcher } from "../hooks/gmail-watcher.js";
 import type { loadClawdbotPlugins } from "../plugins/loader.js";
 import { type PluginServicesHandle, startPluginServices } from "../plugins/services.js";
@@ -30,6 +31,11 @@ export async function startGatewaySidecars(params: {
   };
   logChannels: { info: (msg: string) => void; error: (msg: string) => void };
   logBrowser: { error: (msg: string) => void };
+  logClawline: {
+    info: (msg: string) => void;
+    warn: (msg: string) => void;
+    error: (msg: string) => void;
+  };
 }) {
   // Start clawd browser control server (unless disabled via config).
   let browserControl: Awaited<ReturnType<typeof startBrowserControlServerIfEnabled>> = null;
@@ -117,11 +123,25 @@ export async function startGatewaySidecars(params: {
     params.log.warn(`plugin services failed to start: ${String(err)}`);
   }
 
+  let clawlineService: ClawlineServiceHandle | null = null;
+  if (process.env.CLAWDBOT_SKIP_CLAWLINE === "1") {
+    params.logClawline.info("skipping clawline service start (CLAWDBOT_SKIP_CLAWLINE=1)");
+  } else {
+    try {
+      clawlineService = await startClawlineService({
+        config: params.cfg,
+        logger: params.logClawline,
+      });
+    } catch (err) {
+      params.logClawline.error(`clawline service failed to start: ${String(err)}`);
+    }
+  }
+
   if (shouldWakeFromRestartSentinel()) {
     setTimeout(() => {
       void scheduleRestartSentinelWake({ deps: params.deps });
     }, 750);
   }
 
-  return { browserControl, pluginServices };
+  return { browserControl, pluginServices, clawlineService };
 }
diff --git a/src/gateway/server.config-patch.test.ts b/src/gateway/server.config-patch.test.ts
new file mode 100644
index 000000000..20d46f143
--- /dev/null
+++ b/src/gateway/server.config-patch.test.ts
@@ -0,0 +1,194 @@
+import { describe, expect, it } from "vitest";
+
+import {
+  connectOk,
+  installGatewayTestHooks,
+  onceMessage,
+  startServerWithClient,
+} from "./test-helpers.js";
+
+installGatewayTestHooks();
+
+describe("gateway config.patch", () => {
+  it("merges patches without clobbering unrelated config", async () => {
+    const { server, ws } = await startServerWithClient();
+    await connectOk(ws);
+
+    const setId = "req-set";
+    ws.send(
+      JSON.stringify({
+        type: "req",
+        id: setId,
+        method: "config.set",
+        params: {
+          raw: JSON.stringify({
+            gateway: { mode: "local" },
+            channels: { telegram: { botToken: "token-1" } },
+          }),
+        },
+      }),
+    );
+    const setRes = await onceMessage<{ ok: boolean }>(
+      ws,
+      (o) => o.type === "res" && o.id === setId,
+    );
+    expect(setRes.ok).toBe(true);
+
+    const getId = "req-get";
+    ws.send(
+      JSON.stringify({
+        type: "req",
+        id: getId,
+        method: "config.get",
+        params: {},
+      }),
+    );
+    const getRes = await onceMessage<{ ok: boolean; payload?: { hash?: string } }>(
+      ws,
+      (o) => o.type === "res" && o.id === getId,
+    );
+    expect(getRes.ok).toBe(true);
+    const baseHash = getRes.payload?.hash;
+    expect(typeof baseHash).toBe("string");
+
+    const patchId = "req-patch";
+    ws.send(
+      JSON.stringify({
+        type: "req",
+        id: patchId,
+        method: "config.patch",
+        params: {
+          raw: JSON.stringify({
+            channels: {
+              telegram: {
+                groups: {
+                  "*": { requireMention: false },
+                },
+              },
+            },
+          }),
+          baseHash,
+        },
+      }),
+    );
+    const patchRes = await onceMessage<{ ok: boolean }>(
+      ws,
+      (o) => o.type === "res" && o.id === patchId,
+    );
+    expect(patchRes.ok).toBe(true);
+
+    const get2Id = "req-get-2";
+    ws.send(
+      JSON.stringify({
+        type: "req",
+        id: get2Id,
+        method: "config.get",
+        params: {},
+      }),
+    );
+    const get2Res = await onceMessage<{
+      ok: boolean;
+      payload?: {
+        config?: { gateway?: { mode?: string }; channels?: { telegram?: { botToken?: string } } };
+      };
+    }>(ws, (o) => o.type === "res" && o.id === get2Id);
+    expect(get2Res.ok).toBe(true);
+    expect(get2Res.payload?.config?.gateway?.mode).toBe("local");
+    expect(get2Res.payload?.config?.channels?.telegram?.botToken).toBe("token-1");
+
+    ws.close();
+    await server.close();
+  });
+
+  it("requires base hash when config exists", async () => {
+    const { server, ws } = await startServerWithClient();
+    await connectOk(ws);
+
+    const setId = "req-set-2";
+    ws.send(
+      JSON.stringify({
+        type: "req",
+        id: setId,
+        method: "config.set",
+        params: {
+          raw: JSON.stringify({
+            gateway: { mode: "local" },
+          }),
+        },
+      }),
+    );
+    const setRes = await onceMessage<{ ok: boolean }>(
+      ws,
+      (o) => o.type === "res" && o.id === setId,
+    );
+    expect(setRes.ok).toBe(true);
+
+    const patchId = "req-patch-2";
+    ws.send(
+      JSON.stringify({
+        type: "req",
+        id: patchId,
+        method: "config.patch",
+        params: {
+          raw: JSON.stringify({ gateway: { mode: "remote" } }),
+        },
+      }),
+    );
+    const patchRes = await onceMessage<{ ok: boolean; error?: { message?: string } }>(
+      ws,
+      (o) => o.type === "res" && o.id === patchId,
+    );
+    expect(patchRes.ok).toBe(false);
+    expect(patchRes.error?.message).toContain("base hash");
+
+    ws.close();
+    await server.close();
+  });
+
+  it("requires base hash for config.set when config exists", async () => {
+    const { server, ws } = await startServerWithClient();
+    await connectOk(ws);
+
+    const setId = "req-set-3";
+    ws.send(
+      JSON.stringify({
+        type: "req",
+        id: setId,
+        method: "config.set",
+        params: {
+          raw: JSON.stringify({
+            gateway: { mode: "local" },
+          }),
+        },
+      }),
+    );
+    const setRes = await onceMessage<{ ok: boolean }>(
+      ws,
+      (o) => o.type === "res" && o.id === setId,
+    );
+    expect(setRes.ok).toBe(true);
+
+    const set2Id = "req-set-4";
+    ws.send(
+      JSON.stringify({
+        type: "req",
+        id: set2Id,
+        method: "config.set",
+        params: {
+          raw: JSON.stringify({
+            gateway: { mode: "remote" },
+          }),
+        },
+      }),
+    );
+    const set2Res = await onceMessage<{ ok: boolean; error?: { message?: string } }>(
+      ws,
+      (o) => o.type === "res" && o.id === set2Id,
+    );
+    expect(set2Res.ok).toBe(false);
+    expect(set2Res.error?.message).toContain("base hash");
+
+    ws.close();
+    await server.close();
+  });
+});
diff --git a/src/gateway/server.impl.ts b/src/gateway/server.impl.ts
index 1b043a8f2..fb9b7a245 100644
--- a/src/gateway/server.impl.ts
+++ b/src/gateway/server.impl.ts
@@ -47,6 +47,7 @@ import { resolveGatewayRuntimeConfig } from "./server-runtime-config.js";
 import { createGatewayRuntimeState } from "./server-runtime-state.js";
 import { resolveSessionKeyForRun } from "./server-session-key.js";
 import { startGatewaySidecars } from "./server-startup.js";
+import type { ClawlineServiceHandle } from "../clawline/service.js";
 import { logGatewayStartup } from "./server-startup-log.js";
 import { startGatewayTailscaleExposure } from "./server-tailscale.js";
 import { createWizardSessionTracker } from "./server-wizard-sessions.js";
@@ -68,6 +69,7 @@ const logCron = log.child("cron");
 const logReload = log.child("reload");
 const logHooks = log.child("hooks");
 const logWsControl = log.child("ws");
+const logClawline = log.child("clawline");
 const canvasRuntime = runtimeForLogger(logCanvas);
 const channelLogs = Object.fromEntries(
   listChannelPlugins().map((plugin) => [plugin.id, logChannels.child(plugin.id)]),
@@ -171,6 +173,7 @@ export async function startGatewayServer(
     baseMethods: METHODS,
   });
   let pluginServices: PluginServicesHandle | null = null;
+  let clawlineService: ClawlineServiceHandle | null = null;
   const runtimeConfig = await resolveGatewayRuntimeConfig({
     cfg: cfgAtStart,
     port,
@@ -385,7 +388,7 @@ export async function startGatewayServer(
   });
 
   let browserControl: Awaited<ReturnType<typeof startBrowserControlServerIfEnabled>> = null;
-  ({ browserControl, pluginServices } = await startGatewaySidecars({
+  ({ browserControl, pluginServices, clawlineService } = await startGatewaySidecars({
     cfg: cfgAtStart,
     pluginRegistry,
     defaultWorkspaceDir,
@@ -395,6 +398,7 @@ export async function startGatewayServer(
     logHooks,
     logChannels,
     logBrowser,
+    logClawline,
   }));
 
   const { applyHotReload, requestGatewayRestart } = createGatewayReloadHandlers({
@@ -444,6 +448,7 @@ export async function startGatewayServer(
     bridge,
     stopChannel,
     pluginServices,
+    clawlineService,
     cron,
     heartbeatRunner,
     nodePresenceTimers,
diff --git a/src/gateway/server/__tests__/test-utils.ts b/src/gateway/server/__tests__/test-utils.ts
new file mode 100644
index 000000000..e1d14f8f5
--- /dev/null
+++ b/src/gateway/server/__tests__/test-utils.ts
@@ -0,0 +1,20 @@
+import type { PluginRegistry } from "../../../plugins/registry.js";
+
+export const createTestRegistry = (overrides: Partial<PluginRegistry> = {}): PluginRegistry => {
+  const base: PluginRegistry = {
+    plugins: [],
+    tools: [],
+    channels: [],
+    gatewayHandlers: {},
+    httpHandlers: [],
+    cliRegistrars: [],
+    services: [],
+    diagnostics: [],
+  };
+  const merged = { ...base, ...overrides };
+  return {
+    ...merged,
+    gatewayHandlers: merged.gatewayHandlers ?? {},
+    httpHandlers: merged.httpHandlers ?? [],
+  };
+};
diff --git a/src/gateway/server/plugins-http.test.ts b/src/gateway/server/plugins-http.test.ts
new file mode 100644
index 000000000..e4d54a68b
--- /dev/null
+++ b/src/gateway/server/plugins-http.test.ts
@@ -0,0 +1,86 @@
+import type { IncomingMessage, ServerResponse } from "node:http";
+import { describe, expect, it, vi } from "vitest";
+
+import { createGatewayPluginRequestHandler } from "./plugins-http.js";
+import { createTestRegistry } from "./__tests__/test-utils.js";
+
+const makeResponse = (): {
+  res: ServerResponse;
+  setHeader: ReturnType<typeof vi.fn>;
+  end: ReturnType<typeof vi.fn>;
+} => {
+  const setHeader = vi.fn();
+  const end = vi.fn();
+  const res = {
+    headersSent: false,
+    statusCode: 200,
+    setHeader,
+    end,
+  } as unknown as ServerResponse;
+  return { res, setHeader, end };
+};
+
+describe("createGatewayPluginRequestHandler", () => {
+  it("returns false when no handlers are registered", async () => {
+    const log = { warn: vi.fn() } as unknown as Parameters<
+      typeof createGatewayPluginRequestHandler
+    >[0]["log"];
+    const handler = createGatewayPluginRequestHandler({
+      registry: createTestRegistry(),
+      log,
+    });
+    const { res } = makeResponse();
+    const handled = await handler({} as IncomingMessage, res);
+    expect(handled).toBe(false);
+  });
+
+  it("continues until a handler reports it handled the request", async () => {
+    const first = vi.fn(async () => false);
+    const second = vi.fn(async () => true);
+    const handler = createGatewayPluginRequestHandler({
+      registry: createTestRegistry({
+        httpHandlers: [
+          { pluginId: "first", handler: first, source: "first" },
+          { pluginId: "second", handler: second, source: "second" },
+        ],
+      }),
+      log: { warn: vi.fn() } as unknown as Parameters<
+        typeof createGatewayPluginRequestHandler
+      >[0]["log"],
+    });
+
+    const { res } = makeResponse();
+    const handled = await handler({} as IncomingMessage, res);
+    expect(handled).toBe(true);
+    expect(first).toHaveBeenCalledTimes(1);
+    expect(second).toHaveBeenCalledTimes(1);
+  });
+
+  it("logs and responds with 500 when a handler throws", async () => {
+    const log = { warn: vi.fn() } as unknown as Parameters<
+      typeof createGatewayPluginRequestHandler
+    >[0]["log"];
+    const handler = createGatewayPluginRequestHandler({
+      registry: createTestRegistry({
+        httpHandlers: [
+          {
+            pluginId: "boom",
+            handler: async () => {
+              throw new Error("boom");
+            },
+            source: "boom",
+          },
+        ],
+      }),
+      log,
+    });
+
+    const { res, setHeader, end } = makeResponse();
+    const handled = await handler({} as IncomingMessage, res);
+    expect(handled).toBe(true);
+    expect(log.warn).toHaveBeenCalledWith(expect.stringContaining("boom"));
+    expect(res.statusCode).toBe(500);
+    expect(setHeader).toHaveBeenCalledWith("Content-Type", "text/plain; charset=utf-8");
+    expect(end).toHaveBeenCalledWith("Internal Server Error");
+  });
+});
diff --git a/src/gateway/server/plugins-http.ts b/src/gateway/server/plugins-http.ts
new file mode 100644
index 000000000..956b2ea8f
--- /dev/null
+++ b/src/gateway/server/plugins-http.ts
@@ -0,0 +1,36 @@
+import type { IncomingMessage, ServerResponse } from "node:http";
+
+import type { createSubsystemLogger } from "../../logging.js";
+import type { PluginRegistry } from "../../plugins/registry.js";
+
+type SubsystemLogger = ReturnType<typeof createSubsystemLogger>;
+
+export type PluginHttpRequestHandler = (
+  req: IncomingMessage,
+  res: ServerResponse,
+) => Promise<boolean>;
+
+export function createGatewayPluginRequestHandler(params: {
+  registry: PluginRegistry;
+  log: SubsystemLogger;
+}): PluginHttpRequestHandler {
+  const { registry, log } = params;
+  return async (req, res) => {
+    if (registry.httpHandlers.length === 0) return false;
+    for (const entry of registry.httpHandlers) {
+      try {
+        const handled = await entry.handler(req, res);
+        if (handled) return true;
+      } catch (err) {
+        log.warn(`plugin http handler failed (${entry.pluginId}): ${String(err)}`);
+        if (!res.headersSent) {
+          res.statusCode = 500;
+          res.setHeader("Content-Type", "text/plain; charset=utf-8");
+          res.end("Internal Server Error");
+        }
+        return true;
+      }
+    }
+    return false;
+  };
+}
diff --git a/src/logging/console-capture.test.ts b/src/logging/console-capture.test.ts
new file mode 100644
index 000000000..623587604
--- /dev/null
+++ b/src/logging/console-capture.test.ts
@@ -0,0 +1,85 @@
+import crypto from "node:crypto";
+import os from "node:os";
+import path from "node:path";
+
+import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
+
+import {
+  enableConsoleCapture,
+  resetLogger,
+  routeLogsToStderr,
+  setLoggerOverride,
+} from "../logging.js";
+import { loggingState } from "./state.js";
+
+type ConsoleSnapshot = {
+  log: typeof console.log;
+  info: typeof console.info;
+  warn: typeof console.warn;
+  error: typeof console.error;
+  debug: typeof console.debug;
+  trace: typeof console.trace;
+};
+
+let snapshot: ConsoleSnapshot;
+
+beforeEach(() => {
+  snapshot = {
+    log: console.log,
+    info: console.info,
+    warn: console.warn,
+    error: console.error,
+    debug: console.debug,
+    trace: console.trace,
+  };
+  loggingState.consolePatched = false;
+  loggingState.forceConsoleToStderr = false;
+  loggingState.rawConsole = null;
+  resetLogger();
+});
+
+afterEach(() => {
+  console.log = snapshot.log;
+  console.info = snapshot.info;
+  console.warn = snapshot.warn;
+  console.error = snapshot.error;
+  console.debug = snapshot.debug;
+  console.trace = snapshot.trace;
+  loggingState.consolePatched = false;
+  loggingState.forceConsoleToStderr = false;
+  loggingState.rawConsole = null;
+  resetLogger();
+  setLoggerOverride(null);
+  vi.restoreAllMocks();
+});
+
+describe("enableConsoleCapture", () => {
+  it("swallows EIO from stderr writes", () => {
+    setLoggerOverride({ level: "info", file: tempLogPath() });
+    vi.spyOn(process.stderr, "write").mockImplementation(() => {
+      throw eioError();
+    });
+    routeLogsToStderr();
+    enableConsoleCapture();
+    expect(() => console.log("hello")).not.toThrow();
+  });
+
+  it("swallows EIO from original console writes", () => {
+    setLoggerOverride({ level: "info", file: tempLogPath() });
+    console.log = () => {
+      throw eioError();
+    };
+    enableConsoleCapture();
+    expect(() => console.log("hello")).not.toThrow();
+  });
+});
+
+function tempLogPath() {
+  return path.join(os.tmpdir(), `clawdbot-log-${crypto.randomUUID()}.log`);
+}
+
+function eioError() {
+  const err = new Error("EIO") as NodeJS.ErrnoException;
+  err.code = "EIO";
+  return err;
+}
diff --git a/src/markdown/ir.ts b/src/markdown/ir.ts
new file mode 100644
index 000000000..c823381d8
--- /dev/null
+++ b/src/markdown/ir.ts
@@ -0,0 +1,494 @@
+import MarkdownIt from "markdown-it";
+
+import { chunkText } from "../auto-reply/chunk.js";
+
+type ListState = {
+  type: "bullet" | "ordered";
+  index: number;
+};
+
+type LinkState = {
+  href: string;
+  labelStart: number;
+};
+
+type RenderEnv = {
+  listStack: ListState[];
+  linkStack: LinkState[];
+};
+
+type MarkdownToken = {
+  type: string;
+  content?: string;
+  children?: MarkdownToken[];
+  attrs?: [string, string][];
+  attrGet?: (name: string) => string | null;
+};
+
+export type MarkdownStyle = "bold" | "italic" | "strikethrough" | "code" | "code_block" | "spoiler";
+
+export type MarkdownStyleSpan = {
+  start: number;
+  end: number;
+  style: MarkdownStyle;
+};
+
+export type MarkdownLinkSpan = {
+  start: number;
+  end: number;
+  href: string;
+};
+
+export type MarkdownIR = {
+  text: string;
+  styles: MarkdownStyleSpan[];
+  links: MarkdownLinkSpan[];
+};
+
+type OpenStyle = {
+  style: MarkdownStyle;
+  start: number;
+};
+
+type RenderState = {
+  text: string;
+  styles: MarkdownStyleSpan[];
+  openStyles: OpenStyle[];
+  links: MarkdownLinkSpan[];
+  env: RenderEnv;
+  headingStyle: "none" | "bold";
+  blockquotePrefix: string;
+  enableSpoilers: boolean;
+};
+
+export type MarkdownParseOptions = {
+  linkify?: boolean;
+  enableSpoilers?: boolean;
+  headingStyle?: "none" | "bold";
+  blockquotePrefix?: string;
+  autolink?: boolean;
+};
+
+function createMarkdownIt(options: MarkdownParseOptions): MarkdownIt {
+  const md = new MarkdownIt({
+    html: false,
+    linkify: options.linkify ?? true,
+    breaks: false,
+    typographer: false,
+  });
+  md.enable("strikethrough");
+  if (options.autolink === false) {
+    md.disable("autolink");
+  }
+  return md;
+}
+
+function getAttr(token: MarkdownToken, name: string): string | null {
+  if (token.attrGet) return token.attrGet(name);
+  if (token.attrs) {
+    for (const [key, value] of token.attrs) {
+      if (key === name) return value;
+    }
+  }
+  return null;
+}
+
+function createTextToken(base: MarkdownToken, content: string): MarkdownToken {
+  return { ...base, type: "text", content, children: undefined };
+}
+
+function applySpoilerTokens(tokens: MarkdownToken[]): void {
+  for (const token of tokens) {
+    if (token.children && token.children.length > 0) {
+      token.children = injectSpoilersIntoInline(token.children);
+    }
+  }
+}
+
+function injectSpoilersIntoInline(tokens: MarkdownToken[]): MarkdownToken[] {
+  const result: MarkdownToken[] = [];
+  const state = { spoilerOpen: false };
+
+  for (const token of tokens) {
+    if (token.type !== "text") {
+      result.push(token);
+      continue;
+    }
+
+    const content = token.content ?? "";
+    if (!content.includes("||")) {
+      result.push(token);
+      continue;
+    }
+
+    let index = 0;
+    while (index < content.length) {
+      const next = content.indexOf("||", index);
+      if (next === -1) {
+        if (index < content.length) {
+          result.push(createTextToken(token, content.slice(index)));
+        }
+        break;
+      }
+      if (next > index) {
+        result.push(createTextToken(token, content.slice(index, next)));
+      }
+      state.spoilerOpen = !state.spoilerOpen;
+      result.push({
+        type: state.spoilerOpen ? "spoiler_open" : "spoiler_close",
+      });
+      index = next + 2;
+    }
+  }
+
+  return result;
+}
+
+function appendText(state: RenderState, value: string) {
+  if (!value) return;
+  state.text += value;
+}
+
+function openStyle(state: RenderState, style: MarkdownStyle) {
+  state.openStyles.push({ style, start: state.text.length });
+}
+
+function closeStyle(state: RenderState, style: MarkdownStyle) {
+  for (let i = state.openStyles.length - 1; i >= 0; i -= 1) {
+    if (state.openStyles[i]?.style === style) {
+      const start = state.openStyles[i].start;
+      state.openStyles.splice(i, 1);
+      const end = state.text.length;
+      if (end > start) {
+        state.styles.push({ start, end, style });
+      }
+      return;
+    }
+  }
+}
+
+function appendParagraphSeparator(state: RenderState) {
+  if (state.env.listStack.length > 0) return;
+  appendText(state, "\n\n");
+}
+
+function appendListPrefix(state: RenderState) {
+  const stack = state.env.listStack;
+  const top = stack[stack.length - 1];
+  if (!top) return;
+  top.index += 1;
+  const indent = "  ".repeat(Math.max(0, stack.length - 1));
+  const prefix = top.type === "ordered" ? `${top.index}. ` : "• ";
+  appendText(state, `${indent}${prefix}`);
+}
+
+function renderInlineCode(state: RenderState, content: string) {
+  if (!content) return;
+  const start = state.text.length;
+  appendText(state, content);
+  state.styles.push({ start, end: start + content.length, style: "code" });
+}
+
+function renderCodeBlock(state: RenderState, content: string) {
+  let code = content ?? "";
+  if (!code.endsWith("\n")) code = `${code}\n`;
+  const start = state.text.length;
+  appendText(state, code);
+  state.styles.push({ start, end: start + code.length, style: "code_block" });
+  if (state.env.listStack.length === 0) {
+    appendText(state, "\n");
+  }
+}
+
+function handleLinkClose(state: RenderState) {
+  const link = state.env.linkStack.pop();
+  if (!link?.href) return;
+  const href = link.href.trim();
+  if (!href) return;
+  const start = link.labelStart;
+  const end = state.text.length;
+  if (end <= start) {
+    state.links.push({ start, end, href });
+    return;
+  }
+  state.links.push({ start, end, href });
+}
+
+function renderTokens(tokens: MarkdownToken[], state: RenderState): void {
+  for (const token of tokens) {
+    switch (token.type) {
+      case "inline":
+        if (token.children) renderTokens(token.children, state);
+        break;
+      case "text":
+        appendText(state, token.content ?? "");
+        break;
+      case "em_open":
+        openStyle(state, "italic");
+        break;
+      case "em_close":
+        closeStyle(state, "italic");
+        break;
+      case "strong_open":
+        openStyle(state, "bold");
+        break;
+      case "strong_close":
+        closeStyle(state, "bold");
+        break;
+      case "s_open":
+        openStyle(state, "strikethrough");
+        break;
+      case "s_close":
+        closeStyle(state, "strikethrough");
+        break;
+      case "code_inline":
+        renderInlineCode(state, token.content ?? "");
+        break;
+      case "spoiler_open":
+        if (state.enableSpoilers) openStyle(state, "spoiler");
+        break;
+      case "spoiler_close":
+        if (state.enableSpoilers) closeStyle(state, "spoiler");
+        break;
+      case "link_open": {
+        const href = getAttr(token, "href") ?? "";
+        state.env.linkStack.push({ href, labelStart: state.text.length });
+        break;
+      }
+      case "link_close":
+        handleLinkClose(state);
+        break;
+      case "image":
+        appendText(state, token.content ?? "");
+        break;
+      case "softbreak":
+      case "hardbreak":
+        appendText(state, "\n");
+        break;
+      case "paragraph_close":
+        appendParagraphSeparator(state);
+        break;
+      case "heading_open":
+        if (state.headingStyle === "bold") openStyle(state, "bold");
+        break;
+      case "heading_close":
+        if (state.headingStyle === "bold") closeStyle(state, "bold");
+        appendParagraphSeparator(state);
+        break;
+      case "blockquote_open":
+        if (state.blockquotePrefix) appendText(state, state.blockquotePrefix);
+        break;
+      case "blockquote_close":
+        appendText(state, "\n");
+        break;
+      case "bullet_list_open":
+        state.env.listStack.push({ type: "bullet", index: 0 });
+        break;
+      case "bullet_list_close":
+        state.env.listStack.pop();
+        break;
+      case "ordered_list_open": {
+        const start = Number(getAttr(token, "start") ?? "1");
+        state.env.listStack.push({ type: "ordered", index: start - 1 });
+        break;
+      }
+      case "ordered_list_close":
+        state.env.listStack.pop();
+        break;
+      case "list_item_open":
+        appendListPrefix(state);
+        break;
+      case "list_item_close":
+        appendText(state, "\n");
+        break;
+      case "code_block":
+      case "fence":
+        renderCodeBlock(state, token.content ?? "");
+        break;
+      case "html_block":
+      case "html_inline":
+        appendText(state, token.content ?? "");
+        break;
+      case "table_open":
+      case "table_close":
+      case "thead_open":
+      case "thead_close":
+      case "tbody_open":
+      case "tbody_close":
+        break;
+      case "tr_close":
+        appendText(state, "\n");
+        break;
+      case "th_close":
+      case "td_close":
+        appendText(state, "\t");
+        break;
+      case "hr":
+        appendText(state, "\n");
+        break;
+      default:
+        if (token.children) renderTokens(token.children, state);
+        break;
+    }
+  }
+}
+
+function closeRemainingStyles(state: RenderState) {
+  for (let i = state.openStyles.length - 1; i >= 0; i -= 1) {
+    const open = state.openStyles[i];
+    const end = state.text.length;
+    if (end > open.start) {
+      state.styles.push({
+        start: open.start,
+        end,
+        style: open.style,
+      });
+    }
+  }
+  state.openStyles = [];
+}
+
+function clampStyleSpans(spans: MarkdownStyleSpan[], maxLength: number): MarkdownStyleSpan[] {
+  const clamped: MarkdownStyleSpan[] = [];
+  for (const span of spans) {
+    const start = Math.max(0, Math.min(span.start, maxLength));
+    const end = Math.max(start, Math.min(span.end, maxLength));
+    if (end > start) clamped.push({ start, end, style: span.style });
+  }
+  return clamped;
+}
+
+function clampLinkSpans(spans: MarkdownLinkSpan[], maxLength: number): MarkdownLinkSpan[] {
+  const clamped: MarkdownLinkSpan[] = [];
+  for (const span of spans) {
+    const start = Math.max(0, Math.min(span.start, maxLength));
+    const end = Math.max(start, Math.min(span.end, maxLength));
+    if (end > start) clamped.push({ start, end, href: span.href });
+  }
+  return clamped;
+}
+
+function mergeStyleSpans(spans: MarkdownStyleSpan[]): MarkdownStyleSpan[] {
+  const sorted = [...spans].sort((a, b) => {
+    if (a.start !== b.start) return a.start - b.start;
+    if (a.end !== b.end) return a.end - b.end;
+    return a.style.localeCompare(b.style);
+  });
+
+  const merged: MarkdownStyleSpan[] = [];
+  for (const span of sorted) {
+    const prev = merged[merged.length - 1];
+    if (prev && prev.style === span.style && span.start <= prev.end) {
+      prev.end = Math.max(prev.end, span.end);
+      continue;
+    }
+    merged.push({ ...span });
+  }
+  return merged;
+}
+
+function sliceStyleSpans(
+  spans: MarkdownStyleSpan[],
+  start: number,
+  end: number,
+): MarkdownStyleSpan[] {
+  if (spans.length === 0) return [];
+  const sliced: MarkdownStyleSpan[] = [];
+  for (const span of spans) {
+    const sliceStart = Math.max(span.start, start);
+    const sliceEnd = Math.min(span.end, end);
+    if (sliceEnd > sliceStart) {
+      sliced.push({
+        start: sliceStart - start,
+        end: sliceEnd - start,
+        style: span.style,
+      });
+    }
+  }
+  return mergeStyleSpans(sliced);
+}
+
+function sliceLinkSpans(spans: MarkdownLinkSpan[], start: number, end: number): MarkdownLinkSpan[] {
+  if (spans.length === 0) return [];
+  const sliced: MarkdownLinkSpan[] = [];
+  for (const span of spans) {
+    const sliceStart = Math.max(span.start, start);
+    const sliceEnd = Math.min(span.end, end);
+    if (sliceEnd > sliceStart) {
+      sliced.push({
+        start: sliceStart - start,
+        end: sliceEnd - start,
+        href: span.href,
+      });
+    }
+  }
+  return sliced;
+}
+
+export function markdownToIR(markdown: string, options: MarkdownParseOptions = {}): MarkdownIR {
+  const env: RenderEnv = { listStack: [], linkStack: [] };
+  const md = createMarkdownIt(options);
+  const tokens = md.parse(markdown ?? "", env as unknown as object);
+  if (options.enableSpoilers) {
+    applySpoilerTokens(tokens as MarkdownToken[]);
+  }
+
+  const state: RenderState = {
+    text: "",
+    styles: [],
+    openStyles: [],
+    links: [],
+    env,
+    headingStyle: options.headingStyle ?? "none",
+    blockquotePrefix: options.blockquotePrefix ?? "",
+    enableSpoilers: options.enableSpoilers ?? false,
+  };
+
+  renderTokens(tokens as MarkdownToken[], state);
+  closeRemainingStyles(state);
+
+  const trimmedText = state.text.trimEnd();
+  const trimmedLength = trimmedText.length;
+  let codeBlockEnd = 0;
+  for (const span of state.styles) {
+    if (span.style !== "code_block") continue;
+    if (span.end > codeBlockEnd) codeBlockEnd = span.end;
+  }
+  const finalLength = Math.max(trimmedLength, codeBlockEnd);
+  const finalText =
+    finalLength === state.text.length ? state.text : state.text.slice(0, finalLength);
+
+  return {
+    text: finalText,
+    styles: mergeStyleSpans(clampStyleSpans(state.styles, finalLength)),
+    links: clampLinkSpans(state.links, finalLength),
+  };
+}
+
+export function chunkMarkdownIR(ir: MarkdownIR, limit: number): MarkdownIR[] {
+  if (!ir.text) return [];
+  if (limit <= 0 || ir.text.length <= limit) return [ir];
+
+  const chunks = chunkText(ir.text, limit);
+  const results: MarkdownIR[] = [];
+  let cursor = 0;
+
+  chunks.forEach((chunk, index) => {
+    if (!chunk) return;
+    if (index > 0) {
+      while (cursor < ir.text.length && /\s/.test(ir.text[cursor] ?? "")) {
+        cursor += 1;
+      }
+    }
+    const start = cursor;
+    const end = Math.min(ir.text.length, start + chunk.length);
+    results.push({
+      text: chunk,
+      styles: sliceStyleSpans(ir.styles, start, end),
+      links: sliceLinkSpans(ir.links, start, end),
+    });
+    cursor = end;
+  });
+
+  return results;
+}
diff --git a/src/markdown/render.ts b/src/markdown/render.ts
new file mode 100644
index 000000000..502ab69ef
--- /dev/null
+++ b/src/markdown/render.ts
@@ -0,0 +1,135 @@
+import type { MarkdownIR, MarkdownLinkSpan, MarkdownStyle, MarkdownStyleSpan } from "./ir.js";
+
+export type RenderStyleMarker = {
+  open: string;
+  close: string;
+};
+
+export type RenderStyleMap = Partial<Record<MarkdownStyle, RenderStyleMarker>>;
+
+export type RenderLink = {
+  start: number;
+  end: number;
+  open: string;
+  close: string;
+};
+
+export type RenderOptions = {
+  styleMarkers: RenderStyleMap;
+  escapeText: (text: string) => string;
+  buildLink?: (link: MarkdownLinkSpan, text: string) => RenderLink | null;
+};
+
+const STYLE_ORDER: MarkdownStyle[] = [
+  "code_block",
+  "code",
+  "bold",
+  "italic",
+  "strikethrough",
+  "spoiler",
+];
+
+const STYLE_RANK = new Map<MarkdownStyle, number>(
+  STYLE_ORDER.map((style, index) => [style, index]),
+);
+
+function sortStyleSpans(spans: MarkdownStyleSpan[]): MarkdownStyleSpan[] {
+  return [...spans].sort((a, b) => {
+    if (a.start !== b.start) return a.start - b.start;
+    if (a.end !== b.end) return b.end - a.end;
+    return (STYLE_RANK.get(a.style) ?? 0) - (STYLE_RANK.get(b.style) ?? 0);
+  });
+}
+
+export function renderMarkdownWithMarkers(ir: MarkdownIR, options: RenderOptions): string {
+  const text = ir.text ?? "";
+  if (!text) return "";
+
+  const styleMarkers = options.styleMarkers;
+  const styled = sortStyleSpans(ir.styles.filter((span) => Boolean(styleMarkers[span.style])));
+
+  const boundaries = new Set<number>();
+  boundaries.add(0);
+  boundaries.add(text.length);
+
+  const startsAt = new Map<number, MarkdownStyleSpan[]>();
+  for (const span of styled) {
+    if (span.start === span.end) continue;
+    boundaries.add(span.start);
+    boundaries.add(span.end);
+    const bucket = startsAt.get(span.start);
+    if (bucket) bucket.push(span);
+    else startsAt.set(span.start, [span]);
+  }
+  for (const spans of startsAt.values()) {
+    spans.sort((a, b) => {
+      if (a.end !== b.end) return b.end - a.end;
+      return (STYLE_RANK.get(a.style) ?? 0) - (STYLE_RANK.get(b.style) ?? 0);
+    });
+  }
+
+  const linkStarts = new Map<number, RenderLink[]>();
+  const linkEnds = new Map<number, RenderLink[]>();
+  if (options.buildLink) {
+    for (const link of ir.links) {
+      if (link.start === link.end) continue;
+      const rendered = options.buildLink(link, text);
+      if (!rendered) continue;
+      boundaries.add(rendered.start);
+      boundaries.add(rendered.end);
+      const openBucket = linkStarts.get(rendered.start);
+      if (openBucket) openBucket.push(rendered);
+      else linkStarts.set(rendered.start, [rendered]);
+      const closeBucket = linkEnds.get(rendered.end);
+      if (closeBucket) closeBucket.push(rendered);
+      else linkEnds.set(rendered.end, [rendered]);
+    }
+  }
+
+  const points = [...boundaries].sort((a, b) => a - b);
+  const stack: MarkdownStyleSpan[] = [];
+  let out = "";
+
+  for (let i = 0; i < points.length; i += 1) {
+    const pos = points[i];
+
+    while (stack.length && stack[stack.length - 1]?.end === pos) {
+      const span = stack.pop();
+      if (!span) break;
+      const marker = styleMarkers[span.style];
+      if (marker) out += marker.close;
+    }
+
+    const closingLinks = linkEnds.get(pos);
+    if (closingLinks && closingLinks.length > 0) {
+      for (const link of closingLinks) {
+        out += link.close;
+      }
+    }
+
+    const openingLinks = linkStarts.get(pos);
+    if (openingLinks && openingLinks.length > 0) {
+      for (const link of openingLinks) {
+        out += link.open;
+      }
+    }
+
+    const openingStyles = startsAt.get(pos);
+    if (openingStyles) {
+      for (const span of openingStyles) {
+        const marker = styleMarkers[span.style];
+        if (!marker) continue;
+        stack.push(span);
+        out += marker.open;
+      }
+    }
+
+    const next = points[i + 1];
+    if (next === undefined) break;
+    if (next > pos) {
+      out += options.escapeText(text.slice(pos, next));
+    }
+  }
+
+  return out;
+}
diff --git a/src/plugins/runtime.ts b/src/plugins/runtime.ts
new file mode 100644
index 000000000..f814a0811
--- /dev/null
+++ b/src/plugins/runtime.ts
@@ -0,0 +1,17 @@
+import type { PluginRegistry } from "./registry.js";
+
+let activeRegistry: PluginRegistry | null = null;
+let activeRegistryKey: string | null = null;
+
+export function setActivePluginRegistry(registry: PluginRegistry, cacheKey?: string) {
+  activeRegistry = registry;
+  activeRegistryKey = cacheKey ?? null;
+}
+
+export function getActivePluginRegistry(): PluginRegistry | null {
+  return activeRegistry;
+}
+
+export function getActivePluginRegistryKey(): string | null {
+  return activeRegistryKey;
+}
diff --git a/src/security/audit-extra.ts b/src/security/audit-extra.ts
new file mode 100644
index 000000000..242363929
--- /dev/null
+++ b/src/security/audit-extra.ts
@@ -0,0 +1,574 @@
+import fs from "node:fs/promises";
+import path from "node:path";
+
+import JSON5 from "json5";
+
+import type { ClawdbotConfig, ConfigFileSnapshot } from "../config/config.js";
+import { createConfigIO } from "../config/config.js";
+import { resolveOAuthDir } from "../config/paths.js";
+import { resolveDefaultAgentId } from "../agents/agent-scope.js";
+import { INCLUDE_KEY, MAX_INCLUDE_DEPTH } from "../config/includes.js";
+import { normalizeAgentId } from "../routing/session-key.js";
+import {
+  formatOctal,
+  isGroupReadable,
+  isGroupWritable,
+  isWorldReadable,
+  isWorldWritable,
+  modeBits,
+  safeStat,
+} from "./audit-fs.js";
+
+export type SecurityAuditFinding = {
+  checkId: string;
+  severity: "info" | "warn" | "critical";
+  title: string;
+  detail: string;
+  remediation?: string;
+};
+
+function expandTilde(p: string, env: NodeJS.ProcessEnv): string | null {
+  if (!p.startsWith("~")) return p;
+  const home = typeof env.HOME === "string" && env.HOME.trim() ? env.HOME.trim() : null;
+  if (!home) return null;
+  if (p === "~") return home;
+  if (p.startsWith("~/") || p.startsWith("~\\")) return path.join(home, p.slice(2));
+  return null;
+}
+
+function summarizeGroupPolicy(cfg: ClawdbotConfig): { open: number; allowlist: number; other: number } {
+  const channels = cfg.channels as Record<string, unknown> | undefined;
+  if (!channels || typeof channels !== "object") return { open: 0, allowlist: 0, other: 0 };
+  let open = 0;
+  let allowlist = 0;
+  let other = 0;
+  for (const value of Object.values(channels)) {
+    if (!value || typeof value !== "object") continue;
+    const section = value as Record<string, unknown>;
+    const policy = section.groupPolicy;
+    if (policy === "open") open += 1;
+    else if (policy === "allowlist") allowlist += 1;
+    else other += 1;
+  }
+  return { open, allowlist, other };
+}
+
+export function collectAttackSurfaceSummaryFindings(cfg: ClawdbotConfig): SecurityAuditFinding[] {
+  const group = summarizeGroupPolicy(cfg);
+  const elevated = cfg.tools?.elevated?.enabled !== false;
+  const hooksEnabled = cfg.hooks?.enabled === true;
+  const browserEnabled = Boolean(cfg.browser?.enabled ?? cfg.browser?.controlUrl);
+
+  const detail =
+    `groups: open=${group.open}, allowlist=${group.allowlist}` +
+    `\n` +
+    `tools.elevated: ${elevated ? "enabled" : "disabled"}` +
+    `\n` +
+    `hooks: ${hooksEnabled ? "enabled" : "disabled"}` +
+    `\n` +
+    `browser control: ${browserEnabled ? "enabled" : "disabled"}`;
+
+  return [
+    {
+      checkId: "summary.attack_surface",
+      severity: "info",
+      title: "Attack surface summary",
+      detail,
+    },
+  ];
+}
+
+function isProbablySyncedPath(p: string): boolean {
+  const s = p.toLowerCase();
+  return (
+    s.includes("icloud") ||
+    s.includes("dropbox") ||
+    s.includes("google drive") ||
+    s.includes("googledrive") ||
+    s.includes("onedrive")
+  );
+}
+
+export function collectSyncedFolderFindings(params: {
+  stateDir: string;
+  configPath: string;
+}): SecurityAuditFinding[] {
+  const findings: SecurityAuditFinding[] = [];
+  if (isProbablySyncedPath(params.stateDir) || isProbablySyncedPath(params.configPath)) {
+    findings.push({
+      checkId: "fs.synced_dir",
+      severity: "warn",
+      title: "State/config path looks like a synced folder",
+      detail: `stateDir=${params.stateDir}, configPath=${params.configPath}. Synced folders (iCloud/Dropbox/OneDrive/Google Drive) can leak tokens and transcripts onto other devices.`,
+      remediation: `Keep CLAWDBOT_STATE_DIR on a local-only volume and re-run "clawdbot security audit --fix".`,
+    });
+  }
+  return findings;
+}
+
+function looksLikeEnvRef(value: string): boolean {
+  const v = value.trim();
+  return v.startsWith("${") && v.endsWith("}");
+}
+
+export function collectSecretsInConfigFindings(cfg: ClawdbotConfig): SecurityAuditFinding[] {
+  const findings: SecurityAuditFinding[] = [];
+  const password = typeof cfg.gateway?.auth?.password === "string" ? cfg.gateway.auth.password.trim() : "";
+  if (password && !looksLikeEnvRef(password)) {
+    findings.push({
+      checkId: "config.secrets.gateway_password_in_config",
+      severity: "warn",
+      title: "Gateway password is stored in config",
+      detail: "gateway.auth.password is set in the config file; prefer environment variables for secrets when possible.",
+      remediation: "Prefer CLAWDBOT_GATEWAY_PASSWORD (env) and remove gateway.auth.password from disk.",
+    });
+  }
+
+  const browserToken = typeof cfg.browser?.controlToken === "string" ? cfg.browser.controlToken.trim() : "";
+  if (browserToken && !looksLikeEnvRef(browserToken)) {
+    findings.push({
+      checkId: "config.secrets.browser_control_token_in_config",
+      severity: "warn",
+      title: "Browser control token is stored in config",
+      detail: "browser.controlToken is set in the config file; prefer environment variables for secrets when possible.",
+      remediation: "Prefer CLAWDBOT_BROWSER_CONTROL_TOKEN (env) and remove browser.controlToken from disk.",
+    });
+  }
+
+  const hooksToken = typeof cfg.hooks?.token === "string" ? cfg.hooks.token.trim() : "";
+  if (cfg.hooks?.enabled === true && hooksToken && !looksLikeEnvRef(hooksToken)) {
+    findings.push({
+      checkId: "config.secrets.hooks_token_in_config",
+      severity: "info",
+      title: "Hooks token is stored in config",
+      detail: "hooks.token is set in the config file; keep config perms tight and treat it like an API secret.",
+    });
+  }
+
+  return findings;
+}
+
+export function collectHooksHardeningFindings(cfg: ClawdbotConfig): SecurityAuditFinding[] {
+  const findings: SecurityAuditFinding[] = [];
+  if (cfg.hooks?.enabled !== true) return findings;
+
+  const token = typeof cfg.hooks?.token === "string" ? cfg.hooks.token.trim() : "";
+  if (token && token.length < 24) {
+    findings.push({
+      checkId: "hooks.token_too_short",
+      severity: "warn",
+      title: "Hooks token looks short",
+      detail: `hooks.token is ${token.length} chars; prefer a long random token.`,
+    });
+  }
+
+  const gatewayToken =
+    typeof cfg.gateway?.auth?.token === "string" && cfg.gateway.auth.token.trim()
+      ? cfg.gateway.auth.token.trim()
+      : null;
+  if (token && gatewayToken && token === gatewayToken) {
+    findings.push({
+      checkId: "hooks.token_reuse_gateway_token",
+      severity: "warn",
+      title: "Hooks token reuses the Gateway token",
+      detail: "hooks.token matches gateway.auth token; compromise of hooks expands blast radius to the Gateway API.",
+      remediation: "Use a separate hooks.token dedicated to hook ingress.",
+    });
+  }
+
+  const browserToken =
+    typeof cfg.browser?.controlToken === "string" && cfg.browser.controlToken.trim()
+      ? cfg.browser.controlToken.trim()
+      : process.env.CLAWDBOT_BROWSER_CONTROL_TOKEN?.trim() || null;
+  if (token && browserToken && token === browserToken) {
+    findings.push({
+      checkId: "hooks.token_reuse_browser_token",
+      severity: "warn",
+      title: "Hooks token reuses the browser control token",
+      detail: "hooks.token matches browser control token; compromise of hooks may enable browser control endpoints.",
+      remediation: "Use a separate hooks.token dedicated to hook ingress.",
+    });
+  }
+
+  const rawPath = typeof cfg.hooks?.path === "string" ? cfg.hooks.path.trim() : "";
+  if (rawPath === "/") {
+    findings.push({
+      checkId: "hooks.path_root",
+      severity: "critical",
+      title: "Hooks base path is '/'",
+      detail: "hooks.path='/' would shadow other HTTP endpoints and is unsafe.",
+      remediation: "Use a dedicated path like '/hooks'.",
+    });
+  }
+
+  return findings;
+}
+
+type ModelRef = { id: string; source: string };
+
+function addModel(models: ModelRef[], raw: unknown, source: string) {
+  if (typeof raw !== "string") return;
+  const id = raw.trim();
+  if (!id) return;
+  models.push({ id, source });
+}
+
+function collectModels(cfg: ClawdbotConfig): ModelRef[] {
+  const out: ModelRef[] = [];
+  addModel(out, cfg.agents?.defaults?.model?.primary, "agents.defaults.model.primary");
+  for (const f of cfg.agents?.defaults?.model?.fallbacks ?? []) addModel(out, f, "agents.defaults.model.fallbacks");
+  addModel(out, cfg.agents?.defaults?.imageModel?.primary, "agents.defaults.imageModel.primary");
+  for (const f of cfg.agents?.defaults?.imageModel?.fallbacks ?? [])
+    addModel(out, f, "agents.defaults.imageModel.fallbacks");
+
+  const list = Array.isArray(cfg.agents?.list) ? cfg.agents?.list : [];
+  for (const agent of list ?? []) {
+    if (!agent || typeof agent !== "object") continue;
+    const id = typeof (agent as { id?: unknown }).id === "string" ? (agent as { id: string }).id : "";
+    const model = (agent as { model?: unknown }).model;
+    if (typeof model === "string") {
+      addModel(out, model, `agents.list.${id}.model`);
+    } else if (model && typeof model === "object") {
+      addModel(out, (model as { primary?: unknown }).primary, `agents.list.${id}.model.primary`);
+      const fallbacks = (model as { fallbacks?: unknown }).fallbacks;
+      if (Array.isArray(fallbacks)) {
+        for (const f of fallbacks) addModel(out, f, `agents.list.${id}.model.fallbacks`);
+      }
+    }
+  }
+  return out;
+}
+
+const LEGACY_MODEL_PATTERNS: Array<{ id: string; re: RegExp; label: string }> = [
+  { id: "openai.gpt35", re: /\bgpt-3\.5\b/i, label: "GPT-3.5 family" },
+  { id: "anthropic.claude2", re: /\bclaude-(instant|2)\b/i, label: "Claude 2/Instant family" },
+  { id: "openai.gpt4_legacy", re: /\bgpt-4-(0314|0613)\b/i, label: "Legacy GPT-4 snapshots" },
+];
+
+export function collectModelHygieneFindings(cfg: ClawdbotConfig): SecurityAuditFinding[] {
+  const findings: SecurityAuditFinding[] = [];
+  const models = collectModels(cfg);
+  if (models.length === 0) return findings;
+
+  const matches: Array<{ model: string; source: string; reason: string }> = [];
+  for (const entry of models) {
+    for (const pat of LEGACY_MODEL_PATTERNS) {
+      if (pat.re.test(entry.id)) {
+        matches.push({ model: entry.id, source: entry.source, reason: pat.label });
+        break;
+      }
+    }
+  }
+
+  if (matches.length > 0) {
+    const lines = matches
+      .slice(0, 12)
+      .map((m) => `- ${m.model} (${m.reason}) @ ${m.source}`)
+      .join("\n");
+    const more = matches.length > 12 ? `\n…${matches.length - 12} more` : "";
+    findings.push({
+      checkId: "models.legacy",
+      severity: "warn",
+      title: "Some configured models look legacy",
+      detail:
+        "Older/legacy models can be less robust against prompt injection and tool misuse.\n" + lines + more,
+      remediation: "Prefer modern, instruction-hardened models for any bot that can run tools.",
+    });
+  }
+
+  return findings;
+}
+
+export async function collectPluginsTrustFindings(params: {
+  cfg: ClawdbotConfig;
+  stateDir: string;
+}): Promise<SecurityAuditFinding[]> {
+  const findings: SecurityAuditFinding[] = [];
+  const extensionsDir = path.join(params.stateDir, "extensions");
+  const st = await safeStat(extensionsDir);
+  if (!st.ok || !st.isDir) return findings;
+
+  const entries = await fs.readdir(extensionsDir, { withFileTypes: true }).catch(() => []);
+  const pluginDirs = entries.filter((e) => e.isDirectory()).map((e) => e.name).filter(Boolean);
+  if (pluginDirs.length === 0) return findings;
+
+  const allow = params.cfg.plugins?.allow;
+  const allowConfigured = Array.isArray(allow) && allow.length > 0;
+  if (!allowConfigured) {
+    findings.push({
+      checkId: "plugins.extensions_no_allowlist",
+      severity: "warn",
+      title: "Extensions exist but plugins.allow is not set",
+      detail: `Found ${pluginDirs.length} extension(s) under ${extensionsDir}. Without plugins.allow, any discovered plugin id may load (depending on config and plugin behavior).`,
+      remediation: "Set plugins.allow to an explicit list of plugin ids you trust.",
+    });
+  }
+
+  return findings;
+}
+
+function resolveIncludePath(baseConfigPath: string, includePath: string): string {
+  return path.normalize(
+    path.isAbsolute(includePath)
+      ? includePath
+      : path.resolve(path.dirname(baseConfigPath), includePath),
+  );
+}
+
+function listDirectIncludes(parsed: unknown): string[] {
+  const out: string[] = [];
+  const visit = (value: unknown) => {
+    if (!value) return;
+    if (Array.isArray(value)) {
+      for (const item of value) visit(item);
+      return;
+    }
+    if (typeof value !== "object") return;
+    const rec = value as Record<string, unknown>;
+    const includeVal = rec[INCLUDE_KEY];
+    if (typeof includeVal === "string") out.push(includeVal);
+    else if (Array.isArray(includeVal)) {
+      for (const item of includeVal) {
+        if (typeof item === "string") out.push(item);
+      }
+    }
+    for (const v of Object.values(rec)) visit(v);
+  };
+  visit(parsed);
+  return out;
+}
+
+async function collectIncludePathsRecursive(params: {
+  configPath: string;
+  parsed: unknown;
+}): Promise<string[]> {
+  const visited = new Set<string>();
+  const result: string[] = [];
+
+  const walk = async (basePath: string, parsed: unknown, depth: number): Promise<void> => {
+    if (depth > MAX_INCLUDE_DEPTH) return;
+    for (const raw of listDirectIncludes(parsed)) {
+      const resolved = resolveIncludePath(basePath, raw);
+      if (visited.has(resolved)) continue;
+      visited.add(resolved);
+      result.push(resolved);
+      const rawText = await fs.readFile(resolved, "utf-8").catch(() => null);
+      if (!rawText) continue;
+      const nestedParsed = (() => {
+        try {
+          return JSON5.parse(rawText) as unknown;
+        } catch {
+          return null;
+        }
+      })();
+      if (nestedParsed) {
+        // eslint-disable-next-line no-await-in-loop
+        await walk(resolved, nestedParsed, depth + 1);
+      }
+    }
+  };
+
+  await walk(params.configPath, params.parsed, 0);
+  return result;
+}
+
+export async function collectIncludeFilePermFindings(params: {
+  configSnapshot: ConfigFileSnapshot;
+}): Promise<SecurityAuditFinding[]> {
+  const findings: SecurityAuditFinding[] = [];
+  if (!params.configSnapshot.exists) return findings;
+
+  const configPath = params.configSnapshot.path;
+  const includePaths = await collectIncludePathsRecursive({
+    configPath,
+    parsed: params.configSnapshot.parsed,
+  });
+  if (includePaths.length === 0) return findings;
+
+  for (const p of includePaths) {
+    // eslint-disable-next-line no-await-in-loop
+    const st = await safeStat(p);
+    if (!st.ok) continue;
+    const bits = modeBits(st.mode);
+    if (isWorldWritable(bits) || isGroupWritable(bits)) {
+      findings.push({
+        checkId: "fs.config_include.perms_writable",
+        severity: "critical",
+        title: "Config include file is writable by others",
+        detail: `${p} mode=${formatOctal(bits)}; another user could influence your effective config.`,
+        remediation: `chmod 600 ${p}`,
+      });
+    } else if (isWorldReadable(bits)) {
+      findings.push({
+        checkId: "fs.config_include.perms_world_readable",
+        severity: "critical",
+        title: "Config include file is world-readable",
+        detail: `${p} mode=${formatOctal(bits)}; include files can contain tokens and private settings.`,
+        remediation: `chmod 600 ${p}`,
+      });
+    } else if (isGroupReadable(bits)) {
+      findings.push({
+        checkId: "fs.config_include.perms_group_readable",
+        severity: "warn",
+        title: "Config include file is group-readable",
+        detail: `${p} mode=${formatOctal(bits)}; include files can contain tokens and private settings.`,
+        remediation: `chmod 600 ${p}`,
+      });
+    }
+  }
+
+  return findings;
+}
+
+export async function collectStateDeepFilesystemFindings(params: {
+  cfg: ClawdbotConfig;
+  env: NodeJS.ProcessEnv;
+  stateDir: string;
+}): Promise<SecurityAuditFinding[]> {
+  const findings: SecurityAuditFinding[] = [];
+  const oauthDir = resolveOAuthDir(params.env, params.stateDir);
+
+  const oauthStat = await safeStat(oauthDir);
+  if (oauthStat.ok && oauthStat.isDir) {
+    const bits = modeBits(oauthStat.mode);
+    if (isWorldWritable(bits) || isGroupWritable(bits)) {
+      findings.push({
+        checkId: "fs.credentials_dir.perms_writable",
+        severity: "critical",
+        title: "Credentials dir is writable by others",
+        detail: `${oauthDir} mode=${formatOctal(bits)}; another user could drop/modify credential files.`,
+        remediation: `chmod 700 ${oauthDir}`,
+      });
+    } else if (isGroupReadable(bits) || isWorldReadable(bits)) {
+      findings.push({
+        checkId: "fs.credentials_dir.perms_readable",
+        severity: "warn",
+        title: "Credentials dir is readable by others",
+        detail: `${oauthDir} mode=${formatOctal(bits)}; credentials and allowlists can be sensitive.`,
+        remediation: `chmod 700 ${oauthDir}`,
+      });
+    }
+  }
+
+  const agentIds = Array.isArray(params.cfg.agents?.list)
+    ? params.cfg.agents?.list
+        .map((a) => (a && typeof a === "object" && typeof a.id === "string" ? a.id.trim() : ""))
+        .filter(Boolean)
+    : [];
+  const defaultAgentId = resolveDefaultAgentId(params.cfg);
+  const ids = Array.from(new Set([defaultAgentId, ...agentIds])).map((id) => normalizeAgentId(id));
+
+  for (const agentId of ids) {
+    const agentDir = path.join(params.stateDir, "agents", agentId, "agent");
+    const authPath = path.join(agentDir, "auth-profiles.json");
+    // eslint-disable-next-line no-await-in-loop
+    const authStat = await safeStat(authPath);
+    if (authStat.ok) {
+      const bits = modeBits(authStat.mode);
+      if (isWorldWritable(bits) || isGroupWritable(bits)) {
+        findings.push({
+          checkId: "fs.auth_profiles.perms_writable",
+          severity: "critical",
+          title: "auth-profiles.json is writable by others",
+          detail: `${authPath} mode=${formatOctal(bits)}; another user could inject credentials.`,
+          remediation: `chmod 600 ${authPath}`,
+        });
+      } else if (isWorldReadable(bits) || isGroupReadable(bits)) {
+        findings.push({
+          checkId: "fs.auth_profiles.perms_readable",
+          severity: "warn",
+          title: "auth-profiles.json is readable by others",
+          detail: `${authPath} mode=${formatOctal(bits)}; auth-profiles.json contains API keys and OAuth tokens.`,
+          remediation: `chmod 600 ${authPath}`,
+        });
+      }
+    }
+
+    const storePath = path.join(params.stateDir, "agents", agentId, "sessions", "sessions.json");
+    // eslint-disable-next-line no-await-in-loop
+    const storeStat = await safeStat(storePath);
+    if (storeStat.ok) {
+      const bits = modeBits(storeStat.mode);
+      if (isWorldReadable(bits) || isGroupReadable(bits)) {
+        findings.push({
+          checkId: "fs.sessions_store.perms_readable",
+          severity: "warn",
+          title: "sessions.json is readable by others",
+          detail: `${storePath} mode=${formatOctal(bits)}; routing and transcript metadata can be sensitive.`,
+          remediation: `chmod 600 ${storePath}`,
+        });
+      }
+    }
+  }
+
+  const logFile = typeof params.cfg.logging?.file === "string" ? params.cfg.logging.file.trim() : "";
+  if (logFile) {
+    const expanded = logFile.startsWith("~") ? expandTilde(logFile, params.env) : logFile;
+    if (expanded) {
+      const logPath = path.resolve(expanded);
+      const st = await safeStat(logPath);
+      if (st.ok) {
+        const bits = modeBits(st.mode);
+        if (isWorldReadable(bits) || isGroupReadable(bits)) {
+          findings.push({
+            checkId: "fs.log_file.perms_readable",
+            severity: "warn",
+            title: "Log file is readable by others",
+            detail: `${logPath} mode=${formatOctal(bits)}; logs can contain private messages and tool output.`,
+            remediation: `chmod 600 ${logPath}`,
+          });
+        }
+      }
+    }
+  }
+
+  return findings;
+}
+
+function listGroupPolicyOpen(cfg: ClawdbotConfig): string[] {
+  const out: string[] = [];
+  const channels = cfg.channels as Record<string, unknown> | undefined;
+  if (!channels || typeof channels !== "object") return out;
+  for (const [channelId, value] of Object.entries(channels)) {
+    if (!value || typeof value !== "object") continue;
+    const section = value as Record<string, unknown>;
+    if (section.groupPolicy === "open") out.push(`channels.${channelId}.groupPolicy`);
+    const accounts = section.accounts;
+    if (accounts && typeof accounts === "object") {
+      for (const [accountId, accountVal] of Object.entries(accounts)) {
+        if (!accountVal || typeof accountVal !== "object") continue;
+        const acc = accountVal as Record<string, unknown>;
+        if (acc.groupPolicy === "open") out.push(`channels.${channelId}.accounts.${accountId}.groupPolicy`);
+      }
+    }
+  }
+  return out;
+}
+
+export function collectExposureMatrixFindings(cfg: ClawdbotConfig): SecurityAuditFinding[] {
+  const findings: SecurityAuditFinding[] = [];
+  const openGroups = listGroupPolicyOpen(cfg);
+  if (openGroups.length === 0) return findings;
+
+  const elevatedEnabled = cfg.tools?.elevated?.enabled !== false;
+  if (elevatedEnabled) {
+    findings.push({
+      checkId: "security.exposure.open_groups_with_elevated",
+      severity: "critical",
+      title: "Open groupPolicy with elevated tools enabled",
+      detail:
+        `Found groupPolicy="open" at:\n${openGroups.map((p) => `- ${p}`).join("\n")}\n` +
+        "With tools.elevated enabled, a prompt injection in those rooms can become a high-impact incident.",
+      remediation: `Set groupPolicy="allowlist" and keep elevated allowlists extremely tight.`,
+    });
+  }
+
+  return findings;
+}
+
+export async function readConfigSnapshotForAudit(params: {
+  env: NodeJS.ProcessEnv;
+  configPath: string;
+}): Promise<ConfigFileSnapshot> {
+  return await createConfigIO({ env: params.env, configPath: params.configPath }).readConfigFileSnapshot();
+}
diff --git a/src/security/audit-fs.ts b/src/security/audit-fs.ts
new file mode 100644
index 000000000..47e19b476
--- /dev/null
+++ b/src/security/audit-fs.ts
@@ -0,0 +1,64 @@
+import fs from "node:fs/promises";
+
+export async function safeStat(targetPath: string): Promise<{
+  ok: boolean;
+  isSymlink: boolean;
+  isDir: boolean;
+  mode: number | null;
+  uid: number | null;
+  gid: number | null;
+  error?: string;
+}> {
+  try {
+    const lst = await fs.lstat(targetPath);
+    return {
+      ok: true,
+      isSymlink: lst.isSymbolicLink(),
+      isDir: lst.isDirectory(),
+      mode: typeof lst.mode === "number" ? lst.mode : null,
+      uid: typeof lst.uid === "number" ? lst.uid : null,
+      gid: typeof lst.gid === "number" ? lst.gid : null,
+    };
+  } catch (err) {
+    return {
+      ok: false,
+      isSymlink: false,
+      isDir: false,
+      mode: null,
+      uid: null,
+      gid: null,
+      error: String(err),
+    };
+  }
+}
+
+export function modeBits(mode: number | null): number | null {
+  if (mode == null) return null;
+  return mode & 0o777;
+}
+
+export function formatOctal(bits: number | null): string {
+  if (bits == null) return "unknown";
+  return bits.toString(8).padStart(3, "0");
+}
+
+export function isWorldWritable(bits: number | null): boolean {
+  if (bits == null) return false;
+  return (bits & 0o002) !== 0;
+}
+
+export function isGroupWritable(bits: number | null): boolean {
+  if (bits == null) return false;
+  return (bits & 0o020) !== 0;
+}
+
+export function isWorldReadable(bits: number | null): boolean {
+  if (bits == null) return false;
+  return (bits & 0o004) !== 0;
+}
+
+export function isGroupReadable(bits: number | null): boolean {
+  if (bits == null) return false;
+  return (bits & 0o040) !== 0;
+}
+
diff --git a/src/security/audit.test.ts b/src/security/audit.test.ts
new file mode 100644
index 000000000..c46c41648
--- /dev/null
+++ b/src/security/audit.test.ts
@@ -0,0 +1,322 @@
+import { describe, expect, it } from "vitest";
+
+import type { ClawdbotConfig } from "../config/config.js";
+import { runSecurityAudit } from "./audit.js";
+import fs from "node:fs/promises";
+import os from "node:os";
+import path from "node:path";
+
+describe("security audit", () => {
+  it("includes an attack surface summary (info)", async () => {
+    const cfg: ClawdbotConfig = {
+      channels: { whatsapp: { groupPolicy: "open" }, telegram: { groupPolicy: "allowlist" } },
+      tools: { elevated: { enabled: true, allowFrom: { whatsapp: ["+1"] } } },
+      hooks: { enabled: true },
+      browser: { enabled: true },
+    };
+
+    const res = await runSecurityAudit({
+      config: cfg,
+      includeFilesystem: false,
+      includeChannelSecurity: false,
+    });
+
+    expect(res.findings).toEqual(
+      expect.arrayContaining([
+        expect.objectContaining({ checkId: "summary.attack_surface", severity: "info" }),
+      ]),
+    );
+  });
+
+  it("flags non-loopback bind without auth as critical", async () => {
+    const cfg: ClawdbotConfig = {
+      gateway: {
+        bind: "lan",
+        auth: {},
+      },
+    };
+
+    const res = await runSecurityAudit({
+      config: cfg,
+      includeFilesystem: false,
+      includeChannelSecurity: false,
+    });
+
+    expect(
+      res.findings.some((f) => f.checkId === "gateway.bind_no_auth" && f.severity === "critical"),
+    ).toBe(true);
+  });
+
+  it("flags logging.redactSensitive=off", async () => {
+    const cfg: ClawdbotConfig = {
+      logging: { redactSensitive: "off" },
+    };
+
+    const res = await runSecurityAudit({
+      config: cfg,
+      includeFilesystem: false,
+      includeChannelSecurity: false,
+    });
+
+    expect(res.findings).toEqual(
+      expect.arrayContaining([
+        expect.objectContaining({ checkId: "logging.redact_off", severity: "warn" }),
+      ]),
+    );
+  });
+
+  it("flags tools.elevated allowFrom wildcard as critical", async () => {
+    const cfg: ClawdbotConfig = {
+      tools: {
+        elevated: {
+          allowFrom: { whatsapp: ["*"] },
+        },
+      },
+    };
+
+    const res = await runSecurityAudit({
+      config: cfg,
+      includeFilesystem: false,
+      includeChannelSecurity: false,
+    });
+
+    expect(res.findings).toEqual(
+      expect.arrayContaining([
+        expect.objectContaining({
+          checkId: "tools.elevated.allowFrom.whatsapp.wildcard",
+          severity: "critical",
+        }),
+      ]),
+    );
+  });
+
+  it("flags remote browser control without token as critical", async () => {
+    const prev = process.env.CLAWDBOT_BROWSER_CONTROL_TOKEN;
+    delete process.env.CLAWDBOT_BROWSER_CONTROL_TOKEN;
+    try {
+      const cfg: ClawdbotConfig = {
+        browser: {
+          controlUrl: "http://example.com:18791",
+        },
+      };
+
+      const res = await runSecurityAudit({
+        config: cfg,
+        includeFilesystem: false,
+        includeChannelSecurity: false,
+      });
+
+      expect(res.findings).toEqual(
+        expect.arrayContaining([
+          expect.objectContaining({
+            checkId: "browser.control_remote_no_token",
+            severity: "critical",
+          }),
+        ]),
+      );
+    } finally {
+      if (prev === undefined) delete process.env.CLAWDBOT_BROWSER_CONTROL_TOKEN;
+      else process.env.CLAWDBOT_BROWSER_CONTROL_TOKEN = prev;
+    }
+  });
+
+  it("warns when browser control token matches gateway auth token", async () => {
+    const token = "0123456789abcdef0123456789abcdef";
+    const cfg: ClawdbotConfig = {
+      gateway: { auth: { token } },
+      browser: { controlUrl: "https://browser.example.com", controlToken: token },
+    };
+
+    const res = await runSecurityAudit({
+      config: cfg,
+      includeFilesystem: false,
+      includeChannelSecurity: false,
+    });
+
+    expect(res.findings).toEqual(
+      expect.arrayContaining([
+        expect.objectContaining({
+          checkId: "browser.control_token_reuse_gateway_token",
+          severity: "warn",
+        }),
+      ]),
+    );
+  });
+
+  it("warns when remote browser control uses HTTP", async () => {
+    const prev = process.env.CLAWDBOT_BROWSER_CONTROL_TOKEN;
+    delete process.env.CLAWDBOT_BROWSER_CONTROL_TOKEN;
+    try {
+      const cfg: ClawdbotConfig = {
+        browser: {
+          controlUrl: "http://example.com:18791",
+          controlToken: "0123456789abcdef01234567",
+        },
+      };
+
+      const res = await runSecurityAudit({
+        config: cfg,
+        includeFilesystem: false,
+        includeChannelSecurity: false,
+      });
+
+      expect(res.findings).toEqual(
+        expect.arrayContaining([
+          expect.objectContaining({ checkId: "browser.control_remote_http", severity: "warn" }),
+        ]),
+      );
+    } finally {
+      if (prev === undefined) delete process.env.CLAWDBOT_BROWSER_CONTROL_TOKEN;
+      else process.env.CLAWDBOT_BROWSER_CONTROL_TOKEN = prev;
+    }
+  });
+
+  it("adds a warning when deep probe fails", async () => {
+    const cfg: ClawdbotConfig = { gateway: { mode: "local" } };
+
+    const res = await runSecurityAudit({
+      config: cfg,
+      deep: true,
+      deepTimeoutMs: 50,
+      includeFilesystem: false,
+      includeChannelSecurity: false,
+      probeGatewayFn: async () => ({
+        ok: false,
+        url: "ws://127.0.0.1:18789",
+        connectLatencyMs: null,
+        error: "connect failed",
+        close: null,
+        health: null,
+        status: null,
+        presence: null,
+        configSnapshot: null,
+      }),
+    });
+
+    expect(res.findings).toEqual(
+      expect.arrayContaining([
+        expect.objectContaining({ checkId: "gateway.probe_failed", severity: "warn" }),
+      ]),
+    );
+  });
+
+  it("warns on legacy model configuration", async () => {
+    const cfg: ClawdbotConfig = {
+      agents: { defaults: { model: { primary: "openai/gpt-3.5-turbo" } } },
+    };
+
+    const res = await runSecurityAudit({
+      config: cfg,
+      includeFilesystem: false,
+      includeChannelSecurity: false,
+    });
+
+    expect(res.findings).toEqual(
+      expect.arrayContaining([expect.objectContaining({ checkId: "models.legacy", severity: "warn" })]),
+    );
+  });
+
+  it("warns when hooks token looks short", async () => {
+    const cfg: ClawdbotConfig = {
+      hooks: { enabled: true, token: "short" },
+    };
+
+    const res = await runSecurityAudit({
+      config: cfg,
+      includeFilesystem: false,
+      includeChannelSecurity: false,
+    });
+
+    expect(res.findings).toEqual(
+      expect.arrayContaining([expect.objectContaining({ checkId: "hooks.token_too_short", severity: "warn" })]),
+    );
+  });
+
+  it("warns when state/config look like a synced folder", async () => {
+    const cfg: ClawdbotConfig = {};
+
+    const res = await runSecurityAudit({
+      config: cfg,
+      includeFilesystem: false,
+      includeChannelSecurity: false,
+      stateDir: "/Users/test/Dropbox/.clawdbot",
+      configPath: "/Users/test/Dropbox/.clawdbot/clawdbot.json",
+    });
+
+    expect(res.findings).toEqual(
+      expect.arrayContaining([expect.objectContaining({ checkId: "fs.synced_dir", severity: "warn" })]),
+    );
+  });
+
+  it("flags group/world-readable config include files", async () => {
+    const tmp = await fs.mkdtemp(path.join(os.tmpdir(), "clawdbot-security-audit-"));
+    const stateDir = path.join(tmp, "state");
+    await fs.mkdir(stateDir, { recursive: true, mode: 0o700 });
+
+    const includePath = path.join(stateDir, "extra.json5");
+    await fs.writeFile(includePath, "{ logging: { redactSensitive: 'off' } }\n", "utf-8");
+    await fs.chmod(includePath, 0o644);
+
+    const configPath = path.join(stateDir, "clawdbot.json");
+    await fs.writeFile(configPath, `{ "$include": "./extra.json5" }\n`, "utf-8");
+    await fs.chmod(configPath, 0o600);
+
+    const cfg: ClawdbotConfig = { logging: { redactSensitive: "off" } };
+    const res = await runSecurityAudit({
+      config: cfg,
+      includeFilesystem: true,
+      includeChannelSecurity: false,
+      stateDir,
+      configPath,
+    });
+
+    expect(res.findings).toEqual(
+      expect.arrayContaining([
+        expect.objectContaining({ checkId: "fs.config_include.perms_world_readable", severity: "critical" }),
+      ]),
+    );
+  });
+
+  it("flags extensions without plugins.allow", async () => {
+    const tmp = await fs.mkdtemp(path.join(os.tmpdir(), "clawdbot-security-audit-"));
+    const stateDir = path.join(tmp, "state");
+    await fs.mkdir(path.join(stateDir, "extensions", "some-plugin"), { recursive: true, mode: 0o700 });
+
+    const cfg: ClawdbotConfig = {};
+    const res = await runSecurityAudit({
+      config: cfg,
+      includeFilesystem: true,
+      includeChannelSecurity: false,
+      stateDir,
+      configPath: path.join(stateDir, "clawdbot.json"),
+    });
+
+    expect(res.findings).toEqual(
+      expect.arrayContaining([
+        expect.objectContaining({ checkId: "plugins.extensions_no_allowlist", severity: "warn" }),
+      ]),
+    );
+  });
+
+  it("flags open groupPolicy when tools.elevated is enabled", async () => {
+    const cfg: ClawdbotConfig = {
+      tools: { elevated: { enabled: true, allowFrom: { whatsapp: ["+1"] } } },
+      channels: { whatsapp: { groupPolicy: "open" } },
+    };
+
+    const res = await runSecurityAudit({
+      config: cfg,
+      includeFilesystem: false,
+      includeChannelSecurity: false,
+    });
+
+    expect(res.findings).toEqual(
+      expect.arrayContaining([
+        expect.objectContaining({
+          checkId: "security.exposure.open_groups_with_elevated",
+          severity: "critical",
+        }),
+      ]),
+    );
+  });
+});
diff --git a/src/security/audit.ts b/src/security/audit.ts
new file mode 100644
index 000000000..9c5397fa8
--- /dev/null
+++ b/src/security/audit.ts
@@ -0,0 +1,596 @@
+import { listChannelPlugins } from "../channels/plugins/index.js";
+import { resolveChannelDefaultAccountId } from "../channels/plugins/helpers.js";
+import type { ChannelId } from "../channels/plugins/types.js";
+import type { ClawdbotConfig } from "../config/config.js";
+import { resolveBrowserConfig } from "../browser/config.js";
+import { resolveConfigPath, resolveStateDir } from "../config/paths.js";
+import { resolveGatewayAuth } from "../gateway/auth.js";
+import { buildGatewayConnectionDetails } from "../gateway/call.js";
+import { probeGateway } from "../gateway/probe.js";
+import {
+  collectAttackSurfaceSummaryFindings,
+  collectExposureMatrixFindings,
+  collectHooksHardeningFindings,
+  collectIncludeFilePermFindings,
+  collectModelHygieneFindings,
+  collectPluginsTrustFindings,
+  collectSecretsInConfigFindings,
+  collectStateDeepFilesystemFindings,
+  collectSyncedFolderFindings,
+  readConfigSnapshotForAudit,
+} from "./audit-extra.js";
+import {
+  formatOctal,
+  isGroupReadable,
+  isGroupWritable,
+  isWorldReadable,
+  isWorldWritable,
+  modeBits,
+  safeStat,
+} from "./audit-fs.js";
+
+export type SecurityAuditSeverity = "info" | "warn" | "critical";
+
+export type SecurityAuditFinding = {
+  checkId: string;
+  severity: SecurityAuditSeverity;
+  title: string;
+  detail: string;
+  remediation?: string;
+};
+
+export type SecurityAuditSummary = {
+  critical: number;
+  warn: number;
+  info: number;
+};
+
+export type SecurityAuditReport = {
+  ts: number;
+  summary: SecurityAuditSummary;
+  findings: SecurityAuditFinding[];
+  deep?: {
+    gateway?: {
+      attempted: boolean;
+      url: string | null;
+      ok: boolean;
+      error: string | null;
+      close?: { code: number; reason: string } | null;
+    };
+  };
+};
+
+export type SecurityAuditOptions = {
+  config: ClawdbotConfig;
+  deep?: boolean;
+  includeFilesystem?: boolean;
+  includeChannelSecurity?: boolean;
+  /** Override where to check state (default: resolveStateDir()). */
+  stateDir?: string;
+  /** Override config path check (default: resolveConfigPath()). */
+  configPath?: string;
+  /** Time limit for deep gateway probe. */
+  deepTimeoutMs?: number;
+  /** Dependency injection for tests. */
+  plugins?: ReturnType<typeof listChannelPlugins>;
+  /** Dependency injection for tests. */
+  probeGatewayFn?: typeof probeGateway;
+};
+
+function countBySeverity(findings: SecurityAuditFinding[]): SecurityAuditSummary {
+  let critical = 0;
+  let warn = 0;
+  let info = 0;
+  for (const f of findings) {
+    if (f.severity === "critical") critical += 1;
+    else if (f.severity === "warn") warn += 1;
+    else info += 1;
+  }
+  return { critical, warn, info };
+}
+
+function normalizeAllowFromList(list: Array<string | number> | undefined | null): string[] {
+  if (!Array.isArray(list)) return [];
+  return list.map((v) => String(v).trim()).filter(Boolean);
+}
+
+function classifyChannelWarningSeverity(message: string): SecurityAuditSeverity {
+  const s = message.toLowerCase();
+  if (
+    s.includes("dms: open") ||
+    s.includes('grouppolicy="open"') ||
+    s.includes('dmpolicy="open"')
+  ) {
+    return "critical";
+  }
+  if (s.includes("allows any") || s.includes("anyone can dm") || s.includes("public")) {
+    return "critical";
+  }
+  if (s.includes("locked") || s.includes("disabled")) {
+    return "info";
+  }
+  return "warn";
+}
+
+async function collectFilesystemFindings(params: {
+  stateDir: string;
+  configPath: string;
+}): Promise<SecurityAuditFinding[]> {
+  const findings: SecurityAuditFinding[] = [];
+
+  const stateDirStat = await safeStat(params.stateDir);
+  if (stateDirStat.ok) {
+    const bits = modeBits(stateDirStat.mode);
+    if (stateDirStat.isSymlink) {
+      findings.push({
+        checkId: "fs.state_dir.symlink",
+        severity: "warn",
+        title: "State dir is a symlink",
+        detail: `${params.stateDir} is a symlink; treat this as an extra trust boundary.`,
+      });
+    }
+    if (isWorldWritable(bits)) {
+      findings.push({
+        checkId: "fs.state_dir.perms_world_writable",
+        severity: "critical",
+        title: "State dir is world-writable",
+        detail: `${params.stateDir} mode=${formatOctal(bits)}; other users can write into your Clawdbot state.`,
+        remediation: `chmod 700 ${params.stateDir}`,
+      });
+    } else if (isGroupWritable(bits)) {
+      findings.push({
+        checkId: "fs.state_dir.perms_group_writable",
+        severity: "warn",
+        title: "State dir is group-writable",
+        detail: `${params.stateDir} mode=${formatOctal(bits)}; group users can write into your Clawdbot state.`,
+        remediation: `chmod 700 ${params.stateDir}`,
+      });
+    } else if (isGroupReadable(bits) || isWorldReadable(bits)) {
+      findings.push({
+        checkId: "fs.state_dir.perms_readable",
+        severity: "warn",
+        title: "State dir is readable by others",
+        detail: `${params.stateDir} mode=${formatOctal(bits)}; consider restricting to 700.`,
+        remediation: `chmod 700 ${params.stateDir}`,
+      });
+    }
+  }
+
+  const configStat = await safeStat(params.configPath);
+  if (configStat.ok) {
+    const bits = modeBits(configStat.mode);
+    if (configStat.isSymlink) {
+      findings.push({
+        checkId: "fs.config.symlink",
+        severity: "warn",
+        title: "Config file is a symlink",
+        detail: `${params.configPath} is a symlink; make sure you trust its target.`,
+      });
+    }
+    if (isWorldWritable(bits) || isGroupWritable(bits)) {
+      findings.push({
+        checkId: "fs.config.perms_writable",
+        severity: "critical",
+        title: "Config file is writable by others",
+        detail: `${params.configPath} mode=${formatOctal(bits)}; another user could change gateway/auth/tool policies.`,
+        remediation: `chmod 600 ${params.configPath}`,
+      });
+    } else if (isWorldReadable(bits)) {
+      findings.push({
+        checkId: "fs.config.perms_world_readable",
+        severity: "critical",
+        title: "Config file is world-readable",
+        detail: `${params.configPath} mode=${formatOctal(bits)}; config can contain tokens and private settings.`,
+        remediation: `chmod 600 ${params.configPath}`,
+      });
+    } else if (isGroupReadable(bits)) {
+      findings.push({
+        checkId: "fs.config.perms_group_readable",
+        severity: "warn",
+        title: "Config file is group-readable",
+        detail: `${params.configPath} mode=${formatOctal(bits)}; config can contain tokens and private settings.`,
+        remediation: `chmod 600 ${params.configPath}`,
+      });
+    }
+  }
+
+  return findings;
+}
+
+function collectGatewayConfigFindings(cfg: ClawdbotConfig): SecurityAuditFinding[] {
+  const findings: SecurityAuditFinding[] = [];
+
+  const bind = typeof cfg.gateway?.bind === "string" ? cfg.gateway.bind : "loopback";
+  const tailscaleMode = cfg.gateway?.tailscale?.mode ?? "off";
+  const auth = resolveGatewayAuth({ authConfig: cfg.gateway?.auth, tailscaleMode });
+
+  if (bind !== "loopback" && auth.mode === "none") {
+    findings.push({
+      checkId: "gateway.bind_no_auth",
+      severity: "critical",
+      title: "Gateway binds beyond loopback without auth",
+      detail: `gateway.bind="${bind}" but no gateway.auth token/password is configured.`,
+      remediation: `Set gateway.auth (token recommended) or bind to loopback.`,
+    });
+  }
+
+  if (tailscaleMode === "funnel") {
+    findings.push({
+      checkId: "gateway.tailscale_funnel",
+      severity: "critical",
+      title: "Tailscale Funnel exposure enabled",
+      detail: `gateway.tailscale.mode="funnel" exposes the Gateway publicly; keep auth strict and treat it as internet-facing.`,
+      remediation: `Prefer tailscale.mode="serve" (tailnet-only) or set tailscale.mode="off".`,
+    });
+  } else if (tailscaleMode === "serve") {
+    findings.push({
+      checkId: "gateway.tailscale_serve",
+      severity: "info",
+      title: "Tailscale Serve exposure enabled",
+      detail: `gateway.tailscale.mode="serve" exposes the Gateway to your tailnet (loopback behind Tailscale).`,
+    });
+  }
+
+  const token =
+    typeof auth.token === "string" && auth.token.trim().length > 0 ? auth.token.trim() : null;
+  if (auth.mode === "token" && token && token.length < 24) {
+    findings.push({
+      checkId: "gateway.token_too_short",
+      severity: "warn",
+      title: "Gateway token looks short",
+      detail: `gateway auth token is ${token.length} chars; prefer a long random token.`,
+    });
+  }
+
+  return findings;
+}
+
+function isLoopbackClientHost(hostname: string): boolean {
+  const h = hostname.trim().toLowerCase();
+  return h === "localhost" || h === "127.0.0.1" || h === "::1";
+}
+
+function collectBrowserControlFindings(cfg: ClawdbotConfig): SecurityAuditFinding[] {
+  const findings: SecurityAuditFinding[] = [];
+
+  let resolved: ReturnType<typeof resolveBrowserConfig>;
+  try {
+    resolved = resolveBrowserConfig(cfg.browser);
+  } catch (err) {
+    findings.push({
+      checkId: "browser.control_invalid_config",
+      severity: "warn",
+      title: "Browser control config looks invalid",
+      detail: String(err),
+      remediation: `Fix browser.controlUrl/browser.cdpUrl in ${resolveConfigPath()} and re-run "clawdbot security audit --deep".`,
+    });
+    return findings;
+  }
+
+  if (!resolved.enabled) return findings;
+
+  const url = new URL(resolved.controlUrl);
+  const isLoopback = isLoopbackClientHost(url.hostname);
+  const envToken = process.env.CLAWDBOT_BROWSER_CONTROL_TOKEN?.trim();
+  const controlToken = (envToken || resolved.controlToken)?.trim() || null;
+
+  if (!isLoopback) {
+    if (!controlToken) {
+      findings.push({
+        checkId: "browser.control_remote_no_token",
+        severity: "critical",
+        title: "Remote browser control is missing an auth token",
+        detail: `browser.controlUrl is non-loopback (${resolved.controlUrl}) but no browser.controlToken (or CLAWDBOT_BROWSER_CONTROL_TOKEN) is configured.`,
+        remediation:
+          "Set browser.controlToken (or export CLAWDBOT_BROWSER_CONTROL_TOKEN) and prefer serving over Tailscale Serve or HTTPS reverse proxy.",
+      });
+    }
+
+    if (url.protocol === "http:") {
+      findings.push({
+        checkId: "browser.control_remote_http",
+        severity: "warn",
+        title: "Remote browser control uses HTTP",
+        detail: `browser.controlUrl=${resolved.controlUrl} is http; this is OK only if it's tailnet-only (Tailscale) or behind another encrypted tunnel.`,
+        remediation: `Prefer HTTPS termination (Tailscale Serve) and keep the endpoint tailnet-only.`,
+      });
+    }
+
+    if (controlToken && controlToken.length < 24) {
+      findings.push({
+        checkId: "browser.control_token_too_short",
+        severity: "warn",
+        title: "Browser control token looks short",
+        detail: `browser control token is ${controlToken.length} chars; prefer a long random token.`,
+      });
+    }
+
+    const tailscaleMode = cfg.gateway?.tailscale?.mode ?? "off";
+    const gatewayAuth = resolveGatewayAuth({ authConfig: cfg.gateway?.auth, tailscaleMode });
+    const gatewayToken =
+      gatewayAuth.mode === "token" &&
+      typeof gatewayAuth.token === "string" &&
+      gatewayAuth.token.trim()
+        ? gatewayAuth.token.trim()
+        : null;
+
+    if (controlToken && gatewayToken && controlToken === gatewayToken) {
+      findings.push({
+        checkId: "browser.control_token_reuse_gateway_token",
+        severity: "warn",
+        title: "Browser control token reuses the Gateway token",
+        detail: `browser.controlToken matches gateway.auth token; compromise of browser control expands blast radius to the Gateway API.`,
+        remediation: `Use a separate browser.controlToken dedicated to browser control.`,
+      });
+    }
+  }
+
+  return findings;
+}
+
+function collectLoggingFindings(cfg: ClawdbotConfig): SecurityAuditFinding[] {
+  const redact = cfg.logging?.redactSensitive;
+  if (redact !== "off") return [];
+  return [
+    {
+      checkId: "logging.redact_off",
+      severity: "warn",
+      title: "Tool summary redaction is disabled",
+      detail: `logging.redactSensitive="off" can leak secrets into logs and status output.`,
+      remediation: `Set logging.redactSensitive="tools".`,
+    },
+  ];
+}
+
+function collectElevatedFindings(cfg: ClawdbotConfig): SecurityAuditFinding[] {
+  const findings: SecurityAuditFinding[] = [];
+  const enabled = cfg.tools?.elevated?.enabled;
+  const allowFrom = cfg.tools?.elevated?.allowFrom ?? {};
+  const anyAllowFromKeys = Object.keys(allowFrom).length > 0;
+
+  if (enabled === false) return findings;
+  if (!anyAllowFromKeys) return findings;
+
+  for (const [provider, list] of Object.entries(allowFrom)) {
+    const normalized = normalizeAllowFromList(list);
+    if (normalized.includes("*")) {
+      findings.push({
+        checkId: `tools.elevated.allowFrom.${provider}.wildcard`,
+        severity: "critical",
+        title: "Elevated exec allowlist contains wildcard",
+        detail: `tools.elevated.allowFrom.${provider} includes "*" which effectively approves everyone on that channel for elevated mode.`,
+      });
+    } else if (normalized.length > 25) {
+      findings.push({
+        checkId: `tools.elevated.allowFrom.${provider}.large`,
+        severity: "warn",
+        title: "Elevated exec allowlist is large",
+        detail: `tools.elevated.allowFrom.${provider} has ${normalized.length} entries; consider tightening elevated access.`,
+      });
+    }
+  }
+
+  return findings;
+}
+
+async function collectChannelSecurityFindings(params: {
+  cfg: ClawdbotConfig;
+  plugins: ReturnType<typeof listChannelPlugins>;
+}): Promise<SecurityAuditFinding[]> {
+  const findings: SecurityAuditFinding[] = [];
+
+  const warnDmPolicy = async (input: {
+    label: string;
+    provider: ChannelId;
+    dmPolicy: string;
+    allowFrom?: Array<string | number> | null;
+    policyPath?: string;
+    allowFromPath: string;
+  }) => {
+    const policyPath = input.policyPath ?? `${input.allowFromPath}policy`;
+    const configAllowFrom = normalizeAllowFromList(input.allowFrom);
+    const hasWildcard = configAllowFrom.includes("*");
+
+    if (input.dmPolicy === "open") {
+      const allowFromKey = `${input.allowFromPath}allowFrom`;
+      findings.push({
+        checkId: `channels.${input.provider}.dm.open`,
+        severity: "critical",
+        title: `${input.label} DMs are open`,
+        detail: `${policyPath}="open" allows anyone to DM the bot.`,
+        remediation: `Use pairing/allowlist; if you really need open DMs, ensure ${allowFromKey} includes "*".`,
+      });
+      if (!hasWildcard) {
+        findings.push({
+          checkId: `channels.${input.provider}.dm.open_invalid`,
+          severity: "warn",
+          title: `${input.label} DM config looks inconsistent`,
+          detail: `"open" requires ${allowFromKey} to include "*".`,
+        });
+      }
+      return;
+    }
+
+    if (input.dmPolicy === "disabled") {
+      findings.push({
+        checkId: `channels.${input.provider}.dm.disabled`,
+        severity: "info",
+        title: `${input.label} DMs are disabled`,
+        detail: `${policyPath}="disabled" ignores inbound DMs.`,
+      });
+    }
+  };
+
+  for (const plugin of params.plugins) {
+    if (!plugin.security) continue;
+    const accountIds = plugin.config.listAccountIds(params.cfg);
+    const defaultAccountId = resolveChannelDefaultAccountId({
+      plugin,
+      cfg: params.cfg,
+      accountIds,
+    });
+    const account = plugin.config.resolveAccount(params.cfg, defaultAccountId);
+    const enabled = plugin.config.isEnabled ? plugin.config.isEnabled(account, params.cfg) : true;
+    if (!enabled) continue;
+    const configured = plugin.config.isConfigured
+      ? await plugin.config.isConfigured(account, params.cfg)
+      : true;
+    if (!configured) continue;
+
+    const dmPolicy = plugin.security.resolveDmPolicy?.({
+      cfg: params.cfg,
+      accountId: defaultAccountId,
+      account,
+    });
+    if (dmPolicy) {
+      await warnDmPolicy({
+        label: plugin.meta.label ?? plugin.id,
+        provider: plugin.id,
+        dmPolicy: dmPolicy.policy,
+        allowFrom: dmPolicy.allowFrom,
+        policyPath: dmPolicy.policyPath,
+        allowFromPath: dmPolicy.allowFromPath,
+      });
+    }
+
+    if (plugin.security.collectWarnings) {
+      const warnings = await plugin.security.collectWarnings({
+        cfg: params.cfg,
+        accountId: defaultAccountId,
+        account,
+      });
+      for (const message of warnings ?? []) {
+        const trimmed = String(message).trim();
+        if (!trimmed) continue;
+        findings.push({
+          checkId: `channels.${plugin.id}.warning.${findings.length + 1}`,
+          severity: classifyChannelWarningSeverity(trimmed),
+          title: `${plugin.meta.label ?? plugin.id} security warning`,
+          detail: trimmed.replace(/^-\s*/, ""),
+        });
+      }
+    }
+  }
+
+  return findings;
+}
+
+async function maybeProbeGateway(params: {
+  cfg: ClawdbotConfig;
+  timeoutMs: number;
+  probe: typeof probeGateway;
+}): Promise<SecurityAuditReport["deep"]> {
+  const connection = buildGatewayConnectionDetails({ config: params.cfg });
+  const url = connection.url;
+  const isRemoteMode = params.cfg.gateway?.mode === "remote";
+  const remoteUrlRaw =
+    typeof params.cfg.gateway?.remote?.url === "string" ? params.cfg.gateway.remote.url.trim() : "";
+  const remoteUrlMissing = isRemoteMode && !remoteUrlRaw;
+
+  const resolveAuth = (mode: "local" | "remote") => {
+    const authToken = params.cfg.gateway?.auth?.token;
+    const authPassword = params.cfg.gateway?.auth?.password;
+    const remote = params.cfg.gateway?.remote;
+    const token =
+      mode === "remote"
+        ? typeof remote?.token === "string" && remote.token.trim()
+          ? remote.token.trim()
+          : undefined
+        : process.env.CLAWDBOT_GATEWAY_TOKEN?.trim() ||
+          (typeof authToken === "string" && authToken.trim() ? authToken.trim() : undefined);
+    const password =
+      process.env.CLAWDBOT_GATEWAY_PASSWORD?.trim() ||
+      (mode === "remote"
+        ? typeof remote?.password === "string" && remote.password.trim()
+          ? remote.password.trim()
+          : undefined
+        : typeof authPassword === "string" && authPassword.trim()
+          ? authPassword.trim()
+          : undefined);
+    return { token, password };
+  };
+
+  const auth = remoteUrlMissing ? resolveAuth("local") : resolveAuth("remote");
+  const res = await params.probe({ url, auth, timeoutMs: params.timeoutMs }).catch((err) => ({
+    ok: false,
+    url,
+    connectLatencyMs: null,
+    error: String(err),
+    close: null,
+    health: null,
+    status: null,
+    presence: null,
+    configSnapshot: null,
+  }));
+
+  return {
+    gateway: {
+      attempted: true,
+      url,
+      ok: res.ok,
+      error: res.ok ? null : res.error,
+      close: res.close ? { code: res.close.code, reason: res.close.reason } : null,
+    },
+  };
+}
+
+export async function runSecurityAudit(opts: SecurityAuditOptions): Promise<SecurityAuditReport> {
+  const findings: SecurityAuditFinding[] = [];
+  const cfg = opts.config;
+  const env = process.env;
+  const stateDir = opts.stateDir ?? resolveStateDir(env);
+  const configPath = opts.configPath ?? resolveConfigPath(env, stateDir);
+
+  findings.push(...collectAttackSurfaceSummaryFindings(cfg));
+  findings.push(...collectSyncedFolderFindings({ stateDir, configPath }));
+
+  findings.push(...collectGatewayConfigFindings(cfg));
+  findings.push(...collectBrowserControlFindings(cfg));
+  findings.push(...collectLoggingFindings(cfg));
+  findings.push(...collectElevatedFindings(cfg));
+  findings.push(...collectHooksHardeningFindings(cfg));
+  findings.push(...collectSecretsInConfigFindings(cfg));
+  findings.push(...collectModelHygieneFindings(cfg));
+  findings.push(...collectExposureMatrixFindings(cfg));
+
+  const configSnapshot =
+    opts.includeFilesystem !== false
+      ? await readConfigSnapshotForAudit({ env, configPath }).catch(() => null)
+      : null;
+
+  if (opts.includeFilesystem !== false) {
+    findings.push(...(await collectFilesystemFindings({ stateDir, configPath })));
+    if (configSnapshot) {
+      findings.push(...(await collectIncludeFilePermFindings({ configSnapshot })));
+    }
+    findings.push(...(await collectStateDeepFilesystemFindings({ cfg, env, stateDir })));
+    findings.push(...(await collectPluginsTrustFindings({ cfg, stateDir })));
+  }
+
+  if (opts.includeChannelSecurity !== false) {
+    const plugins = opts.plugins ?? listChannelPlugins();
+    findings.push(...(await collectChannelSecurityFindings({ cfg, plugins })));
+  }
+
+  const deep =
+    opts.deep === true
+      ? await maybeProbeGateway({
+          cfg,
+          timeoutMs: Math.max(250, opts.deepTimeoutMs ?? 5000),
+          probe: opts.probeGatewayFn ?? probeGateway,
+        })
+      : undefined;
+
+  if (deep?.gateway?.attempted && deep.gateway.ok === false) {
+    findings.push({
+      checkId: "gateway.probe_failed",
+      severity: "warn",
+      title: "Gateway probe failed (deep)",
+      detail: deep.gateway.error ?? "gateway unreachable",
+      remediation: `Run "clawdbot status --all" to debug connectivity/auth, then re-run "clawdbot security audit --deep".`,
+    });
+  }
+
+  const summary = countBySeverity(findings);
+  return { ts: Date.now(), summary, findings, deep };
+}
diff --git a/src/security/fix.test.ts b/src/security/fix.test.ts
new file mode 100644
index 000000000..f423079be
--- /dev/null
+++ b/src/security/fix.test.ts
@@ -0,0 +1,267 @@
+import fs from "node:fs/promises";
+import os from "node:os";
+import path from "node:path";
+
+import { describe, expect, it } from "vitest";
+
+import { fixSecurityFootguns } from "./fix.js";
+
+const isWindows = process.platform === "win32";
+
+const expectPerms = (actual: number, expected: number) => {
+  if (isWindows) {
+    expect([expected, 0o666, 0o777]).toContain(actual);
+    return;
+  }
+  expect(actual).toBe(expected);
+};
+
+describe("security fix", () => {
+  it("tightens groupPolicy + filesystem perms", async () => {
+    const tmp = await fs.mkdtemp(path.join(os.tmpdir(), "clawdbot-security-fix-"));
+    const stateDir = path.join(tmp, "state");
+    await fs.mkdir(stateDir, { recursive: true });
+    await fs.chmod(stateDir, 0o755);
+
+    const configPath = path.join(stateDir, "clawdbot.json");
+    await fs.writeFile(
+      configPath,
+      `${JSON.stringify(
+        {
+          channels: {
+            telegram: { groupPolicy: "open" },
+            whatsapp: { groupPolicy: "open" },
+            discord: { groupPolicy: "open" },
+            signal: { groupPolicy: "open" },
+            imessage: { groupPolicy: "open" },
+          },
+          logging: { redactSensitive: "off" },
+        },
+        null,
+        2,
+      )}\n`,
+      "utf-8",
+    );
+    await fs.chmod(configPath, 0o644);
+
+    const credsDir = path.join(stateDir, "credentials");
+    await fs.mkdir(credsDir, { recursive: true });
+    await fs.writeFile(
+      path.join(credsDir, "whatsapp-allowFrom.json"),
+      `${JSON.stringify({ version: 1, allowFrom: [" +15551234567 "] }, null, 2)}\n`,
+      "utf-8",
+    );
+
+    const env = {
+      ...process.env,
+      CLAWDBOT_STATE_DIR: stateDir,
+      CLAWDBOT_CONFIG_PATH: "",
+    };
+
+    const res = await fixSecurityFootguns({ env });
+    expect(res.ok).toBe(true);
+    expect(res.configWritten).toBe(true);
+    expect(res.changes).toEqual(
+      expect.arrayContaining([
+        "channels.telegram.groupPolicy=open -> allowlist",
+        "channels.whatsapp.groupPolicy=open -> allowlist",
+        "channels.discord.groupPolicy=open -> allowlist",
+        "channels.signal.groupPolicy=open -> allowlist",
+        "channels.imessage.groupPolicy=open -> allowlist",
+        'logging.redactSensitive=off -> "tools"',
+      ]),
+    );
+
+    const stateMode = (await fs.stat(stateDir)).mode & 0o777;
+    expectPerms(stateMode, 0o700);
+
+    const configMode = (await fs.stat(configPath)).mode & 0o777;
+    expectPerms(configMode, 0o600);
+
+    const parsed = JSON.parse(await fs.readFile(configPath, "utf-8")) as Record<string, unknown>;
+    const channels = parsed.channels as Record<string, Record<string, unknown>>;
+    expect(channels.telegram.groupPolicy).toBe("allowlist");
+    expect(channels.whatsapp.groupPolicy).toBe("allowlist");
+    expect(channels.discord.groupPolicy).toBe("allowlist");
+    expect(channels.signal.groupPolicy).toBe("allowlist");
+    expect(channels.imessage.groupPolicy).toBe("allowlist");
+
+    expect(channels.whatsapp.groupAllowFrom).toEqual(["+15551234567"]);
+  });
+
+  it("applies allowlist per-account and seeds WhatsApp groupAllowFrom from store", async () => {
+    const tmp = await fs.mkdtemp(path.join(os.tmpdir(), "clawdbot-security-fix-"));
+    const stateDir = path.join(tmp, "state");
+    await fs.mkdir(stateDir, { recursive: true });
+
+    const configPath = path.join(stateDir, "clawdbot.json");
+    await fs.writeFile(
+      configPath,
+      `${JSON.stringify(
+        {
+          channels: {
+            whatsapp: {
+              accounts: {
+                a1: { groupPolicy: "open" },
+              },
+            },
+          },
+        },
+        null,
+        2,
+      )}\n`,
+      "utf-8",
+    );
+
+    const credsDir = path.join(stateDir, "credentials");
+    await fs.mkdir(credsDir, { recursive: true });
+    await fs.writeFile(
+      path.join(credsDir, "whatsapp-allowFrom.json"),
+      `${JSON.stringify({ version: 1, allowFrom: ["+15550001111"] }, null, 2)}\n`,
+      "utf-8",
+    );
+
+    const env = {
+      ...process.env,
+      CLAWDBOT_STATE_DIR: stateDir,
+      CLAWDBOT_CONFIG_PATH: "",
+    };
+
+    const res = await fixSecurityFootguns({ env });
+    expect(res.ok).toBe(true);
+
+    const parsed = JSON.parse(await fs.readFile(configPath, "utf-8")) as Record<string, unknown>;
+    const channels = parsed.channels as Record<string, Record<string, unknown>>;
+    const whatsapp = channels.whatsapp as Record<string, unknown>;
+    const accounts = whatsapp.accounts as Record<string, Record<string, unknown>>;
+
+    expect(accounts.a1.groupPolicy).toBe("allowlist");
+    expect(accounts.a1.groupAllowFrom).toEqual(["+15550001111"]);
+  });
+
+  it("does not seed WhatsApp groupAllowFrom if allowFrom is set", async () => {
+    const tmp = await fs.mkdtemp(path.join(os.tmpdir(), "clawdbot-security-fix-"));
+    const stateDir = path.join(tmp, "state");
+    await fs.mkdir(stateDir, { recursive: true });
+
+    const configPath = path.join(stateDir, "clawdbot.json");
+    await fs.writeFile(
+      configPath,
+      `${JSON.stringify(
+        {
+          channels: {
+            whatsapp: { groupPolicy: "open", allowFrom: ["+15552223333"] },
+          },
+        },
+        null,
+        2,
+      )}\n`,
+      "utf-8",
+    );
+
+    const credsDir = path.join(stateDir, "credentials");
+    await fs.mkdir(credsDir, { recursive: true });
+    await fs.writeFile(
+      path.join(credsDir, "whatsapp-allowFrom.json"),
+      `${JSON.stringify({ version: 1, allowFrom: ["+15550001111"] }, null, 2)}\n`,
+      "utf-8",
+    );
+
+    const env = {
+      ...process.env,
+      CLAWDBOT_STATE_DIR: stateDir,
+      CLAWDBOT_CONFIG_PATH: "",
+    };
+
+    const res = await fixSecurityFootguns({ env });
+    expect(res.ok).toBe(true);
+
+    const parsed = JSON.parse(await fs.readFile(configPath, "utf-8")) as Record<string, unknown>;
+    const channels = parsed.channels as Record<string, Record<string, unknown>>;
+    expect(channels.whatsapp.groupPolicy).toBe("allowlist");
+    expect(channels.whatsapp.groupAllowFrom).toBeUndefined();
+  });
+
+  it("returns ok=false for invalid config but still tightens perms", async () => {
+    const tmp = await fs.mkdtemp(path.join(os.tmpdir(), "clawdbot-security-fix-"));
+    const stateDir = path.join(tmp, "state");
+    await fs.mkdir(stateDir, { recursive: true });
+    await fs.chmod(stateDir, 0o755);
+
+    const configPath = path.join(stateDir, "clawdbot.json");
+    await fs.writeFile(configPath, "{ this is not json }\n", "utf-8");
+    await fs.chmod(configPath, 0o644);
+
+    const env = {
+      ...process.env,
+      CLAWDBOT_STATE_DIR: stateDir,
+      CLAWDBOT_CONFIG_PATH: "",
+    };
+
+    const res = await fixSecurityFootguns({ env });
+    expect(res.ok).toBe(false);
+
+    const stateMode = (await fs.stat(stateDir)).mode & 0o777;
+    expectPerms(stateMode, 0o700);
+
+    const configMode = (await fs.stat(configPath)).mode & 0o777;
+    expectPerms(configMode, 0o600);
+  });
+
+  it("tightens perms for credentials + agent auth/sessions + include files", async () => {
+    const tmp = await fs.mkdtemp(path.join(os.tmpdir(), "clawdbot-security-fix-"));
+    const stateDir = path.join(tmp, "state");
+    await fs.mkdir(stateDir, { recursive: true });
+
+    const includesDir = path.join(stateDir, "includes");
+    await fs.mkdir(includesDir, { recursive: true });
+    const includePath = path.join(includesDir, "extra.json5");
+    await fs.writeFile(includePath, "{ logging: { redactSensitive: 'off' } }\n", "utf-8");
+    await fs.chmod(includePath, 0o644);
+
+    const configPath = path.join(stateDir, "clawdbot.json");
+    await fs.writeFile(
+      configPath,
+      `{ "$include": "./includes/extra.json5", channels: { whatsapp: { groupPolicy: "open" } } }\n`,
+      "utf-8",
+    );
+    await fs.chmod(configPath, 0o644);
+
+    const credsDir = path.join(stateDir, "credentials");
+    await fs.mkdir(credsDir, { recursive: true });
+    const allowFromPath = path.join(credsDir, "whatsapp-allowFrom.json");
+    await fs.writeFile(
+      allowFromPath,
+      `${JSON.stringify({ version: 1, allowFrom: ["+15550002222"] }, null, 2)}\n`,
+      "utf-8",
+    );
+    await fs.chmod(allowFromPath, 0o644);
+
+    const agentDir = path.join(stateDir, "agents", "main", "agent");
+    await fs.mkdir(agentDir, { recursive: true });
+    const authProfilesPath = path.join(agentDir, "auth-profiles.json");
+    await fs.writeFile(authProfilesPath, "{}\n", "utf-8");
+    await fs.chmod(authProfilesPath, 0o644);
+
+    const sessionsDir = path.join(stateDir, "agents", "main", "sessions");
+    await fs.mkdir(sessionsDir, { recursive: true });
+    const sessionsStorePath = path.join(sessionsDir, "sessions.json");
+    await fs.writeFile(sessionsStorePath, "{}\n", "utf-8");
+    await fs.chmod(sessionsStorePath, 0o644);
+
+    const env = {
+      ...process.env,
+      CLAWDBOT_STATE_DIR: stateDir,
+      CLAWDBOT_CONFIG_PATH: "",
+    };
+
+    const res = await fixSecurityFootguns({ env });
+    expect(res.ok).toBe(true);
+
+    expect((await fs.stat(credsDir)).mode & 0o777).toBe(0o700);
+    expect((await fs.stat(allowFromPath)).mode & 0o777).toBe(0o600);
+    expect((await fs.stat(authProfilesPath)).mode & 0o777).toBe(0o600);
+    expect((await fs.stat(sessionsStorePath)).mode & 0o777).toBe(0o600);
+    expect((await fs.stat(includePath)).mode & 0o777).toBe(0o600);
+  });
+});
diff --git a/src/security/fix.ts b/src/security/fix.ts
new file mode 100644
index 000000000..1d3e4bf17
--- /dev/null
+++ b/src/security/fix.ts
@@ -0,0 +1,381 @@
+import fs from "node:fs/promises";
+import path from "node:path";
+
+import JSON5 from "json5";
+
+import type { ClawdbotConfig } from "../config/config.js";
+import { createConfigIO } from "../config/config.js";
+import { resolveConfigPath, resolveOAuthDir, resolveStateDir } from "../config/paths.js";
+import { resolveDefaultAgentId } from "../agents/agent-scope.js";
+import { INCLUDE_KEY, MAX_INCLUDE_DEPTH } from "../config/includes.js";
+import { normalizeAgentId } from "../routing/session-key.js";
+import { readChannelAllowFromStore } from "../pairing/pairing-store.js";
+
+export type SecurityFixChmodAction = {
+  kind: "chmod";
+  path: string;
+  mode: number;
+  ok: boolean;
+  skipped?: string;
+  error?: string;
+};
+
+export type SecurityFixResult = {
+  ok: boolean;
+  stateDir: string;
+  configPath: string;
+  configWritten: boolean;
+  changes: string[];
+  actions: SecurityFixChmodAction[];
+  errors: string[];
+};
+
+async function safeChmod(params: {
+  path: string;
+  mode: number;
+  require: "dir" | "file";
+}): Promise<SecurityFixChmodAction> {
+  try {
+    const st = await fs.lstat(params.path);
+    if (st.isSymbolicLink()) {
+      return {
+        kind: "chmod",
+        path: params.path,
+        mode: params.mode,
+        ok: false,
+        skipped: "symlink",
+      };
+    }
+    if (params.require === "dir" && !st.isDirectory()) {
+      return {
+        kind: "chmod",
+        path: params.path,
+        mode: params.mode,
+        ok: false,
+        skipped: "not-a-directory",
+      };
+    }
+    if (params.require === "file" && !st.isFile()) {
+      return {
+        kind: "chmod",
+        path: params.path,
+        mode: params.mode,
+        ok: false,
+        skipped: "not-a-file",
+      };
+    }
+    const current = st.mode & 0o777;
+    if (current === params.mode) {
+      return {
+        kind: "chmod",
+        path: params.path,
+        mode: params.mode,
+        ok: false,
+        skipped: "already",
+      };
+    }
+    await fs.chmod(params.path, params.mode);
+    return { kind: "chmod", path: params.path, mode: params.mode, ok: true };
+  } catch (err) {
+    const code = (err as { code?: string }).code;
+    if (code === "ENOENT") {
+      return {
+        kind: "chmod",
+        path: params.path,
+        mode: params.mode,
+        ok: false,
+        skipped: "missing",
+      };
+    }
+    return {
+      kind: "chmod",
+      path: params.path,
+      mode: params.mode,
+      ok: false,
+      error: String(err),
+    };
+  }
+}
+
+function setGroupPolicyAllowlist(params: {
+  cfg: ClawdbotConfig;
+  channel: string;
+  changes: string[];
+  policyFlips: Set<string>;
+}): void {
+  if (!params.cfg.channels) return;
+  const section = params.cfg.channels[params.channel as keyof ClawdbotConfig["channels"]] as
+    | Record<string, unknown>
+    | undefined;
+  if (!section || typeof section !== "object") return;
+
+  const topPolicy = section.groupPolicy;
+  if (topPolicy === "open") {
+    section.groupPolicy = "allowlist";
+    params.changes.push(`channels.${params.channel}.groupPolicy=open -> allowlist`);
+    params.policyFlips.add(`channels.${params.channel}.`);
+  }
+
+  const accounts = section.accounts;
+  if (!accounts || typeof accounts !== "object") return;
+  for (const [accountId, accountValue] of Object.entries(accounts)) {
+    if (!accountId) continue;
+    if (!accountValue || typeof accountValue !== "object") continue;
+    const account = accountValue as Record<string, unknown>;
+    if (account.groupPolicy === "open") {
+      account.groupPolicy = "allowlist";
+      params.changes.push(
+        `channels.${params.channel}.accounts.${accountId}.groupPolicy=open -> allowlist`,
+      );
+      params.policyFlips.add(`channels.${params.channel}.accounts.${accountId}.`);
+    }
+  }
+}
+
+function setWhatsAppGroupAllowFromFromStore(params: {
+  cfg: ClawdbotConfig;
+  storeAllowFrom: string[];
+  changes: string[];
+  policyFlips: Set<string>;
+}): void {
+  const section = params.cfg.channels?.whatsapp as Record<string, unknown> | undefined;
+  if (!section || typeof section !== "object") return;
+  if (params.storeAllowFrom.length === 0) return;
+
+  const maybeApply = (prefix: string, obj: Record<string, unknown>) => {
+    if (!params.policyFlips.has(prefix)) return;
+    const allowFrom = Array.isArray(obj.allowFrom) ? obj.allowFrom : [];
+    const groupAllowFrom = Array.isArray(obj.groupAllowFrom) ? obj.groupAllowFrom : [];
+    if (allowFrom.length > 0) return;
+    if (groupAllowFrom.length > 0) return;
+    obj.groupAllowFrom = params.storeAllowFrom;
+    params.changes.push(`${prefix}groupAllowFrom=pairing-store`);
+  };
+
+  maybeApply("channels.whatsapp.", section);
+
+  const accounts = section.accounts;
+  if (!accounts || typeof accounts !== "object") return;
+  for (const [accountId, accountValue] of Object.entries(accounts)) {
+    if (!accountValue || typeof accountValue !== "object") continue;
+    const account = accountValue as Record<string, unknown>;
+    maybeApply(`channels.whatsapp.accounts.${accountId}.`, account);
+  }
+}
+
+function applyConfigFixes(params: { cfg: ClawdbotConfig; env: NodeJS.ProcessEnv }): {
+  cfg: ClawdbotConfig;
+  changes: string[];
+  policyFlips: Set<string>;
+} {
+  const next = structuredClone(params.cfg ?? {});
+  const changes: string[] = [];
+  const policyFlips = new Set<string>();
+
+  if (next.logging?.redactSensitive === "off") {
+    next.logging = { ...next.logging, redactSensitive: "tools" };
+    changes.push('logging.redactSensitive=off -> "tools"');
+  }
+
+  for (const channel of [
+    "telegram",
+    "whatsapp",
+    "discord",
+    "signal",
+    "imessage",
+    "slack",
+    "msteams",
+  ]) {
+    setGroupPolicyAllowlist({ cfg: next, channel, changes, policyFlips });
+  }
+
+  return { cfg: next, changes, policyFlips };
+}
+
+function listDirectIncludes(parsed: unknown): string[] {
+  const out: string[] = [];
+  const visit = (value: unknown) => {
+    if (!value) return;
+    if (Array.isArray(value)) {
+      for (const item of value) visit(item);
+      return;
+    }
+    if (typeof value !== "object") return;
+    const rec = value as Record<string, unknown>;
+    const includeVal = rec[INCLUDE_KEY];
+    if (typeof includeVal === "string") out.push(includeVal);
+    else if (Array.isArray(includeVal)) {
+      for (const item of includeVal) {
+        if (typeof item === "string") out.push(item);
+      }
+    }
+    for (const v of Object.values(rec)) visit(v);
+  };
+  visit(parsed);
+  return out;
+}
+
+function resolveIncludePath(baseConfigPath: string, includePath: string): string {
+  return path.normalize(
+    path.isAbsolute(includePath)
+      ? includePath
+      : path.resolve(path.dirname(baseConfigPath), includePath),
+  );
+}
+
+async function collectIncludePathsRecursive(params: {
+  configPath: string;
+  parsed: unknown;
+}): Promise<string[]> {
+  const visited = new Set<string>();
+  const result: string[] = [];
+
+  const walk = async (basePath: string, parsed: unknown, depth: number): Promise<void> => {
+    if (depth > MAX_INCLUDE_DEPTH) return;
+    for (const raw of listDirectIncludes(parsed)) {
+      const resolved = resolveIncludePath(basePath, raw);
+      if (visited.has(resolved)) continue;
+      visited.add(resolved);
+      result.push(resolved);
+      const rawText = await fs.readFile(resolved, "utf-8").catch(() => null);
+      if (!rawText) continue;
+      const nestedParsed = (() => {
+        try {
+          return JSON5.parse(rawText) as unknown;
+        } catch {
+          return null;
+        }
+      })();
+      if (nestedParsed) {
+        // eslint-disable-next-line no-await-in-loop
+        await walk(resolved, nestedParsed, depth + 1);
+      }
+    }
+  };
+
+  await walk(params.configPath, params.parsed, 0);
+  return result;
+}
+
+async function chmodCredentialsAndAgentState(params: {
+  env: NodeJS.ProcessEnv;
+  stateDir: string;
+  cfg: ClawdbotConfig;
+  actions: SecurityFixChmodAction[];
+}): Promise<void> {
+  const credsDir = resolveOAuthDir(params.env, params.stateDir);
+  params.actions.push(await safeChmod({ path: credsDir, mode: 0o700, require: "dir" }));
+
+  const credsEntries = await fs.readdir(credsDir, { withFileTypes: true }).catch(() => []);
+  for (const entry of credsEntries) {
+    if (!entry.isFile()) continue;
+    if (!entry.name.endsWith(".json")) continue;
+    const p = path.join(credsDir, entry.name);
+    // eslint-disable-next-line no-await-in-loop
+    params.actions.push(await safeChmod({ path: p, mode: 0o600, require: "file" }));
+  }
+
+  const ids = new Set<string>();
+  ids.add(resolveDefaultAgentId(params.cfg));
+  const list = Array.isArray(params.cfg.agents?.list) ? params.cfg.agents?.list : [];
+  for (const agent of list ?? []) {
+    if (!agent || typeof agent !== "object") continue;
+    const id = typeof (agent as { id?: unknown }).id === "string" ? (agent as { id: string }).id.trim() : "";
+    if (id) ids.add(id);
+  }
+
+  for (const agentId of ids) {
+    const normalizedAgentId = normalizeAgentId(agentId);
+    const agentRoot = path.join(params.stateDir, "agents", normalizedAgentId);
+    const agentDir = path.join(agentRoot, "agent");
+    const sessionsDir = path.join(agentRoot, "sessions");
+
+    // eslint-disable-next-line no-await-in-loop
+    params.actions.push(await safeChmod({ path: agentRoot, mode: 0o700, require: "dir" }));
+    // eslint-disable-next-line no-await-in-loop
+    params.actions.push(await safeChmod({ path: agentDir, mode: 0o700, require: "dir" }));
+
+    const authPath = path.join(agentDir, "auth-profiles.json");
+    // eslint-disable-next-line no-await-in-loop
+    params.actions.push(await safeChmod({ path: authPath, mode: 0o600, require: "file" }));
+
+    // eslint-disable-next-line no-await-in-loop
+    params.actions.push(await safeChmod({ path: sessionsDir, mode: 0o700, require: "dir" }));
+
+    const storePath = path.join(sessionsDir, "sessions.json");
+    // eslint-disable-next-line no-await-in-loop
+    params.actions.push(await safeChmod({ path: storePath, mode: 0o600, require: "file" }));
+  }
+}
+
+export async function fixSecurityFootguns(opts?: {
+  env?: NodeJS.ProcessEnv;
+  stateDir?: string;
+  configPath?: string;
+}): Promise<SecurityFixResult> {
+  const env = opts?.env ?? process.env;
+  const stateDir = opts?.stateDir ?? resolveStateDir(env);
+  const configPath = opts?.configPath ?? resolveConfigPath(env, stateDir);
+  const actions: SecurityFixChmodAction[] = [];
+  const errors: string[] = [];
+
+  const io = createConfigIO({ env, configPath });
+  const snap = await io.readConfigFileSnapshot();
+  if (!snap.valid) {
+    errors.push(...snap.issues.map((i) => `${i.path}: ${i.message}`));
+  }
+
+  let configWritten = false;
+  let changes: string[] = [];
+  if (snap.valid) {
+    const fixed = applyConfigFixes({ cfg: snap.config, env });
+    changes = fixed.changes;
+
+    const whatsappStoreAllowFrom = await readChannelAllowFromStore("whatsapp", env).catch(() => []);
+    if (whatsappStoreAllowFrom.length > 0) {
+      setWhatsAppGroupAllowFromFromStore({
+        cfg: fixed.cfg,
+        storeAllowFrom: whatsappStoreAllowFrom,
+        changes,
+        policyFlips: fixed.policyFlips,
+      });
+    }
+
+    if (changes.length > 0) {
+      try {
+        await io.writeConfigFile(fixed.cfg);
+        configWritten = true;
+      } catch (err) {
+        errors.push(`writeConfigFile failed: ${String(err)}`);
+      }
+    }
+  }
+
+  actions.push(await safeChmod({ path: stateDir, mode: 0o700, require: "dir" }));
+  actions.push(await safeChmod({ path: configPath, mode: 0o600, require: "file" }));
+
+  if (snap.exists) {
+    const includePaths = await collectIncludePathsRecursive({
+      configPath: snap.path,
+      parsed: snap.parsed,
+    }).catch(() => []);
+    for (const p of includePaths) {
+      // eslint-disable-next-line no-await-in-loop
+      actions.push(await safeChmod({ path: p, mode: 0o600, require: "file" }));
+    }
+  }
+
+  await chmodCredentialsAndAgentState({ env, stateDir, cfg: snap.config ?? {}, actions }).catch((err) => {
+    errors.push(`chmodCredentialsAndAgentState failed: ${String(err)}`);
+  });
+
+  return {
+    ok: errors.length === 0,
+    stateDir,
+    configPath,
+    configWritten,
+    changes,
+    actions,
+    errors,
+  };
+}
diff --git a/src/signal/format.test.ts b/src/signal/format.test.ts
new file mode 100644
index 000000000..7c66e3013
--- /dev/null
+++ b/src/signal/format.test.ts
@@ -0,0 +1,57 @@
+import { describe, expect, it } from "vitest";
+
+import { markdownToSignalText } from "./format.js";
+
+describe("markdownToSignalText", () => {
+  it("renders inline styles", () => {
+    const res = markdownToSignalText("hi _there_ **boss** ~~nope~~ `code`");
+
+    expect(res.text).toBe("hi there boss nope code");
+    expect(res.styles).toEqual([
+      { start: 3, length: 5, style: "ITALIC" },
+      { start: 9, length: 4, style: "BOLD" },
+      { start: 14, length: 4, style: "STRIKETHROUGH" },
+      { start: 19, length: 4, style: "MONOSPACE" },
+    ]);
+  });
+
+  it("renders links as label plus url when needed", () => {
+    const res = markdownToSignalText("see [docs](https://example.com) and https://example.com");
+
+    expect(res.text).toBe("see docs (https://example.com) and https://example.com");
+    expect(res.styles).toEqual([]);
+  });
+
+  it("applies spoiler styling", () => {
+    const res = markdownToSignalText("hello ||secret|| world");
+
+    expect(res.text).toBe("hello secret world");
+    expect(res.styles).toEqual([{ start: 6, length: 6, style: "SPOILER" }]);
+  });
+
+  it("renders fenced code blocks with monospaced styles", () => {
+    const res = markdownToSignalText("before\n\n```\nconst x = 1;\n```\n\nafter");
+
+    const prefix = "before\n\n";
+    const code = "const x = 1;\n";
+    const suffix = "\nafter";
+
+    expect(res.text).toBe(`${prefix}${code}${suffix}`);
+    expect(res.styles).toEqual([{ start: prefix.length, length: code.length, style: "MONOSPACE" }]);
+  });
+
+  it("renders lists without extra block markup", () => {
+    const res = markdownToSignalText("- one\n- two");
+
+    expect(res.text).toBe("• one\n• two");
+    expect(res.styles).toEqual([]);
+  });
+
+  it("uses UTF-16 code units for offsets", () => {
+    const res = markdownToSignalText("😀 **bold**");
+
+    const prefix = "😀 ";
+    expect(res.text).toBe(`${prefix}bold`);
+    expect(res.styles).toEqual([{ start: prefix.length, length: 4, style: "BOLD" }]);
+  });
+});
diff --git a/src/signal/format.ts b/src/signal/format.ts
new file mode 100644
index 000000000..0890ce608
--- /dev/null
+++ b/src/signal/format.ts
@@ -0,0 +1,210 @@
+import {
+  chunkMarkdownIR,
+  markdownToIR,
+  type MarkdownIR,
+  type MarkdownStyle,
+} from "../markdown/ir.js";
+
+type SignalTextStyle = "BOLD" | "ITALIC" | "STRIKETHROUGH" | "MONOSPACE" | "SPOILER";
+
+export type SignalTextStyleRange = {
+  start: number;
+  length: number;
+  style: SignalTextStyle;
+};
+
+export type SignalFormattedText = {
+  text: string;
+  styles: SignalTextStyleRange[];
+};
+
+type SignalStyleSpan = {
+  start: number;
+  end: number;
+  style: SignalTextStyle;
+};
+
+type Insertion = {
+  pos: number;
+  length: number;
+};
+
+function mapStyle(style: MarkdownStyle): SignalTextStyle | null {
+  switch (style) {
+    case "bold":
+      return "BOLD";
+    case "italic":
+      return "ITALIC";
+    case "strikethrough":
+      return "STRIKETHROUGH";
+    case "code":
+    case "code_block":
+      return "MONOSPACE";
+    case "spoiler":
+      return "SPOILER";
+    default:
+      return null;
+  }
+}
+
+function mergeStyles(styles: SignalTextStyleRange[]): SignalTextStyleRange[] {
+  const sorted = [...styles].sort((a, b) => {
+    if (a.start !== b.start) return a.start - b.start;
+    if (a.length !== b.length) return a.length - b.length;
+    return a.style.localeCompare(b.style);
+  });
+
+  const merged: SignalTextStyleRange[] = [];
+  for (const style of sorted) {
+    const prev = merged[merged.length - 1];
+    if (prev && prev.style === style.style && style.start <= prev.start + prev.length) {
+      const prevEnd = prev.start + prev.length;
+      const nextEnd = Math.max(prevEnd, style.start + style.length);
+      prev.length = nextEnd - prev.start;
+      continue;
+    }
+    merged.push({ ...style });
+  }
+
+  return merged;
+}
+
+function clampStyles(styles: SignalTextStyleRange[], maxLength: number): SignalTextStyleRange[] {
+  const clamped: SignalTextStyleRange[] = [];
+  for (const style of styles) {
+    const start = Math.max(0, Math.min(style.start, maxLength));
+    const end = Math.min(style.start + style.length, maxLength);
+    const length = end - start;
+    if (length > 0) clamped.push({ start, length, style: style.style });
+  }
+  return clamped;
+}
+
+function applyInsertionsToStyles(
+  spans: SignalStyleSpan[],
+  insertions: Insertion[],
+): SignalStyleSpan[] {
+  if (insertions.length === 0) return spans;
+  const sortedInsertions = [...insertions].sort((a, b) => a.pos - b.pos);
+  let updated = spans;
+
+  for (const insertion of sortedInsertions) {
+    const next: SignalStyleSpan[] = [];
+    for (const span of updated) {
+      if (span.end <= insertion.pos) {
+        next.push(span);
+        continue;
+      }
+      if (span.start >= insertion.pos) {
+        next.push({
+          start: span.start + insertion.length,
+          end: span.end + insertion.length,
+          style: span.style,
+        });
+        continue;
+      }
+      if (span.start < insertion.pos && span.end > insertion.pos) {
+        if (insertion.pos > span.start) {
+          next.push({
+            start: span.start,
+            end: insertion.pos,
+            style: span.style,
+          });
+        }
+        const shiftedStart = insertion.pos + insertion.length;
+        const shiftedEnd = span.end + insertion.length;
+        if (shiftedEnd > shiftedStart) {
+          next.push({
+            start: shiftedStart,
+            end: shiftedEnd,
+            style: span.style,
+          });
+        }
+      }
+    }
+    updated = next;
+  }
+
+  return updated;
+}
+
+function renderSignalText(ir: MarkdownIR): SignalFormattedText {
+  const text = ir.text ?? "";
+  if (!text) return { text: "", styles: [] };
+
+  const sortedLinks = [...ir.links].sort((a, b) => a.start - b.start);
+  let out = "";
+  let cursor = 0;
+  const insertions: Insertion[] = [];
+
+  for (const link of sortedLinks) {
+    if (link.start < cursor) continue;
+    out += text.slice(cursor, link.end);
+
+    const href = link.href.trim();
+    const label = text.slice(link.start, link.end);
+    const trimmedLabel = label.trim();
+    const comparableHref = href.startsWith("mailto:") ? href.slice("mailto:".length) : href;
+
+    if (href) {
+      if (!trimmedLabel) {
+        out += href;
+        insertions.push({ pos: link.end, length: href.length });
+      } else if (trimmedLabel !== href && trimmedLabel !== comparableHref) {
+        const addition = ` (${href})`;
+        out += addition;
+        insertions.push({ pos: link.end, length: addition.length });
+      }
+    }
+
+    cursor = link.end;
+  }
+
+  out += text.slice(cursor);
+
+  const mappedStyles: SignalStyleSpan[] = ir.styles
+    .map((span) => {
+      const mapped = mapStyle(span.style);
+      if (!mapped) return null;
+      return { start: span.start, end: span.end, style: mapped };
+    })
+    .filter((span): span is SignalStyleSpan => span !== null);
+
+  const adjusted = applyInsertionsToStyles(mappedStyles, insertions);
+  const trimmedText = out.trimEnd();
+  const trimmedLength = trimmedText.length;
+  const clamped = clampStyles(
+    adjusted.map((span) => ({
+      start: span.start,
+      length: span.end - span.start,
+      style: span.style,
+    })),
+    trimmedLength,
+  );
+
+  return {
+    text: trimmedText,
+    styles: mergeStyles(clamped),
+  };
+}
+
+export function markdownToSignalText(markdown: string): SignalFormattedText {
+  const ir = markdownToIR(markdown ?? "", {
+    linkify: true,
+    enableSpoilers: true,
+    headingStyle: "none",
+    blockquotePrefix: "",
+  });
+  return renderSignalText(ir);
+}
+
+export function markdownToSignalTextChunks(markdown: string, limit: number): SignalFormattedText[] {
+  const ir = markdownToIR(markdown ?? "", {
+    linkify: true,
+    enableSpoilers: true,
+    headingStyle: "none",
+    blockquotePrefix: "",
+  });
+  const chunks = chunkMarkdownIR(ir, limit);
+  return chunks.map((chunk) => renderSignalText(chunk));
+}
diff --git a/src/slack/channel-migration.test.ts b/src/slack/channel-migration.test.ts
new file mode 100644
index 000000000..b2837b554
--- /dev/null
+++ b/src/slack/channel-migration.test.ts
@@ -0,0 +1,113 @@
+import { describe, expect, it } from "vitest";
+
+import { migrateSlackChannelConfig } from "./channel-migration.js";
+
+describe("migrateSlackChannelConfig", () => {
+  it("migrates global channel ids", () => {
+    const cfg = {
+      channels: {
+        slack: {
+          channels: {
+            C123: { requireMention: false },
+          },
+        },
+      },
+    };
+
+    const result = migrateSlackChannelConfig({
+      cfg,
+      accountId: "default",
+      oldChannelId: "C123",
+      newChannelId: "C999",
+    });
+
+    expect(result.migrated).toBe(true);
+    expect(cfg.channels.slack.channels).toEqual({
+      C999: { requireMention: false },
+    });
+  });
+
+  it("migrates account-scoped channels", () => {
+    const cfg = {
+      channels: {
+        slack: {
+          accounts: {
+            primary: {
+              channels: {
+                C123: { requireMention: true },
+              },
+            },
+          },
+        },
+      },
+    };
+
+    const result = migrateSlackChannelConfig({
+      cfg,
+      accountId: "primary",
+      oldChannelId: "C123",
+      newChannelId: "C999",
+    });
+
+    expect(result.migrated).toBe(true);
+    expect(result.scopes).toEqual(["account"]);
+    expect(cfg.channels.slack.accounts.primary.channels).toEqual({
+      C999: { requireMention: true },
+    });
+  });
+
+  it("matches account ids case-insensitively", () => {
+    const cfg = {
+      channels: {
+        slack: {
+          accounts: {
+            Primary: {
+              channels: {
+                C123: {},
+              },
+            },
+          },
+        },
+      },
+    };
+
+    const result = migrateSlackChannelConfig({
+      cfg,
+      accountId: "primary",
+      oldChannelId: "C123",
+      newChannelId: "C999",
+    });
+
+    expect(result.migrated).toBe(true);
+    expect(cfg.channels.slack.accounts.Primary.channels).toEqual({
+      C999: {},
+    });
+  });
+
+  it("skips migration when new id already exists", () => {
+    const cfg = {
+      channels: {
+        slack: {
+          channels: {
+            C123: { requireMention: true },
+            C999: { requireMention: false },
+          },
+        },
+      },
+    };
+
+    const result = migrateSlackChannelConfig({
+      cfg,
+      accountId: "default",
+      oldChannelId: "C123",
+      newChannelId: "C999",
+    });
+
+    expect(result.migrated).toBe(false);
+    expect(result.skippedExisting).toBe(true);
+    expect(cfg.channels.slack.channels).toEqual({
+      C123: { requireMention: true },
+      C999: { requireMention: false },
+    });
+  });
+});
diff --git a/src/slack/channel-migration.ts b/src/slack/channel-migration.ts
new file mode 100644
index 000000000..bc68c278b
--- /dev/null
+++ b/src/slack/channel-migration.ts
@@ -0,0 +1,84 @@
+import type { ClawdbotConfig } from "../config/config.js";
+import type { SlackChannelConfig } from "../config/types.slack.js";
+import { normalizeAccountId } from "../routing/session-key.js";
+
+type SlackChannels = Record<string, SlackChannelConfig>;
+
+type MigrationScope = "account" | "global";
+
+export type SlackChannelMigrationResult = {
+  migrated: boolean;
+  skippedExisting: boolean;
+  scopes: MigrationScope[];
+};
+
+function resolveAccountChannels(
+  cfg: ClawdbotConfig,
+  accountId?: string | null,
+): { channels?: SlackChannels } {
+  if (!accountId) return {};
+  const normalized = normalizeAccountId(accountId);
+  const accounts = cfg.channels?.slack?.accounts;
+  if (!accounts || typeof accounts !== "object") return {};
+  const exact = accounts[normalized];
+  if (exact?.channels) return { channels: exact.channels };
+  const matchKey = Object.keys(accounts).find(
+    (key) => key.toLowerCase() === normalized.toLowerCase(),
+  );
+  return { channels: matchKey ? accounts[matchKey]?.channels : undefined };
+}
+
+export function migrateSlackChannelsInPlace(
+  channels: SlackChannels | undefined,
+  oldChannelId: string,
+  newChannelId: string,
+): { migrated: boolean; skippedExisting: boolean } {
+  if (!channels) return { migrated: false, skippedExisting: false };
+  if (oldChannelId === newChannelId) return { migrated: false, skippedExisting: false };
+  if (!Object.hasOwn(channels, oldChannelId)) return { migrated: false, skippedExisting: false };
+  if (Object.hasOwn(channels, newChannelId)) return { migrated: false, skippedExisting: true };
+  channels[newChannelId] = channels[oldChannelId];
+  delete channels[oldChannelId];
+  return { migrated: true, skippedExisting: false };
+}
+
+export function migrateSlackChannelConfig(params: {
+  cfg: ClawdbotConfig;
+  accountId?: string | null;
+  oldChannelId: string;
+  newChannelId: string;
+}): SlackChannelMigrationResult {
+  const scopes: MigrationScope[] = [];
+  let migrated = false;
+  let skippedExisting = false;
+
+  const accountChannels = resolveAccountChannels(params.cfg, params.accountId).channels;
+  if (accountChannels) {
+    const result = migrateSlackChannelsInPlace(
+      accountChannels,
+      params.oldChannelId,
+      params.newChannelId,
+    );
+    if (result.migrated) {
+      migrated = true;
+      scopes.push("account");
+    }
+    if (result.skippedExisting) skippedExisting = true;
+  }
+
+  const globalChannels = params.cfg.channels?.slack?.channels;
+  if (globalChannels) {
+    const result = migrateSlackChannelsInPlace(
+      globalChannels,
+      params.oldChannelId,
+      params.newChannelId,
+    );
+    if (result.migrated) {
+      migrated = true;
+      scopes.push("global");
+    }
+    if (result.skippedExisting) skippedExisting = true;
+  }
+
+  return { migrated, skippedExisting, scopes };
+}
diff --git a/src/slack/monitor/channel-config.test.ts b/src/slack/monitor/channel-config.test.ts
new file mode 100644
index 000000000..6d71a3ab3
--- /dev/null
+++ b/src/slack/monitor/channel-config.test.ts
@@ -0,0 +1,31 @@
+import { describe, expect, it } from "vitest";
+
+import { resolveSlackChannelConfig } from "./channel-config.js";
+
+describe("resolveSlackChannelConfig", () => {
+  it("uses defaultRequireMention when channels config is empty", () => {
+    const res = resolveSlackChannelConfig({
+      channelId: "C1",
+      channels: {},
+      defaultRequireMention: false,
+    });
+    expect(res).toEqual({ allowed: true, requireMention: false });
+  });
+
+  it("defaults defaultRequireMention to true when not provided", () => {
+    const res = resolveSlackChannelConfig({
+      channelId: "C1",
+      channels: {},
+    });
+    expect(res).toEqual({ allowed: true, requireMention: true });
+  });
+
+  it("prefers explicit channel/fallback requireMention over defaultRequireMention", () => {
+    const res = resolveSlackChannelConfig({
+      channelId: "C1",
+      channels: { "*": { requireMention: true } },
+      defaultRequireMention: false,
+    });
+    expect(res).toMatchObject({ requireMention: true });
+  });
+});
diff --git a/src/telegram/group-migration.test.ts b/src/telegram/group-migration.test.ts
new file mode 100644
index 000000000..f6cc03360
--- /dev/null
+++ b/src/telegram/group-migration.test.ts
@@ -0,0 +1,113 @@
+import { describe, expect, it } from "vitest";
+
+import { migrateTelegramGroupConfig } from "./group-migration.js";
+
+describe("migrateTelegramGroupConfig", () => {
+  it("migrates global group ids", () => {
+    const cfg = {
+      channels: {
+        telegram: {
+          groups: {
+            "-123": { requireMention: false },
+          },
+        },
+      },
+    };
+
+    const result = migrateTelegramGroupConfig({
+      cfg,
+      accountId: "default",
+      oldChatId: "-123",
+      newChatId: "-100123",
+    });
+
+    expect(result.migrated).toBe(true);
+    expect(cfg.channels.telegram.groups).toEqual({
+      "-100123": { requireMention: false },
+    });
+  });
+
+  it("migrates account-scoped groups", () => {
+    const cfg = {
+      channels: {
+        telegram: {
+          accounts: {
+            primary: {
+              groups: {
+                "-123": { requireMention: true },
+              },
+            },
+          },
+        },
+      },
+    };
+
+    const result = migrateTelegramGroupConfig({
+      cfg,
+      accountId: "primary",
+      oldChatId: "-123",
+      newChatId: "-100123",
+    });
+
+    expect(result.migrated).toBe(true);
+    expect(result.scopes).toEqual(["account"]);
+    expect(cfg.channels.telegram.accounts.primary.groups).toEqual({
+      "-100123": { requireMention: true },
+    });
+  });
+
+  it("matches account ids case-insensitively", () => {
+    const cfg = {
+      channels: {
+        telegram: {
+          accounts: {
+            Primary: {
+              groups: {
+                "-123": {},
+              },
+            },
+          },
+        },
+      },
+    };
+
+    const result = migrateTelegramGroupConfig({
+      cfg,
+      accountId: "primary",
+      oldChatId: "-123",
+      newChatId: "-100123",
+    });
+
+    expect(result.migrated).toBe(true);
+    expect(cfg.channels.telegram.accounts.Primary.groups).toEqual({
+      "-100123": {},
+    });
+  });
+
+  it("skips migration when new id already exists", () => {
+    const cfg = {
+      channels: {
+        telegram: {
+          groups: {
+            "-123": { requireMention: true },
+            "-100123": { requireMention: false },
+          },
+        },
+      },
+    };
+
+    const result = migrateTelegramGroupConfig({
+      cfg,
+      accountId: "default",
+      oldChatId: "-123",
+      newChatId: "-100123",
+    });
+
+    expect(result.migrated).toBe(false);
+    expect(result.skippedExisting).toBe(true);
+    expect(cfg.channels.telegram.groups).toEqual({
+      "-123": { requireMention: true },
+      "-100123": { requireMention: false },
+    });
+  });
+});
diff --git a/src/telegram/group-migration.ts b/src/telegram/group-migration.ts
new file mode 100644
index 000000000..efa3678ad
--- /dev/null
+++ b/src/telegram/group-migration.ts
@@ -0,0 +1,76 @@
+import type { ClawdbotConfig } from "../config/config.js";
+import type { TelegramGroupConfig } from "../config/types.telegram.js";
+import { normalizeAccountId } from "../routing/session-key.js";
+
+type TelegramGroups = Record<string, TelegramGroupConfig>;
+
+type MigrationScope = "account" | "global";
+
+export type TelegramGroupMigrationResult = {
+  migrated: boolean;
+  skippedExisting: boolean;
+  scopes: MigrationScope[];
+};
+
+function resolveAccountGroups(
+  cfg: ClawdbotConfig,
+  accountId?: string | null,
+): { groups?: TelegramGroups } {
+  if (!accountId) return {};
+  const normalized = normalizeAccountId(accountId);
+  const accounts = cfg.channels?.telegram?.accounts;
+  if (!accounts || typeof accounts !== "object") return {};
+  const exact = accounts[normalized];
+  if (exact?.groups) return { groups: exact.groups };
+  const matchKey = Object.keys(accounts).find(
+    (key) => key.toLowerCase() === normalized.toLowerCase(),
+  );
+  return { groups: matchKey ? accounts[matchKey]?.groups : undefined };
+}
+
+export function migrateTelegramGroupsInPlace(
+  groups: TelegramGroups | undefined,
+  oldChatId: string,
+  newChatId: string,
+): { migrated: boolean; skippedExisting: boolean } {
+  if (!groups) return { migrated: false, skippedExisting: false };
+  if (oldChatId === newChatId) return { migrated: false, skippedExisting: false };
+  if (!Object.hasOwn(groups, oldChatId)) return { migrated: false, skippedExisting: false };
+  if (Object.hasOwn(groups, newChatId)) return { migrated: false, skippedExisting: true };
+  groups[newChatId] = groups[oldChatId];
+  delete groups[oldChatId];
+  return { migrated: true, skippedExisting: false };
+}
+
+export function migrateTelegramGroupConfig(params: {
+  cfg: ClawdbotConfig;
+  accountId?: string | null;
+  oldChatId: string;
+  newChatId: string;
+}): TelegramGroupMigrationResult {
+  const scopes: MigrationScope[] = [];
+  let migrated = false;
+  let skippedExisting = false;
+
+  const accountGroups = resolveAccountGroups(params.cfg, params.accountId).groups;
+  if (accountGroups) {
+    const result = migrateTelegramGroupsInPlace(accountGroups, params.oldChatId, params.newChatId);
+    if (result.migrated) {
+      migrated = true;
+      scopes.push("account");
+    }
+    if (result.skippedExisting) skippedExisting = true;
+  }
+
+  const globalGroups = params.cfg.channels?.telegram?.groups;
+  if (globalGroups) {
+    const result = migrateTelegramGroupsInPlace(globalGroups, params.oldChatId, params.newChatId);
+    if (result.migrated) {
+      migrated = true;
+      scopes.push("global");
+    }
+    if (result.skippedExisting) skippedExisting = true;
+  }
+
+  return { migrated, skippedExisting, scopes };
+}
diff --git a/src/tui/tui-overlays.test.ts b/src/tui/tui-overlays.test.ts
new file mode 100644
index 000000000..a612c8c76
--- /dev/null
+++ b/src/tui/tui-overlays.test.ts
@@ -0,0 +1,60 @@
+import type { Component } from "@mariozechner/pi-tui";
+import { describe, expect, it, vi } from "vitest";
+
+import { createOverlayHandlers } from "./tui-overlays.js";
+
+class DummyComponent implements Component {
+  render() {
+    return ["dummy"];
+  }
+
+  invalidate() {}
+}
+
+describe("createOverlayHandlers", () => {
+  it("routes overlays through the TUI overlay stack", () => {
+    const showOverlay = vi.fn();
+    const hideOverlay = vi.fn();
+    const setFocus = vi.fn();
+    let open = false;
+
+    const host = {
+      showOverlay: (component: Component) => {
+        open = true;
+        showOverlay(component);
+      },
+      hideOverlay: () => {
+        open = false;
+        hideOverlay();
+      },
+      hasOverlay: () => open,
+      setFocus,
+    };
+
+    const { openOverlay, closeOverlay } = createOverlayHandlers(host, new DummyComponent());
+    const overlay = new DummyComponent();
+
+    openOverlay(overlay);
+    expect(showOverlay).toHaveBeenCalledWith(overlay);
+
+    closeOverlay();
+    expect(hideOverlay).toHaveBeenCalledTimes(1);
+    expect(setFocus).not.toHaveBeenCalled();
+  });
+
+  it("restores focus when closing without an overlay", () => {
+    const setFocus = vi.fn();
+    const host = {
+      showOverlay: vi.fn(),
+      hideOverlay: vi.fn(),
+      hasOverlay: () => false,
+      setFocus,
+    };
+    const fallback = new DummyComponent();
+
+    const { closeOverlay } = createOverlayHandlers(host, fallback);
+    closeOverlay();
+
+    expect(setFocus).toHaveBeenCalledWith(fallback);
+  });
+});
diff --git a/src/tui/tui-overlays.ts b/src/tui/tui-overlays.ts
new file mode 100644
index 000000000..51ba45a98
--- /dev/null
+++ b/src/tui/tui-overlays.ts
@@ -0,0 +1,19 @@
+import type { Component, TUI } from "@mariozechner/pi-tui";
+
+type OverlayHost = Pick<TUI, "showOverlay" | "hideOverlay" | "hasOverlay" | "setFocus">;
+
+export function createOverlayHandlers(host: OverlayHost, fallbackFocus: Component) {
+  const openOverlay = (component: Component) => {
+    host.showOverlay(component);
+  };
+
+  const closeOverlay = () => {
+    if (host.hasOverlay()) {
+      host.hideOverlay();
+      return;
+    }
+    host.setFocus(fallbackFocus);
+  };
+
+  return { openOverlay, closeOverlay };
+}
diff --git a/src/web/accounts.whatsapp-auth.test.ts b/src/web/accounts.whatsapp-auth.test.ts
new file mode 100644
index 000000000..9009025ef
--- /dev/null
+++ b/src/web/accounts.whatsapp-auth.test.ts
@@ -0,0 +1,63 @@
+import fs from "node:fs";
+import os from "node:os";
+import path from "node:path";
+import { afterEach, beforeEach, describe, expect, it } from "vitest";
+
+import { hasAnyWhatsAppAuth, listWhatsAppAuthDirs } from "./accounts.js";
+
+describe("hasAnyWhatsAppAuth", () => {
+  let previousOauthDir: string | undefined;
+  let tempOauthDir: string | undefined;
+
+  const writeCreds = (dir: string) => {
+    fs.mkdirSync(dir, { recursive: true });
+    fs.writeFileSync(path.join(dir, "creds.json"), JSON.stringify({ me: {} }));
+  };
+
+  beforeEach(() => {
+    previousOauthDir = process.env.CLAWDBOT_OAUTH_DIR;
+    tempOauthDir = fs.mkdtempSync(path.join(os.tmpdir(), "clawdbot-oauth-"));
+    process.env.CLAWDBOT_OAUTH_DIR = tempOauthDir;
+  });
+
+  afterEach(() => {
+    if (previousOauthDir === undefined) {
+      delete process.env.CLAWDBOT_OAUTH_DIR;
+    } else {
+      process.env.CLAWDBOT_OAUTH_DIR = previousOauthDir;
+    }
+    if (tempOauthDir) {
+      fs.rmSync(tempOauthDir, { recursive: true, force: true });
+      tempOauthDir = undefined;
+    }
+  });
+
+  it("returns false when no auth exists", () => {
+    expect(hasAnyWhatsAppAuth({})).toBe(false);
+  });
+
+  it("returns true when legacy auth exists", () => {
+    fs.writeFileSync(path.join(tempOauthDir ?? "", "creds.json"), JSON.stringify({ me: {} }));
+    expect(hasAnyWhatsAppAuth({})).toBe(true);
+  });
+
+  it("returns true when non-default auth exists", () => {
+    writeCreds(path.join(tempOauthDir ?? "", "whatsapp", "work"));
+    expect(hasAnyWhatsAppAuth({})).toBe(true);
+  });
+
+  it("includes authDir overrides", () => {
+    const customDir = fs.mkdtempSync(path.join(os.tmpdir(), "clawdbot-wa-auth-"));
+    try {
+      writeCreds(customDir);
+      const cfg = {
+        channels: { whatsapp: { accounts: { work: { authDir: customDir } } } },
+      };
+
+      expect(listWhatsAppAuthDirs(cfg)).toContain(customDir);
+      expect(hasAnyWhatsAppAuth(cfg)).toBe(true);
+    } finally {
+      fs.rmSync(customDir, { recursive: true, force: true });
+    }
+  });
+});
