diff --git a/scratch/clawline-client b/scratch/clawline-client
index e0019c701..ab319bfe3 160000
--- a/scratch/clawline-client
+++ b/scratch/clawline-client
@@ -1 +1 @@
-Subproject commit e0019c701e819295b8e0d3c4495f95216a9b03e1
+Subproject commit ab319bfe3ce36126f6b216d6cc8892ae14cbd5a5
diff --git a/scratch/clawline.prev b/scratch/clawline.prev
--- a/scratch/clawline.prev
+++ b/scratch/clawline.prev
@@ -1 +1 @@
-Subproject commit 207ea203d0e6befb976fb42a3e9056c34ac39e51
+Subproject commit 207ea203d0e6befb976fb42a3e9056c34ac39e51-dirty
diff --git a/src/clawline/adapter.test.ts b/src/clawline/adapter.test.ts
deleted file mode 100644
index 68a653359..000000000
--- a/src/clawline/adapter.test.ts
+++ /dev/null
@@ -1,131 +0,0 @@
-import fs from "node:fs/promises";
-import os from "node:os";
-import path from "node:path";
-
-import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
-
-import type { ClawdbotConfig } from "../config/config.js";
-import { createClawlineAdapter } from "./adapter.js";
-import { resolveClawlineConfig } from "./config.js";
-
-vi.mock("../agents/pi-embedded-runner.js", () => ({
-  runEmbeddedPiAgent: vi.fn(),
-}));
-
-const { runEmbeddedPiAgent } = await import("../agents/pi-embedded-runner.js");
-
-describe("createClawlineAdapter", () => {
-  let tmpDir: string;
-
-  beforeEach(async () => {
-    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), "clawline-test-"));
-    vi.mocked(runEmbeddedPiAgent).mockReset();
-  });
-
-  afterEach(async () => {
-    await fs.rm(tmpDir, { recursive: true, force: true });
-  });
-
-  function buildConfig(): ClawdbotConfig {
-    return {
-      agents: {
-        defaults: {
-          model: { primary: "anthropic/claude-sonnet-4-5" },
-          cliBackends: {
-            anthropic: {
-              command: "claude",
-            },
-          },
-          workspace: path.join(tmpDir, "workspace"),
-          timeoutSeconds: 30,
-        },
-      },
-    } as ClawdbotConfig;
-  }
-
-  it("lets pi runner resolve models when not overridden", async () => {
-    vi.mocked(runEmbeddedPiAgent).mockResolvedValue({ payloads: [{ text: "ok" }] });
-    const adapter = await createClawlineAdapter({
-      config: { agents: { defaults: {} } } as unknown as ClawdbotConfig,
-      statePath: tmpDir,
-    });
-    await adapter.execute({
-      prompt: "Hi",
-      sessionId: "sess",
-      userId: "user",
-      deviceId: "dev",
-    });
-    const call = vi.mocked(runEmbeddedPiAgent).mock.calls.at(-1)?.[0];
-    expect(call?.provider).toBeUndefined();
-    expect(call?.model).toBeUndefined();
-  });
-
-  it("parses inline provider/model override", async () => {
-    vi.mocked(runEmbeddedPiAgent).mockResolvedValue({ payloads: [{ text: "ok" }] });
-    const adapter = await createClawlineAdapter({
-      config: buildConfig(),
-      statePath: tmpDir,
-      clawlineConfig: resolveClawlineConfig({
-        clawline: { adapter: { model: "anthropic/claude-3-7" } },
-      } as ClawdbotConfig),
-    });
-    await adapter.execute({
-      prompt: "hi",
-      sessionId: "sess",
-      userId: "user",
-      deviceId: "dev",
-    });
-    const call = vi.mocked(runEmbeddedPiAgent).mock.calls.at(-1)?.[0];
-    expect(call?.provider).toBe("anthropic");
-    expect(call?.model).toBe("claude-3-7");
-  });
-
-  it("calls runEmbeddedPiAgent with derived session data", async () => {
-    vi.mocked(runEmbeddedPiAgent).mockResolvedValue({
-      payloads: [{ text: "Hello from agent" }],
-      meta: { durationMs: 10 },
-    });
-
-    const adapter = await createClawlineAdapter({
-      config: buildConfig(),
-      statePath: tmpDir,
-    });
-
-    const result = await adapter.execute({
-      prompt: "Hi there",
-      userId: "user_123",
-      sessionId: "sess_123",
-      deviceId: "device_a",
-    });
-
-    expect(runEmbeddedPiAgent).toHaveBeenCalledTimes(1);
-    const call = vi.mocked(runEmbeddedPiAgent).mock.calls[0]?.[0];
-    expect(call?.prompt).toBe("Hi there");
-    expect(call?.sessionId).toBe("sess_123");
-    expect(call?.provider).toBeUndefined();
-    expect(call?.model).toBeUndefined();
-    expect(result).toEqual({ exitCode: 0, output: "Hello from agent" });
-  });
-
-  it("returns non-zero exit when payload text missing", async () => {
-    vi.mocked(runEmbeddedPiAgent).mockResolvedValue({
-      payloads: [],
-      meta: { durationMs: 5 },
-    });
-    const adapter = await createClawlineAdapter({
-      config: buildConfig(),
-      statePath: tmpDir,
-      clawlineConfig: resolveClawlineConfig({
-        clawline: { adapter: { responseFallback: "No reply" } },
-      } as ClawdbotConfig),
-    });
-    const result = await adapter.execute({
-      prompt: "Hi",
-      userId: "user_x",
-      sessionId: "sess_x",
-      deviceId: "device_x",
-    });
-    expect(result.exitCode).toBe(1);
-    expect(result.output).toBe("No reply");
-  });
-});
diff --git a/src/clawline/adapter.ts b/src/clawline/adapter.ts
deleted file mode 100644
index 0bc6cfe4a..000000000
--- a/src/clawline/adapter.ts
+++ /dev/null
@@ -1,99 +0,0 @@
-import fs from "node:fs/promises";
-import path from "node:path";
-import { randomUUID } from "node:crypto";
-
-import type { ClawdbotConfig } from "../config/config.js";
-import {
-  resolveAgentWorkspaceDir,
-  resolveDefaultAgentId,
-} from "../agents/agent-scope.js";
-import type { EmbeddedPiRunResult } from "../agents/pi-embedded-runner.js";
-import { runEmbeddedPiAgent } from "../agents/pi-embedded-runner.js";
-import type { AdapterExecuteParams, Logger } from "./domain.js";
-import { resolveClawlineConfig, type ResolvedClawlineConfig } from "./config.js";
-
-export type AdapterResult = { exitCode: number; output: string };
-
-export type ClawlineAdapter = {
-  execute: (params: AdapterExecuteParams) => Promise<AdapterResult>;
-};
-
-type AdapterCreateParams = {
-  config: ClawdbotConfig;
-  statePath: string;
-  logger?: Logger;
-  clawlineConfig?: ResolvedClawlineConfig;
-};
-
-function extractText(result: EmbeddedPiRunResult): string | null {
-  const texts =
-    result.payloads
-      ?.map((entry) => entry.text?.trim())
-      .filter((value): value is string => Boolean(value)) ?? [];
-  if (texts.length === 0) return null;
-  return texts.join("\n\n");
-}
-
-export async function createClawlineAdapter(
-  params: AdapterCreateParams,
-): Promise<ClawlineAdapter> {
-  const logger = params.logger ?? console;
-  const resolved = params.clawlineConfig ?? resolveClawlineConfig(params.config);
-  const adapterProvider = resolved.adapterOverrides.provider?.trim() || undefined;
-  let adapterModel = resolved.adapterOverrides.model?.trim() || undefined;
-  let providerOverride = adapterProvider;
-  let modelOverride = adapterModel;
-  if (!providerOverride && adapterModel) {
-    const slash = adapterModel.indexOf("/");
-    if (slash > 0 && slash < adapterModel.length - 1) {
-      const provider = adapterModel.slice(0, slash).trim();
-      const model = adapterModel.slice(slash + 1).trim();
-      if (provider && model) {
-        providerOverride = provider;
-        modelOverride = model;
-      }
-    }
-  }
-  const timeoutSeconds =
-    resolved.adapterOverrides.timeoutSeconds ??
-    params.config.agents?.defaults?.timeoutSeconds ??
-    300;
-  const timeoutMs = Math.max(1, timeoutSeconds) * 1000;
-  const agentId = resolveDefaultAgentId(params.config);
-  const workspaceDir = resolveAgentWorkspaceDir(params.config, agentId);
-  const sessionDir = path.join(params.statePath, "sessions");
-  await fs.mkdir(sessionDir, { recursive: true });
-  return {
-    async execute(ctx) {
-      const sessionFile = path.join(sessionDir, `${ctx.userId}.jsonl`);
-      await fs.mkdir(path.dirname(sessionFile), { recursive: true });
-      const runId = randomUUID();
-      const result = await runEmbeddedPiAgent({
-        sessionId: ctx.sessionId,
-        sessionKey: ctx.sessionId,
-        sessionFile,
-        workspaceDir,
-        config: params.config,
-        prompt: ctx.prompt,
-        provider: providerOverride,
-        model: modelOverride,
-        thinkLevel: params.config.agents?.defaults?.thinkingDefault,
-        timeoutMs,
-        runId,
-        extraSystemPrompt: resolved.adapterOverrides.systemPrompt,
-        ownerNumbers: undefined,
-      });
-      const text = extractText(result);
-      if (!text) {
-        const fallback = resolved.adapterOverrides.responseFallback ?? "";
-        if (!fallback) {
-          logger.warn?.(
-            "[clawline] adapter returned no text; consider setting clawline.adapter.responseFallback",
-          );
-        }
-        return { exitCode: 1, output: fallback };
-      }
-      return { exitCode: 0, output: text };
-    },
-  };
-}
diff --git a/src/clawline/config.test.ts b/src/clawline/config.test.ts
index f07cb71da..8f9262b1e 100644
--- a/src/clawline/config.test.ts
+++ b/src/clawline/config.test.ts
@@ -45,4 +45,34 @@ describe("resolveClawlineConfig", () => {
     expect(cfg.network.allowInsecurePublic).toBe(true);
     expect(cfg.network.allowedOrigins).toEqual(["https://example.com"]);
   });
+
+  it("expands tildes in configurable paths", () => {
+    const cfg = resolveClawlineConfig({
+      clawline: {
+        statePath: "~/custom/clawline",
+        media: {
+          storagePath: "~/custom/media",
+        },
+      },
+    } as ClawdbotConfig);
+
+    expect(cfg.statePath).toBe(path.join(home, "custom", "clawline"));
+    expect(cfg.media.storagePath).toBe(
+      path.join(home, "custom", "media"),
+    );
+  });
+
+  it("resolves relative media paths to absolute", () => {
+    const cfg = resolveClawlineConfig({
+      clawline: {
+        media: {
+          storagePath: "relative/media",
+        },
+      },
+    } as ClawdbotConfig);
+
+    expect(cfg.media.storagePath).toBe(
+      path.resolve("relative/media"),
+    );
+  });
 });
diff --git a/src/clawline/config.ts b/src/clawline/config.ts
index adcb1fa18..267017aca 100644
--- a/src/clawline/config.ts
+++ b/src/clawline/config.ts
@@ -28,6 +28,23 @@ export type ClawlineConfigInput = {
 const defaultStatePath = path.join(os.homedir(), ".clawdbot", "clawline");
 const defaultMediaPath = path.join(os.homedir(), ".clawdbot", "clawline-media");
 
+function expandUserPath(input: string): string {
+  if (input === "~") {
+    return os.homedir();
+  }
+  if (input.startsWith("~/")) {
+    return path.join(os.homedir(), input.slice(2));
+  }
+  return input;
+}
+
+function resolvePathValue(value: string | undefined, fallback: string): string {
+  const trimmed = value?.trim();
+  const raw = trimmed && trimmed.length > 0 ? trimmed : fallback;
+  const expanded = expandUserPath(raw);
+  return path.isAbsolute(expanded) ? expanded : path.resolve(expanded);
+}
+
 const DEFAULTS: ResolvedClawlineConfig = {
   enabled: true,
   port: 18800,
@@ -83,8 +100,11 @@ export function resolveClawlineConfig(
     structuredClone(DEFAULTS) as ResolvedClawlineConfig,
     input as Partial<ResolvedClawlineConfig>,
   );
-  merged.statePath = merged.statePath || defaultStatePath;
-  merged.media.storagePath = merged.media.storagePath || defaultMediaPath;
+  merged.statePath = resolvePathValue(merged.statePath, defaultStatePath);
+  merged.media.storagePath = resolvePathValue(
+    merged.media.storagePath,
+    defaultMediaPath,
+  );
   const adapterOverrides: ClawlineAdapterOverrides = input.adapter
     ? { ...input.adapter }
     : {};
diff --git a/src/clawline/domain.ts b/src/clawline/domain.ts
index ad086c828..1feffa977 100644
--- a/src/clawline/domain.ts
+++ b/src/clawline/domain.ts
@@ -1,3 +1,6 @@
+import type { ClawdbotConfig } from "../config/config.js";
+import type { getReplyFromConfig } from "../auto-reply/reply.js";
+
 export type DeviceInfo = {
   platform: string;
   model: string;
@@ -10,6 +13,7 @@ export type AllowlistEntry = {
   claimedName?: string;
   deviceInfo: DeviceInfo;
   userId: string;
+  bindingId?: string;
   isAdmin: boolean;
   tokenDelivered: boolean;
   createdAt: number;
@@ -31,20 +35,6 @@ export type NormalizedAttachment =
   | { type: "image"; mimeType: string; data: string }
   | { type: "asset"; assetId: string };
 
-export type AdapterExecuteParams = {
-  prompt: string;
-  userId: string;
-  sessionId: string;
-  deviceId: string;
-};
-
-export interface Adapter {
-  capabilities?: { streaming?: boolean };
-  execute: (
-    params: AdapterExecuteParams
-  ) => Promise<{ exitCode: number; output: string } | { exitCode?: number; output?: string } | string>;
-}
-
 export interface ProviderConfig {
   port: number;
   statePath: string;
@@ -92,7 +82,8 @@ export interface ProviderConfig {
 
 export interface ProviderOptions {
   config?: Partial<ProviderConfig>;
-  adapter: Adapter;
+  clawdbotConfig: ClawdbotConfig;
+  replyResolver?: typeof getReplyFromConfig;
   logger?: Logger;
   sessionStorePath: string;
 }
diff --git a/src/clawline/server.ts b/src/clawline/server.ts
index 26cc528ff..550cffca5 100644
--- a/src/clawline/server.ts
+++ b/src/clawline/server.ts
@@ -10,8 +10,22 @@ import WebSocket, { WebSocketServer } from "ws";
 import jwt from "jsonwebtoken";
 import BetterSqlite3 from "better-sqlite3";
 import type { Database as SqliteDatabase } from "better-sqlite3";
+import type { MsgContext } from "../auto-reply/templating.js";
+import { dispatchReplyFromConfig } from "../auto-reply/reply/dispatch-from-config.js";
+import { createReplyDispatcher } from "../auto-reply/reply/reply-dispatcher.js";
+import { extractShortModelName } from "../auto-reply/reply/response-prefix-template.js";
+import type { ResponsePrefixContext } from "../auto-reply/reply/response-prefix-template.js";
+import type { ReplyPayload } from "../auto-reply/types.js";
+import { resolveAgentRoute } from "../routing/resolve-route.js";
+import {
+  resolveEffectiveMessagesConfig,
+  resolveHumanDelayConfig,
+  resolveIdentityName,
+} from "../agents/identity.js";
+import { updateLastRoute } from "../config/sessions.js";
 import { rawDataToString } from "../infra/ws.js";
 import { recordClawlineSessionActivity } from "./session-store.js";
+import type { ClawlineAdapterOverrides } from "./config.js";
 import {
   buildClawlineSessionKey,
   clawlineSessionFileName,
@@ -92,6 +106,18 @@ function sanitizeDeviceInfo(info: DeviceInfo): DeviceInfo {
   };
 }
 
+function derivePeerId(entry: AllowlistEntry): string {
+  const sources = [
+    entry.bindingId?.trim(),
+    entry.claimedName?.trim(),
+    entry.deviceInfo.model?.trim(),
+    entry.deviceInfo.platform?.trim(),
+    entry.userId.trim(),
+    entry.deviceId.trim(),
+  ].filter((value): value is string => Boolean(value && value.length > 0));
+  return sources[0] ?? entry.deviceId;
+}
+
 function normalizeAttachmentsInput(
   raw: unknown,
   mediaConfig: ProviderConfig["media"]
@@ -151,6 +177,50 @@ function normalizeAttachmentsInput(
   return { attachments, inlineBytes, assetIds };
 }
 
+function describeClawlineAttachments(
+  attachments: NormalizedAttachment[],
+  assetsDir: string,
+): string | null {
+  if (attachments.length === 0) {
+    return null;
+  }
+  const lines = attachments.map((attachment, index) => {
+    const label = `Attachment ${index + 1}`;
+    if (attachment.type === "asset") {
+      const assetPath = path.join(assetsDir, attachment.assetId);
+      return `${label}: uploaded asset ${attachment.assetId} at ${assetPath}`;
+    }
+    const approxBytes = Math.round((attachment.data.length / 4) * 3);
+    return `${label}: inline image (${attachment.mimeType}, ~${approxBytes} bytes)`;
+  });
+  return `Attachments:\n${lines.join("\n")}`;
+}
+
+function buildAssistantTextFromPayload(payload: ReplyPayload, fallback: string): string | null {
+  const parts: string[] = [];
+  const text = payload.text?.trim();
+  if (text) {
+    parts.push(text);
+  }
+  const mediaUrls = payload.mediaUrls?.length
+    ? payload.mediaUrls
+    : payload.mediaUrl
+      ? [payload.mediaUrl]
+      : [];
+  if (mediaUrls.length > 0) {
+    parts.push(mediaUrls.map((url) => `[media] ${url}`).join("\n"));
+  }
+  if (payload.isError && parts.length > 0) {
+    parts[0] = `⚠️ ${parts[0]}`;
+  }
+  const combined = parts.join("\n\n").trim();
+  if (combined) {
+    return combined;
+  }
+  const fallbackText = fallback.trim();
+  return fallbackText || null;
+}
+
 function timingSafeStringEqual(a: string, b: string): boolean {
   const bufA = Buffer.from(a);
   const bufB = Buffer.from(b);
@@ -193,6 +263,7 @@ type Session = {
   isAdmin: boolean;
   sessionId: string;
   sessionKey: string;
+  peerId: string;
   claimedName?: string;
   deviceInfo?: DeviceInfo;
 };
@@ -365,18 +436,6 @@ function hashAttachments(attachments: NormalizedAttachment[]): string {
   return sha256(`[${parts.join(",")}]`);
 }
 
-type AdapterExecutionResult = { exitCode?: number; output?: string } | string;
-
-function normalizeAdapterResult(result: AdapterExecutionResult): { exitCode: number; output: string } {
-  if (typeof result === "string") {
-    return { exitCode: 0, output: result };
-  }
-  return {
-    exitCode: result?.exitCode ?? 0,
-    output: result?.output ?? ""
-  };
-}
-
 function nowMs(): number {
   return Date.now();
 }
@@ -389,25 +448,15 @@ function generateUserId(): string {
   return `user_${randomUUID()}`;
 }
 
-function buildPromptFromEvents(
-  events: ServerMessage[],
-  maxPromptMessages: number,
-  appendedUserContent: string
-): string {
-  const trimmed = events
-    .filter((event) => event.role === "user" || event.role === "assistant")
-    .slice(-maxPromptMessages + 1);
-  const lines = trimmed.map((event) => `${event.role === "user" ? "User" : "Assistant"}: ${event.content}`);
-  lines.push(`User: ${appendedUserContent}`);
-  return lines.join("\n");
-}
-
 function parseServerMessage(json: string): ServerMessage {
   return JSON.parse(json) as ServerMessage;
 }
 
 export async function createProviderServer(options: ProviderOptions): Promise<ProviderServer> {
   const config = mergeConfig(options.config);
+  const adapterOverrides =
+    ((options.config as { adapterOverrides?: ClawlineAdapterOverrides } | undefined)?.adapterOverrides) ?? {};
+  const clawdbotCfg = options.clawdbotConfig;
   const logger: Logger = options.logger ?? console;
   const sessionStorePath = options.sessionStorePath;
   
@@ -1127,13 +1176,6 @@ export async function createProviderServer(options: ProviderOptions): Promise<Pr
     return event;
   }
 
-  function getConversationEvents(userId: string) {
-    const rows = db
-      .prepare(`SELECT payloadJson FROM events WHERE userId = ? ORDER BY sequence ASC LIMIT ?`)
-      .all(userId, config.sessions.maxPromptMessages - 1) as Array<{ payloadJson: string }>;
-    return rows.map((row) => parseServerMessage(row.payloadJson));
-  }
-
   function removeSession(session: Session) {
     sessionsByDevice.delete(session.deviceId);
     const sessions = userSessions.get(session.userId);
@@ -1247,43 +1289,105 @@ export async function createProviderServer(options: ProviderOptions): Promise<Pr
         });
         broadcastToUser(session.userId, event);
 
-        const priorEvents = getConversationEvents(session.userId);
-        const prompt = buildPromptFromEvents(priorEvents, config.sessions.maxPromptMessages, payload.content);
-        try {
-          const adapterResult = await Promise.race<AdapterExecutionResult>([
-            options.adapter.execute({
-              prompt,
-              userId: session.userId,
-              sessionId: session.sessionId,
-              deviceId: session.deviceId
-            }),
-            new Promise((_, reject) =>
-              setTimeout(() => reject(new Error("adapter_timeout")), config.sessions.adapterExecuteTimeoutSeconds * 1000)
-            )
-          ]);
-          const normalizedResult = normalizeAdapterResult(adapterResult);
-          if ((normalizedResult.exitCode ?? 0) !== 0) {
-            updateMessageStreamingStmt.run(MessageStreamingState.Failed, session.deviceId, payload.id);
-            await sendJson(session.socket, {
-              type: "error",
-              code: "server_error",
-              message: "Adapter error",
-              messageId: payload.id
+        const attachmentSummary = describeClawlineAttachments(
+          attachmentsInfo.attachments,
+          assetsDir,
+        );
+        const inboundBody = attachmentSummary
+          ? `${payload.content}\n\n${attachmentSummary}`
+          : payload.content;
+        const peerId = session.peerId;
+        const route = resolveAgentRoute({
+          cfg: clawdbotCfg,
+          channel: "clawline",
+          peer: { kind: "dm", id: peerId },
+        });
+
+        const ctxPayload: MsgContext = {
+          Body: inboundBody,
+          RawBody: payload.content,
+          CommandBody: payload.content,
+          From: `clawline:${peerId}`,
+          To: `device:${session.deviceId}`,
+          SessionKey: route.sessionKey,
+          AccountId: route.accountId,
+          MessageSid: payload.id,
+          ChatType: "direct",
+          SenderName: session.claimedName ?? session.deviceInfo?.model ?? peerId,
+          SenderId: peerId,
+          Provider: "clawline",
+          Surface: "clawline",
+          OriginatingChannel: "clawline",
+          OriginatingTo: peerId,
+        };
+
+        await updateLastRoute({
+          storePath: sessionStorePath,
+          sessionKey: route.mainSessionKey,
+          channel: "clawline",
+          to: peerId,
+          accountId: route.accountId,
+        });
+
+        const fallbackText = adapterOverrides.responseFallback?.trim() ?? "";
+        const prefixContext: ResponsePrefixContext = {
+          identityName: resolveIdentityName(clawdbotCfg, route.agentId),
+        };
+
+        const dispatcher = createReplyDispatcher({
+          responsePrefix: resolveEffectiveMessagesConfig(clawdbotCfg, route.agentId).responsePrefix,
+          responsePrefixContextProvider: () => prefixContext,
+          humanDelay: resolveHumanDelayConfig(clawdbotCfg, route.agentId),
+          deliver: async (replyPayload) => {
+            const assistantText = buildAssistantTextFromPayload(replyPayload, fallbackText);
+            if (!assistantText) {
+              return;
+            }
+            const assistantEvent = await persistAssistantMessage(session, assistantText);
+            broadcastToUser(session.userId, assistantEvent);
+          },
+          onError: (err, info) => {
+            logger.error?.("[clawline] reply_delivery_failed", {
+              kind: info.kind,
+              error: err instanceof Error ? err.message : String(err),
             });
-            return;
-          }
-          const assistantEvent = await persistAssistantMessage(session, normalizedResult.output ?? "");
-          broadcastToUser(session.userId, assistantEvent);
-          updateMessageStreamingStmt.run(MessageStreamingState.Finalized, session.deviceId, payload.id);
-        } catch {
+          },
+        });
+
+        let queuedFinal = false;
+        try {
+          const result = await dispatchReplyFromConfig({
+            ctx: ctxPayload,
+            cfg: clawdbotCfg,
+            dispatcher,
+            replyOptions: {
+              onModelSelected: (ctx) => {
+                prefixContext.provider = ctx.provider;
+                prefixContext.model = extractShortModelName(ctx.model);
+                prefixContext.modelFull = `${ctx.provider}/${ctx.model}`;
+                prefixContext.thinkingLevel = ctx.thinkLevel ?? "off";
+              },
+            },
+            replyResolver: options.replyResolver,
+          });
+          queuedFinal = result.queuedFinal;
+        } catch (err) {
+          logger.error?.("[clawline] dispatch_failed", err);
+          queuedFinal = false;
+        }
+        await dispatcher.waitForIdle();
+
+        if (!queuedFinal) {
           updateMessageStreamingStmt.run(MessageStreamingState.Failed, session.deviceId, payload.id);
           await sendJson(session.socket, {
             type: "error",
             code: "server_error",
-            message: "Adapter failure",
-            messageId: payload.id
+            message: "Unable to deliver reply",
+            messageId: payload.id,
           });
+          return;
         }
+        updateMessageStreamingStmt.run(MessageStreamingState.Finalized, session.deviceId, payload.id);
       });
     } catch (err) {
       if (err instanceof ClientMessageError) {
@@ -1495,8 +1599,15 @@ export async function createProviderServer(options: ProviderOptions): Promise<Pr
     }
 
     if (entry && entry.tokenDelivered) {
-      logger.warn?.("[clawline:http] pair_request_duplicate_device", { deviceId });
-      await sendJson(ws, { type: "error", code: "invalid_message", message: "Device already paired" });
+      logger.info?.("[clawline:http] pair_request_token_redispatch", { deviceId });
+      const token = issueToken(entry);
+      const delivered = await sendJson(ws, { type: "pair_result", success: true, token, userId: entry.userId })
+        .then(() => true)
+        .catch(() => false);
+      if (delivered) {
+        await updateLastSeen(entry.deviceId, nowMs());
+        await setTokenDelivered(entry.deviceId, true);
+      }
       ws.close();
       return;
     }
@@ -1585,6 +1696,7 @@ export async function createProviderServer(options: ProviderOptions): Promise<Pr
       return;
     }
     const sessionKey = buildClawlineSessionKey(entry.userId, entry.deviceId);
+    const peerId = derivePeerId(entry);
     const session: Session = {
       socket: ws,
       deviceId: entry.deviceId,
@@ -1592,6 +1704,7 @@ export async function createProviderServer(options: ProviderOptions): Promise<Pr
       isAdmin: entry.isAdmin,
       sessionId: `session_${randomUUID()}`,
       sessionKey,
+      peerId,
       claimedName: entry.claimedName,
       deviceInfo: entry.deviceInfo,
     };
diff --git a/src/clawline/service.ts b/src/clawline/service.ts
index 3c1047baa..7b327fa87 100644
--- a/src/clawline/service.ts
+++ b/src/clawline/service.ts
@@ -1,6 +1,5 @@
 import type { ClawdbotConfig } from "../config/config.js";
 import { resolveStorePath } from "../config/sessions.js";
-import { createClawlineAdapter } from "./adapter.js";
 import { resolveClawlineConfig } from "./config.js";
 import { createProviderServer } from "./server.js";
 import type { Logger, ProviderServer } from "./domain.js";
@@ -19,16 +18,10 @@ export async function startClawlineService(params: {
     logger.info?.("[clawline] service disabled in config");
     return null;
   }
-  const adapter = await createClawlineAdapter({
-    config: params.config,
-    statePath: resolved.statePath,
-    logger,
-    clawlineConfig: resolved,
-  });
   const sessionStorePath = resolveStorePath(params.config.session?.store);
   const server: ProviderServer = await createProviderServer({
     config: resolved,
-    adapter,
+    clawdbotConfig: params.config,
     logger,
     sessionStorePath,
   });
